## let's try our vim script out

## symlink where gimp can find it:

ls /Users/danthomas/Documents/speckling/center/scriptfu/make_spot_polygons.scm 

ln -s /Users/danthomas/Documents/speckling/center/scriptfu/make_spot_polygons.scm "/Users/danthomas/Library/Application Support/GIMP/2.8/scripts/make_spot_polygons.scm" 

$gimp -i --verbose -b '(make_spot_polygons "/Users/danthomas/Documents/speckling/demo/test_spots3.png" "mooptest")' -b '(gimp-quit 0)'

## new install not working, missing "gdb". What is this? 

brew search gdb

brew info gdb

## then had to do a bunch of certificate stuff, info here: <https://sourceware.org/gdb/wiki/BuildingOnDarwin>

## to find out where gdb lives:

type -a gdb ## its in /usr/local/bin

## but 

ls -l /usr/local/bin/gdb

## its a soft link to our homebrew cellar:

ls -l /usr/local/Cellar/gdb/8.1/bin/gdb

## not writable. I want to keep it that way. So mac wants sudo or gui password input

codesign -s gdb-cert /usr/local/Cellar/gdb/8.1/bin/gdb

## okay, did this help?

$gimp -i --verbose -b '(make_spot_polygons "/Users/danthomas/Documents/speckling/demo/test_spots3.png" "mooptest")' -b '(gimp-quit 0)'

## and then a mountain of errors from gdb, about shared library incompatibilites. 

## meh. fuck all that. The command line will not work for my setup. It's not worth the time
## to now debug gdb for my setup. Too deep for me. 

## let's try just using the console while gimp is running. Then maybe we can make a macro 
## instead of a script. 

## example file: "/Users/danthomas/Documents/speckling/demo/test_spots3.png"

    (let* (
            ;; load files, set vars
            (image (car (gimp-file-load 
                                0 
                                "/Users/danthomas/Documents/speckling/demo/test_spots3.png" 
                                "/Users/danthomas/Documents/speckling/demo/test_spots3.png") ) )
            (drawable (car (gimp-image-get-active-layer image)))
          )
            ;; do stuff
            ;;1 select black/solid regions:
            (gimp-image-select-color 
                image
                CHANNEL-OP-REPLACE
                drawable
                '(0 0 0) ;; black
            ) ;'
            ;;2 Convert selection to path
            (plug-in-sel2path
                RUN-NONINTERACTIVE
                image
                drawable
            ) 
            ;;3 save path to file
        (gimp-vectors-export-to-file
            image
            "/Users/danthomas/Documents/speckling/make_polygons/spots_script_test.svg"
            0 ;; all vectors
        )
)

## so that works for copying and pasting to the console in GIMP.

## we need to either write a macro for running in the GUI that can handle lots of images or 
## try again with the command line. 


## I personally like the idea of the latter. But I still have no idea 
## how to run gimp command line from the terminal

## can we run the above from the terminal?


## we need to put a copy (symlink) where git wants it:

ln -s /Users/danthomas/Documents/speckling/make_polygons/make_spot_polygons.scm \
"/Users/danthomas/Library/Application Support/GIMP/2.10/scripts/make_spot_polygons.scm"

ls -l "/Users/danthomas/Library/Application Support/GIMP/2.10/scripts/"


ls /Applications/Gimp-2.10.app/Contents/MacOS/gimp-console-2.10

/Applications/Gimp-2.10.app/Contents/MacOS/gimp-console-2.10

## theoretically, we should be able to run this like so:
~/GIMP.app/Contents/MacOS/gimp-2.8 -i

## none of the above works. As before. I think the best strategy here is to try this on my
## linux machine, see if the same bugs pop up. 
cd /home/daniel/mimulusSpeckling/make_polygons


## all the above was for the lab mac. 

## try again with my linux laptop

## where to put gimp scripts on my laptop?

## here I think:
cd ~/.gimp-2.8/scripts

ls -al ~/.gimp-2.8/scripts

ln -s /home/daniel/mimulusSpeckling/make_polygons/make_spot_polygons.scm ~/.gimp-2.8/scripts/make_spot_polygons.scm 

## can we run it?


gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## let's do a test with a script from online:

gimp -i -b '(test-script "foo.png" 5.0 0.5 0)' -b '(gimp-quit 0)'

## okay works...why not ours?

## why is the the script name parsed as an undeclared variable?

cd ../demo
gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'
## nope

## is it because it is a symlink?

cp /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm /home/daniel/.gimp-2.8/scripts/

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## ah, that worked!
## is this a permission issue?

chmod 777 /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm

## try again

ln -s /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm ~/.gimp-2.8/scripts/makePetalPoly.scm 

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## yep. I feel pretty stupid. But good to know that symlink permissions 
## don't really mean anything

## sweet, so:

## 1 edit script to export other filenames that are related to the entered file
## 2 find a way to handle multiple files - either with bash or in scriptfu

## 1 should be simple?

## okay, works. 

#######################################

## back up. We need to use Doug's structures to generate binary pngs 
## that gimp will like. 

## since matlab sucks, as in not-free and license issues are complex
## even when paid for, we'll try octave here

## I'm waiting on the math department to talk to me about the desktop
## license at the lab.`

octave-cli

## get one of Doug's data structures:

load("/home/daniel/Documents/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P431F1.mat")

Petals

fieldnames(Petals)

Petals.left

fieldnames(Petals.left)

Petals.left.data

## can we turn this into an image?

fieldnames(Petals.right)

fieldnames(Petals.Clusters)

Petals.Clusters.left

imshow(Petals.Clusters.left) %% doesn't work

image(Petals.Clusters.left) %% works. Don't know why

image(Petals.Clusters.right); colorbar

%% get the image package 
pkg load image

aa = mat2gray(Petals.Clusters.right);

imshow(aa) %% that works. 

unique(aa) %% all values transformed to between 1 and 0. 
%% 1 is white, 0 is black

%% now we want a petal and a spot image. To do this:

%% get the spot shapes as black, background as white:
bb = aa < 1;
imshow(bb); 

%% petals black with white background
cc = aa == 0;
imshow(cc); 

%% okay. These should be digestable for our GIMP scripts. 

%% export:

imwrite(bb, 'P431F1_bottom_spots.png') %% some quality warnings. 
imwrite(cc, 'P431F1_bottom_petal.png')

%% can we get these to gimp now, and get svgs for both?

## shell/gimp

## ugh, got to remember how to use Gimp from command line 
## with our script...

## we have our scriptfu for this, does this work?:

gimp -i -b '(makePetalPoly "P431F1_bottom_spots.png")' -b '(gimp-quit 0)'

## nope.  What changed? the old command that worked:

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## doesn't work now... did I change something accidentally?

git log makePetalPoly.scm


## not really. The file worked on the last day it was modified.

## can we bring up the older versions, see if they work?

git checkout 759701d0688c1c08e76ca876dc25d08e122b09c4 makePetalPoly.scm

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## nope. What changed?

## looks like the link might be dead...

ln -s /home/daniel/Documents/mimulusSpeckling/make_polygons/makePetalPoly.scm /home/daniel/.gimp-2.8/scripts/makePetalPoly.scm

## work now?

gimp -i -b '(makePetalPoly "P431F1_bottom_spots.png")' -b '(gimp-quit 0)'

## yup, works. Note to self, watch those directory changes...remember they fuck with links 

## now can we flatten the svg bezier curves?

## ugh, all this would be so much more elegant with python. 
## http://scikit-image.org/docs/dev/api/skimage.draw.html

## anyway..

## so with svg bezier curves, we want to be rid of the control points 
## leave just the terminal points

## first get the svg to work,
## then figure out how to clean it all out so matlab can read it.

cp P431F1_bottom_spots.png_path.svg test.svg

## for svg, to flatten the beziers,
## change all C's to L's
## and get rid of the control points (keep only the first set of coordinates)

sed '/^\s*C/ s/C\s/L /' test.svg | \
sed -e 's/\([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\) \([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\) \([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\)/\1/g' > test2.svg

## okay, that seems to work...but the paths have been clipped somehow, which leaves 
## unclosed polygons. This must have happened during the gimp export?

## nope, the svg with the beziers is not broken, at least according to inkscape.
## so we introduced this with our SED modification

tail test.svg

tail test2.svg

## actually, it's ok. The svg lines do close up in both files, you just have to
## expand the svg canvas to see a little. 

## ok, relief. So...what do we need for matlab to understand that these are 
## polygons?

## gimp needs two vectors, x and y. 

## how can we convert our svg to this? 

## a couple of problems here.

## 1) get rid of chaff - remove all the non-drawing directions
## 2) break up the respective polygons
## 3) convert each polygon to two vectors, x and y. 

## this really needs some python. Sorry Doug. 

## which probably means we should back up and use a 
## single python script to fix our svgs in general
## (so I just spent an hour on a SED regex I don't need).
## good news is that the script should be fairly straight forward.

## actually, why use svgs at all? If we're going to 
## python, let's do it right and get our edge detection
## done with that

## hah. into the best rabbit hole I know...


########################################################

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

## bring in our petal image:

bb = io.imread('P431F1_bottom_spots.png')
io.imshow(bb)
io.show()

cc = io.imread('P431F1_bottom_petal.png')
io.imshow(cc)
io.show()

edges = filters.sobel(bb)
io.imshow(edges)
io.show()

## okay, can we turn this into a polygon?

## meaning, can it be approximated into a 
## series of vertices? 

## what value are we chasing?

np.unique(edges)

## huh. 7 non-zero values...

contours = measure.find_contours(edges, 0.5)

type(contours)

contours[0].shape

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)


## almost works, but we're losing information by the png 
## conversion, methinks.

## so... back to octave/matlab:

####################################################

octave-cli

pkg load image

## get one grayscale image:

load("../dougRaster/Rotated_and_Cropped/P431F1.mat")
aa = mat2gray(Petals.Clusters.right);

Petals.Clusters.right

spots = aa < 1;
imshow(spots);

petal = aa == 0;
imshow(petal);

## save them as csv's:

csvwrite('P431F1petal.csv',petal)
csvwrite('P431F1spots.csv',spots)

%% and back to python...
#########################

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

petal = np.genfromtxt ('P431F1petal.csv', delimiter=",")
spots = np.genfromtxt ('P431F1spots.csv', delimiter=",")

np.unique(petal)

np.unique(spots)

## try spots

## can contours handle these directly?
contours = measure.find_contours(spots, 0)
for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.show()

## not bad, but still gaps...

contours = measure.find_contours(spots, 0)
for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

## same. Try finding the edges first:


edges = filters.sobel(spots)

io.imshow(edges)
io.show()

np.unique(edges)

contours = measure.find_contours(edges, 0.5)

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.show()

## same problem. can we add a margin of white to our 
## matrix?

## jog my memory, how to work with numpy again...

a = np.array([[1, 1], [2, 2], [3, 3]])

a
a = np.insert(a, 0, 5, 1)
a

a = np.array([[1, 1], [2, 2], [3, 3]])
np.insert(a, 0, 5, 0)

## rows are axis zero, columns axis one

a = np.array([[1, 1], [2, 2], [3, 3]])

a.shape
np.insert(a, 0, [6,6,6], 1)
np.insert(a, 2, [6,6,6], 1)

a = np.array([[1, 1], [2, 2], [3, 3]])
b = np.insert(a, 2, [6,6,6], 1) ## might be a more elegant way...

## can we add more than one column at a time?

a = np.array([[1, 1], [2, 2], [3, 3]])
b = np.insert(a, 2, [[5,5,5],[6,6,6]], 1)

## works, but probably better to build another matrix 
## and concatenate it 

## for our images, our polygons are black, = 0's

## so we want to add white space, or 1's. 

## seems pretty simple. try it with one of our images:


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

petal = np.genfromtxt ('P431F1petal.csv', delimiter=",")
spots = np.genfromtxt ('P431F1spots.csv', delimiter=",")

petal.shape
## (561, 439)

spots.shape
## same

## looks like the rows/columns are transposed 
## automatically by the scikit-image?

## to add one pixel of white to columns:
spots_marg = np.insert(spots, 439, 1, 1) 
spots_marg = np.insert(spots_marg, 0, 1, 1) 
## and rows:
spots_marg = np.insert(spots_marg, 561, 1, 0) 
spots_marg = np.insert(spots_marg, 0, 1, 0) 

spots.shape
spots_marg.shape


## does this help the detection of the polygons?

contours = measure.find_contours(spots_marg, 0)

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)


plt.show()


## to keep the relative positions accurate, we have to do the
## the same with the petal outline:

petal_marg = np.insert(petal, 439, 1, 1) 
petal_marg = np.insert(petal_marg, 0, 1, 1) 
## and rows:
petal_marg = np.insert(petal_marg, 561, 1, 0) 
petal_marg = np.insert(petal_marg, 0, 1, 0) 

Pcontours = measure.find_contours(petal_marg, 0)

## how does it look?:

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.plot(Pcontours[0][:,1], Pcontours[0][:,0], linewidth=1)

plt.show()

## looks good. 

## 1) Can we give these to Matlab?

## and if so, 

## 2) we need a script to generalize this. 

## 3) and a bash script that will work for anyone to repeat. 

## update notebook, then do these things. 

## okay, can we export one of these so that octave can read it?

## CSV is a little problematic, because we need a new for each 
## polygon.

## but building a json of nested arrays that python will make and 
## matlab will parse, sounds more tricky than I want to take on. 

np.savetxt("P431F1petal_polys.csv", contours) ## doesn't work

contours[0]

contours[0].astype(int)

## loop through the various polygons, save them individually?

photoname = 'P431F1'
partname  = 'spots'
petalname = 'bottom'

for n, contour in enumerate(contours):
    polyname = photoname + petalname + partname + str(n) + "_poly.csv"
    print(polyname)
    np.savetxt(fname=polyname, X=contour.astype(int), delimiter=',') 

## looks good. 

## so now the challenge is, given a single image, make a function 
## that exports the petal outline and all the respective 

## we start with..? a csv from matlab, which is the grayscale matrix
## of a single petal image:

## remember that as we have it here, we get a petal and a spots
## csv from matlab/octave. 

## but it is the same process for both. Make this agnostic: 


## get_pols.py
#################################3
#!/usr/bin/env python3

import argparse
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

## instantiate the argparser
parser = argparse.ArgumentParser()

## argument:
parser.add_argument('file', 
            help="Name of the .csv file from matlab that contains grayscale information about a petal.")

args = parser.parse_args()

## get our image in...
aa  = np.genfromtxt(args.file, delimiter = ",")

aR = aa.shape[0] ## number of rows
aC = aa.shape[1] ## number of cols

## add one pixel of white to rows:
aa_marg = np.insert(aa, aR, 1, 0)
aa_marg = np.insert(aa_marg, 0, 1, 0)
## and columns:
aa_marg = np.insert(aa_marg, aC, 1, 1)
aa_marg = np.insert(aa_marg, 0, 1, 1)

## find the contours:
contours = measure.find_contours(aa_marg, 0)

## save them out:

imageName = args.file[:-4] ## no file extension

for n, contour in enumerate(contours):
    polyname = imageName + "_poly" + str(n) + ".csv"
    np.savetxt(fname=polyname, X=contour.astype(int), delimiter=',')

#####################################

## try this out on one of our CSvs from matlab:

./get_pols.py P431F1spots.csv

## seems to work, but we'll need to check this
## out on matlab tomorrow. 

## how can we make this cleaner? We want to output
## to a folder...



