## let's try our vim script out

## symlink where gimp can find it:

ls /Users/danthomas/Documents/speckling/center/scriptfu/make_spot_polygons.scm 

ln -s /Users/danthomas/Documents/speckling/center/scriptfu/make_spot_polygons.scm "/Users/danthomas/Library/Application Support/GIMP/2.8/scripts/make_spot_polygons.scm" 

$gimp -i --verbose -b '(make_spot_polygons "/Users/danthomas/Documents/speckling/demo/test_spots3.png" "mooptest")' -b '(gimp-quit 0)'

## new install not working, missing "gdb". What is this? 

brew search gdb

brew info gdb

## then had to do a bunch of certificate stuff, info here: <https://sourceware.org/gdb/wiki/BuildingOnDarwin>

## to find out where gdb lives:

type -a gdb ## its in /usr/local/bin

## but 

ls -l /usr/local/bin/gdb

## its a soft link to our homebrew cellar:

ls -l /usr/local/Cellar/gdb/8.1/bin/gdb

## not writable. I want to keep it that way. So mac wants sudo or gui password input

codesign -s gdb-cert /usr/local/Cellar/gdb/8.1/bin/gdb

## okay, did this help?

$gimp -i --verbose -b '(make_spot_polygons "/Users/danthomas/Documents/speckling/demo/test_spots3.png" "mooptest")' -b '(gimp-quit 0)'

## and then a mountain of errors from gdb, about shared library incompatibilites. 

## meh. fuck all that. The command line will not work for my setup. It's not worth the time
## to now debug gdb for my setup. Too deep for me. 

## let's try just using the console while gimp is running. Then maybe we can make a macro 
## instead of a script. 

## example file: "/Users/danthomas/Documents/speckling/demo/test_spots3.png"

    (let* (
            ;; load files, set vars
            (image (car (gimp-file-load 
                                0 
                                "/Users/danthomas/Documents/speckling/demo/test_spots3.png" 
                                "/Users/danthomas/Documents/speckling/demo/test_spots3.png") ) )
            (drawable (car (gimp-image-get-active-layer image)))
          )
            ;; do stuff
            ;;1 select black/solid regions:
            (gimp-image-select-color 
                image
                CHANNEL-OP-REPLACE
                drawable
                '(0 0 0) ;; black
            ) ;'
            ;;2 Convert selection to path
            (plug-in-sel2path
                RUN-NONINTERACTIVE
                image
                drawable
            ) 
            ;;3 save path to file
        (gimp-vectors-export-to-file
            image
            "/Users/danthomas/Documents/speckling/make_polygons/spots_script_test.svg"
            0 ;; all vectors
        )
)

## so that works for copying and pasting to the console in GIMP.

## we need to either write a macro for running in the GUI that can handle lots of images or 
## try again with the command line. 


## I personally like the idea of the latter. But I still have no idea 
## how to run gimp command line from the terminal

## can we run the above from the terminal?


## we need to put a copy (symlink) where git wants it:

ln -s /Users/danthomas/Documents/speckling/make_polygons/make_spot_polygons.scm \
"/Users/danthomas/Library/Application Support/GIMP/2.10/scripts/make_spot_polygons.scm"

ls -l "/Users/danthomas/Library/Application Support/GIMP/2.10/scripts/"


ls /Applications/Gimp-2.10.app/Contents/MacOS/gimp-console-2.10

/Applications/Gimp-2.10.app/Contents/MacOS/gimp-console-2.10

## theoretically, we should be able to run this like so:
~/GIMP.app/Contents/MacOS/gimp-2.8 -i

## none of the above works. As before. I think the best strategy here is to try this on my
## linux machine, see if the same bugs pop up. 
cd /home/daniel/mimulusSpeckling/make_polygons


## all the above was for the lab mac. 

## try again with my linux laptop

## where to put gimp scripts on my laptop?

## here I think:
cd ~/.gimp-2.8/scripts

ls -al ~/.gimp-2.8/scripts

ln -s /home/daniel/mimulusSpeckling/make_polygons/make_spot_polygons.scm ~/.gimp-2.8/scripts/make_spot_polygons.scm 

## can we run it?


gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## let's do a test with a script from online:

gimp -i -b '(test-script "foo.png" 5.0 0.5 0)' -b '(gimp-quit 0)'

## okay works...why not ours?

## why is the the script name parsed as an undeclared variable?

cd ../demo
gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'
## nope

## is it because it is a symlink?

cp /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm /home/daniel/.gimp-2.8/scripts/

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## ah, that worked!
## is this a permission issue?

chmod 777 /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm

## try again

ln -s /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm ~/.gimp-2.8/scripts/makePetalPoly.scm 

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## yep. I feel pretty stupid. But good to know that symlink permissions 
## don't really mean anything

## sweet, so:

## 1 edit script to export other filenames that are related to the entered file
## 2 find a way to handle multiple files - either with bash or in scriptfu

## 1 should be simple?

## okay, works. 

#######################################

## back up. We need to use Doug's structures to generate binary pngs 
## that gimp will like. 

## since matlab sucks, as in not-free and license issues are complex
## even when paid for, we'll try octave here

## I'm waiting on the math department to talk to me about the desktop
## license at the lab.`

octave-cli

## get one of Doug's data structures:

load("/home/daniel/Documents/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P431F1.mat")

Petals

fieldnames(Petals)

Petals.left

fieldnames(Petals.left)

Petals.left.data

## can we turn this into an image?

fieldnames(Petals.right)

fieldnames(Petals.Clusters)

Petals.Clusters.left

imshow(Petals.Clusters.left) %% doesn't work

image(Petals.Clusters.left) %% works. Don't know why

image(Petals.Clusters.right); colorbar

%% get the image package 
pkg load image

aa = mat2gray(Petals.Clusters.right);

imshow(aa) %% that works. 

unique(aa) %% all values transformed to between 1 and 0. 
%% 1 is white, 0 is black

%% now we want a petal and a spot image. To do this:

%% get the spot shapes as black, background as white:
bb = aa < 1;
imshow(bb); 

%% petals black with white background
cc = aa == 0;
imshow(cc); 

%% okay. These should be digestable for our GIMP scripts. 

%% export:

imwrite(bb, 'P431F1_bottom_spots.png') %% some quality warnings. 
imwrite(cc, 'P431F1_bottom_petal.png')

%% can we get these to gimp now, and get svgs for both?

## shell/gimp

## ugh, got to remember how to use Gimp from command line 
## with our script...

## we have our scriptfu for this, does this work?:

gimp -i -b '(makePetalPoly "P431F1_bottom_spots.png")' -b '(gimp-quit 0)'

## nope.  What changed? the old command that worked:

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## doesn't work now... did I change something accidentally?

git log makePetalPoly.scm


## not really. The file worked on the last day it was modified.

## can we bring up the older versions, see if they work?

git checkout 759701d0688c1c08e76ca876dc25d08e122b09c4 makePetalPoly.scm

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## nope. What changed?

## looks like the link might be dead...

ln -s /home/daniel/Documents/mimulusSpeckling/make_polygons/makePetalPoly.scm /home/daniel/.gimp-2.8/scripts/makePetalPoly.scm

## work now?

gimp -i -b '(makePetalPoly "P431F1_bottom_spots.png")' -b '(gimp-quit 0)'

## yup, works. Note to self, watch those directory changes...remember they fuck with links 

## now can we flatten the svg bezier curves?

## ugh, all this would be so much more elegant with python. 
## http://scikit-image.org/docs/dev/api/skimage.draw.html

## anyway..

## so with svg bezier curves, we want to be rid of the control points 
## leave just the terminal points

## first get the svg to work,
## then figure out how to clean it all out so matlab can read it.

cp P431F1_bottom_spots.png_path.svg test.svg

## for svg, to flatten the beziers,
## change all C's to L's
## and get rid of the control points (keep only the first set of coordinates)

sed '/^\s*C/ s/C\s/L /' test.svg | \
sed -e 's/\([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\) \([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\) \([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\)/\1/g' > test2.svg

## okay, that seems to work...but the paths have been clipped somehow, which leaves 
## unclosed polygons. This must have happened during the gimp export?

## nope, the svg with the beziers is not broken, at least according to inkscape.
## so we introduced this with our SED modification

tail test.svg

tail test2.svg

## actually, it's ok. The svg lines do close up in both files, you just have to
## expand the svg canvas to see a little. 

## ok, relief. So...what do we need for matlab to understand that these are 
## polygons?

## gimp needs two vectors, x and y. 

## how can we convert our svg to this? 

## a couple of problems here.

## 1) get rid of chaff - remove all the non-drawing directions
## 2) break up the respective polygons
## 3) convert each polygon to two vectors, x and y. 

## this really needs some python. Sorry Doug. 

## which probably means we should back up and use a 
## single python script to fix our svgs in general
## (so I just spent an hour on a SED regex I don't need).
## good news is that the script should be fairly straight forward.

## actually, why use svgs at all? If we're going to 
## python, let's do it right and get our edge detection
## done with that

## hah. into the best rabbit hole I know...


########################################################

import numpy as np
op')

import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

## bring in our petal image:

bb = io.imread('P431F1_bottom_spots.png')
io.imshow(bb)
io.show()

cc = io.imread('P431F1_bottom_petal.png')
io.imshow(cc)
io.show()

edges = filters.sobel(bb)
io.imshow(edges)
io.show()

## okay, can we turn this into a polygon?

## meaning, can it be approximated into a 
## series of vertices? 

## what value are we chasing?

np.unique(edges)

## huh. 7 non-zero values...

contours = measure.find_contours(edges, 0.5)

type(contours)

contours[0].shape

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)


## almost works, but we're losing information by the png 
## conversion, methinks.

## so... back to octave/matlab:

####################################################

octave-cli

pkg load image

## get one grayscale image:

load("../dougRaster/Rotated_and_Cropped/P431F1.mat")
aa = mat2gray(Petals.Clusters.right);

Petals.Clusters.right

spots = aa < 1;
imshow(spots);

petal = aa == 0;
imshow(petal);

## save them as csv's:

csvwrite('P431F1petal.csv',petal)
csvwrite('P431F1spots.csv',spots)

%% and back to python...
#########################

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

petal = np.genfromtxt ('P431F1petal.csv', delimiter=",")
spots = np.genfromtxt ('P431F1spots.csv', delimiter=",")

np.unique(petal)

np.unique(spots)

## try spots

## can contours handle these directly?
contours = measure.find_contours(spots, 0)
for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.show()

## not bad, but still gaps...

contours = measure.find_contours(spots, 0)
for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

## same. Try finding the edges first:


edges = filters.sobel(spots)

io.imshow(edges)
io.show()

np.unique(edges)

contours = measure.find_contours(edges, 0.5)

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.show()

## same problem. can we add a margin of white to our 
## matrix?

## jog my memory, how to work with numpy again...

a = np.array([[1, 1], [2, 2], [3, 3]])

a
a = np.insert(a, 0, 5, 1)
a

a = np.array([[1, 1], [2, 2], [3, 3]])
np.insert(a, 0, 5, 0)

## rows are axis zero, columns axis one

a = np.array([[1, 1], [2, 2], [3, 3]])

a.shape
np.insert(a, 0, [6,6,6], 1)
np.insert(a, 2, [6,6,6], 1)

a = np.array([[1, 1], [2, 2], [3, 3]])
b = np.insert(a, 2, [6,6,6], 1) ## might be a more elegant way...

## can we add more than one column at a time?

a = np.array([[1, 1], [2, 2], [3, 3]])
b = np.insert(a, 2, [[5,5,5],[6,6,6]], 1)

## works, but probably better to build another matrix 
## and concatenate it 

## for our images, our polygons are black, = 0's

## so we want to add white space, or 1's. 

## seems pretty simple. try it with one of our images:


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

petal = np.genfromtxt ('P431F1petal.csv', delimiter=",")
spots = np.genfromtxt ('P431F1spots.csv', delimiter=",")

petal.shape
## (561, 439)

spots.shape
## same

## looks like the rows/columns are transposed 
## automatically by the scikit-image?

## to add one pixel of white to columns:
spots_marg = np.insert(spots, 439, 1, 1) 
spots_marg = np.insert(spots_marg, 0, 1, 1) 
## and rows:
spots_marg = np.insert(spots_marg, 561, 1, 0) 
spots_marg = np.insert(spots_marg, 0, 1, 0) 

spots.shape
spots_marg.shape


## does this help the detection of the polygons?

contours = measure.find_contours(spots_marg, 0)

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)


plt.show()


## to keep the relative positions accurate, we have to do the
## the same with the petal outline:

petal_marg = np.insert(petal, 439, 1, 1) 
petal_marg = np.insert(petal_marg, 0, 1, 1) 
## and rows:
petal_marg = np.insert(petal_marg, 561, 1, 0) 
petal_marg = np.insert(petal_marg, 0, 1, 0) 

Pcontours = measure.find_contours(petal_marg, 0)

## how does it look?:

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.plot(Pcontours[0][:,1], Pcontours[0][:,0], linewidth=1)

plt.show()

## looks good. 

## 1) Can we give these to Matlab?

## and if so, 

## 2) we need a script to generalize this. 

## 3) and a bash script that will work for anyone to repeat. 

## update notebook, then do these things. 

## okay, can we export one of these so that octave can read it?

## CSV is a little problematic, because we need a new for each 
## polygon.

## but building a json of nested arrays that python will make and 
## matlab will parse, sounds more tricky than I want to take on. 

np.savetxt("P431F1petal_polys.csv", contours) ## doesn't work

contours[0]

contours[0].astype(int)

## loop through the various polygons, save them individually?

photoname = 'P431F1'
partname  = 'spots'
petalname = 'bottom'

for n, contour in enumerate(contours):
    polyname = photoname + petalname + partname + str(n) + "_poly.csv"
    print(polyname)
    np.savetxt(fname=polyname, X=contour.astype(int), delimiter=',') 

## looks good. 

## so now the challenge is, given a single image, make a function 
## that exports the petal outline and all the respective 

## we start with..? a csv from matlab, which is the grayscale matrix
## of a single petal image:

## remember that as we have it here, we get a petal and a spots
## csv from matlab/octave. 

## but it is the same process for both. Make this agnostic: 


## get_pols.py
#################################3
#!/usr/bin/env python3

import argparse
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

## instantiate the argparser
parser = argparse.ArgumentParser()

## argument:
parser.add_argument('file', 
            help="Name of the .csv file from matlab that contains grayscale information about a petal.")

args = parser.parse_args()

## get our image in...
aa  = np.genfromtxt(args.file, delimiter = ",")

aR = aa.shape[0] ## number of rows
aC = aa.shape[1] ## number of cols

## add one pixel of white to rows:
aa_marg = np.insert(aa, aR, 1, 0)
aa_marg = np.insert(aa_marg, 0, 1, 0)
## and columns:
aa_marg = np.insert(aa_marg, aC, 1, 1)
aa_marg = np.insert(aa_marg, 0, 1, 1)

## find the contours:
contours = measure.find_contours(aa_marg, 0)

## save them out:

imageName = args.file[:-4] ## no file extension

for n, contour in enumerate(contours):
    polyname = imageName + "_poly" + str(n) + ".csv"
    np.savetxt(fname=polyname, X=contour.astype(int), delimiter=',')

#####################################

## try this out on one of our CSvs from matlab:

./get_pols.py P431F1spots.csv

## seems to work, but we'll need to check this
## out on matlab tomorrow. 

## how can we make this cleaner? We want to output
## to a folder...

## update notebook, fix tomorrow. 

###############################

## its tomorrow, again. 

## okay, so we need to make our script export all products into 
## a single folder. 

## let's work in the file itself...

./get_pols.py P431F1spots.csv

## 13 of them. is this the same as before?

## looks okay, I think. 

## works for our petal outline? 

./get_pols.py P431F1petal.csv

## works ok on the mac, looks like.

## switch over to matlab for a minute, can we plot our polygons 
## from this and do they look ok?

## if so, focus on getting all of doug's rasters into shape for 
## this script, 

## then run script on all of them. 

## want to run the matlab interpreter without the other junk
## but we gotta find our binaries apparently, doesn't add 
## anything to our path for us on the install...


## I hate matlab.

/Applications/MATLAB_R2018a.app/bin/matlab -nodisplay

## made an alias. should just work with:

matlab

%% now in matlab...

%% what do we want to do again?

wkd = '/Users/danthomas/Documents/speckling/make_polygons/';
%cd /Users/danthomas/Documents/speckling/make_polygons;
cd(wkd);
%name='P431F1petal';
name='P431F1spots';
cd(name);

%% empty vector to fill?

aa = []
counter=1
for i = 2:6;
    aa(counter) = i;
    counter = counter + 1;
end;


%% we need add these as cell arrays to
%% a single iterable structure..
%% so to read in these polygons:

aa = struct
counter = 1;
files = dir('*.csv');
for file = files';
    coords = csvread(file.name);
    aa(counter).coords=coords;
    counter = counter + 1;
end;

%% now to convert to polygons:

counter=1;
for i = aa';
    aa(counter).p = polyshape(aa(counter).coords);
    counter=counter+1;
end;
%% doesn't work, fails and doesn't retry
%% big ol fashioned ugly ifs and fors

counter=1;
for i = aa;
    disp(counter)
%    if length(aa(counter).coords) > 1;
        disp(i)
%    end;
    counter=counter+1;
end;


counter=1;
for i = aa;
disp(i)
end;

for i = 1:length(aa);
    size(aa(i).coords)
end

%% huh. all of the the three point ones aren't viable polygons

%% do we need them? We can increase the sensitivity of our polygon detection,
%% I'd imagine...

%% for the moment we plot them as lines?


%% I'm lost. What am I trying to do? 

%% trying to plot all the spots on a petal. Some of them are too thin to plot as polygons 
%% in matlab. 

%% I may have mentioned I fucking hate matlab. 

%% anyway, not matlab's fault. These are not polygons, they are lines. 

%% back up reset our structure:

aa = struct
counter = 1;
files = dir('*.csv');
for file = files';
    coords = csvread(file.name);
    aa(counter).coords=coords;
    counter = counter + 1;
end;

%% add polyshape if we can:

counter=1;
for i = aa;
    if length(i.coords(:,1)) > 3;
        aa(counter).p = polyshape(i.coords)
    end;
    counter=counter+1;
end;

%% can we plot this?

counter=1;
for i = aa;
    if ~isempty(i.p)
        plot(i.p)
        hold on
    end;
    counter=counter+1;
end;

%% add our petal outline:

Pcoords = csvread("/Users/danthomas/Documents/speckling/make_polygons/P431F1petal/P431F1petal_poly0.csv")
Ppoly = polyshape(Pcoords)
plot(Ppoly)


## lotsa work to do on this, but I think we're moving in the right direction...

##################

## okay, so back up. We need matlab to export the original petal and spots csv in a single folder, 
## so that our skimmage script can rip through them all at once. 

## and we need our skimmage script to handle a folder at a time. 

## then we need a matlab script to 


## looks like we probably need to learn about running matlab scripts from 
## the command line? 

## ugh, nah. Let's not. Others can do this if they want. 

## so first, let's get matlab to export petals and spots in two 
## matrices, in a folder:

%% separatePetPol.m
#############################

%% the goal here is grab all available petal images 
%% that have been through doug's raster transformations.
%% We make grayscle (0-1) matrices of his matrices, 
%% then "peel" them apart into spots and petal backgrounds.
%% these are then passed onto a python script for digitizing
%% the polygons.

%% first let's run through one image again
%% to output both matrices to a single, new folder:

%% following that, make it so all three petals are 
%% produced in their own folders, all within a 
%% single folder for each image

%% following that, make it so we can cycle through
%% all of our processed images

%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% go to working directory
wd = '/Users/danthomas/Documents/speckling/make_polygons/polygons/';
cd(wd);

dougRasterDir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

im = "P431F1.mat";
imName = regexprep(im,'\.mat', ''); 

%% go get our file, come back
cd(dougRasterDir);
rast=load(im);
cd(wd);

%% make a spot for our image, go to it:
mkdir(imName);
cd (imName);

%% get our petal names (left, right mid)
petNames = fieldnames(rast.Petals.Clusters);

%% split images into petal and spot, export, for each of the three petals:

for i = 1:length(petNames);
    pet = rast.Petals.Clusters.(petNames{i}); %petal at hand
    rastGray = mat2gray(pet); 
    spots = rastGray  < 1; 
    petal = rastGray == 0;
    mkdir(petNames{i});
    cd(petNames{i});
    fileNamePetal = imName + "_" +  petNames(i) + "_" + 'petal.csv';
    csvwrite(fileNamePetal,petal);
    fileNameSpots = imName + "_" +  petNames(i) + "_" + 'spots.csv';
    csvwrite(fileNameSpots,spots);
    cd ..;
end;

cd(wd);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%% generalize to catch all of dougs rasters

%%%%%%%%%%%%%%%%%%%%%%%%%%

%% a script to put all of Doug's rasters into a form we can use:

%% go to working directory
wd = '/Users/danthomas/Documents/speckling/make_polygons/polygons/';
cd(wd);

dougRasterDir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

cd(dougRasterDir)

files = dir('P*.mat');
for file = files';
    im = file.name;
    imName = regexprep(im,'\.mat', ''); 
    %% go get our file, come back
    cd(dougRasterDir);
    rast=load(im);
    cd(wd);
    %% make a spot for our image, go to it:
    mkdir(imName);
    cd (imName);
    %% get our petal names (left, right mid)
    petNames = fieldnames(rast.Petals.Clusters);
    %% split images into petal and spot, export, for each of the three petals:
    for i = 1:length(petNames);
        pet = rast.Petals.Clusters.(petNames{i}); %petal at hand
        rastGray = mat2gray(pet); 
        spots = rastGray  < 1; 
        petal = rastGray == 0;
        mkdir(petNames{i});
        cd(petNames{i});
        fileNamePetal = imName + "_" +  petNames(i) + "_" + 'petal.csv';
        csvwrite(fileNamePetal,petal);
        fileNameSpots = imName + "_" +  petNames(i) + "_" + 'spots.csv';
        csvwrite(fileNameSpots,spots);
        cd ..;
    end;
    cd(wd);
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

## think that worked...

## how do we check?

## back to python...

python

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

## some rando files to compare:

aa = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P247F1/right/P247F1_right_spots.csv'
bb = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P399F1/right/P399F1_right_spots.csv'
cc = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P399F1/left/P399F1_left_spots.csv'
dd = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P393F2/mid/P393F2_mid_spots.csv'
ee = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P257F2/left/P257F2_left_petal.csv'

## look at em

image = ee
sv = np.genfromtxt (image, delimiter=",")
contours = measure.find_contours(sv, 0)
for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.show()

## add a petal for cc
image = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P399F1/left/P399F1_left_petal.csv'
svp = np.genfromtxt (image, delimiter=",")
contoursp = measure.find_contours(svp, 0)
for n, contourp in enumerate(contoursp):
    plt.plot(contourp[:, 1], contourp[:, 0], linewidth=2)

## all looks good. 

## move on, digitize with python script... 

## okay, this script goes to home of each file, and builds directories right there, in place.

## so this will go to each of our blacknwhite matrices and build another folder in place with 
## a bunch of polygons 

## is this going to be hard to work with later?

## Probably. First let's just see if it works.

## How do we apply it all of our files? They are all buried in the nested folders...

## seems like a good use of find:

find ./ -name "P*csv" -type f  | wc -l
## hehzus, there 1080 of these. Is that right? 
## = 180 photos x 6, yup.

## sicking our script on these could be catastrophic... getting github uptodate...


find ../polygons/ -name "P*csv" -type f  -exec ./get_pols.py {} \;

## no errors reporting .. how do we check if we did a good job? 

## be sure to update get_pol.py  script on notebook when next we go there..

## let's let that run tonight...

## maybe we can do the commit/push remotely...

#######################################

##  update notebook


## branch

## then check these with matlab, and meld with doug's matlab structures

## how to do this, in matlab?...

## for each image:

%% 1) load doug matlab structure of image
%% 2) load all associated polygons and petal outlines csvs as matlab polyshapes 
%% 3) add these to doug's matlab stuctures



%% try just one:

wd = '/Users/danthomas/Documents/speckling/make_polygons/'
cd(wd)

dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

im = "P369F1";
pos='mid';
%typPol='spots';
typPol='petal';
imStructF = dougdir + im + ".mat";



%% how do we get a list of matlab structures of interest (images as structures)?

cd(dougdir)
files = dir('P*.mat');
for file = files';
    im = regexprep(file.name,'\.mat', ''); 
    disp(file.name + " " + im)
end;
%% works

load(imStructF)

wd + "tryscript/" + im + '_' + pos + '_' + typPol

%%"mid" (actually "right") petal:

aa = mat2gray(Petals.Clusters.mid);
imshow(aa)

%% there's a hole in this spot, I wonder how our python script
%% dealt with that. We'll see in a minute...

%% what are our accompanying python-defined csv?

%% two directories we need are:

"tryScript/P369F1_mid_petal"
"tryScript/P369F1_mid_spots"

%% could be restated as:

wd + "tryscript/" + im + '_' + pos + '_' + typPol

ls(wd + "tryscript/" + im + '_' + pos + '_' + typPol) %% seems to work

%% seems like it would be simplest to construct a structure that contains
%% all of our spot and petal polygons, then add this to the existing 
%% doug matlab structure for that image. 

%% 1) get image name from list of mat files in dougdir
%% 2) load and convert all the pertinent csvs to polyshapes
%% 3) save together in a structure
%% 4) add this to dougs existing structure

%% for 2, how do we find all the pertinent files?

%% im is scrounged off the file name, then...

dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";
wd = '/Users/danthomas/Documents/speckling/make_polygons/'
petNames = ["left", "mid", "right"];
typPols = ["petal", "spots"];

im = "P369F1";

cd(wd)
Polys = struct;
for i = petNames;
    for j = typPols;
        imdir = "tryScript/" + im + "_" + i + "_" + j;
        cd(imdir);
        files = dir('P*.csv');
        counter = 1;
        for file = files';
            disp(file.name)
            disp(counter)
            coords=csvread(file.name);
            if length(coords(:,1)) > 3; %% if there are enough points
                Polys.(i).(j)(counter) = polyshape(coords); %% convert to polyshape
                counter=counter+1;
            end;
        end;
    cd(wd)
    end;
end;

%% that seems to work. how would we add it?

%% one of Doug's structures looks like:


load ('/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P431F2.mat')

aa = load ('/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P431F2.mat')

save

bb = 'loop';
cc = 'poop';

save('test.mat', 'bb', 'cc')

clear(bb, cc)

load('test.mat')

%% just load the mat file of interest, and add the above as a field.

im = "P369F1";
aa = load(dougdir + im + ".mat");

%% add our polyshapes to it:

aa.Petals

aa.Petals.polys = Polys;

aa.Petals.polys

%% then save it back out. Does our naming the structure accidentally add a layer to our structure?
save("aatest.mat", "aa")
clear(aa)
load("aatest.mat")
%% yup. 

%% seems like maybe we just deal with files one at time here.

load(dougdir + im + ".mat");
Petals.Polys = Polys;
save(imFile,"Petals")


%% where shall we save these?


imFile = wd + "matObjW_pol/" + im + ".mat";

save(imFile,"Petals")

clear Petals

load(imFile)

%% works. Can we loop it?


dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";
wd = '/Users/danthomas/Documents/speckling/make_polygons/';
petNames = ["left", "mid", "right"];
typPols = ["petal", "spots"];

cd(dougdir)
hs = dir('P*.mat');
for h = hs';
    im = regexprep(h.name,'\.mat', ''); 
    cd(wd)
    Polys = struct;
    for i = petNames;
        for j = typPols;
            imdir = "tryScript/" + im + "_" + i + "_" + j;
            cd(imdir);
            files = dir('P*.csv');
            counter = 1;
            for file = files';
                disp(file.name)
                disp(counter)
                coords=csvread(file.name);
                if length(coords(:,1)) > 3; %% if there are enough points
                    Polys.(i).(j)(counter) = polyshape(coords); %% convert to polyshape
                    counter=counter+1;
                end;
            end;
        cd(wd)
        end;
    end;
    load(dougdir + im + ".mat"); %% get doug's matlab structure
    Petals.Polys = Polys; %% add our new Polys structure inside it
    imFile = wd + "matObjW_pol/" + im + ".mat"; %% save the modified structure 
    save(imFile,"Petals");
end;

%% did that work?

%% how to check a few of these?

%% import the 

im = "P369F1";
aa = load(dougdir + im + ".mat");

load("/Users/danthomas/Documents/speckling/make_polygons/matObjW_pol/P440F1.mat")

%% iterate through our petal outline and spots 

for i = Petals.Polys.left.petal
    if ~isempty(i)
        plot(i)
        hold on %% keep the plot open
    end;
end;

for i = Petals.Polys.left.spots
    if ~isempty(i)
        plot(i)
        hold on %% keep the plot open
    end;
end;


%%, but as Arielle mentioned, polygons are getting merged. 

%% let's see how common and how badly. 


%% can we make a function for viewing all three stages of the 
%% process. 

%% to just view the original jpeg?

cd /Users/danthomas/Documents/speckling/make_polygons/matObjW_pol 

files = dir('P*.mat');
counter = 1;
for file = files';
    disp(file.name)
end;


load('P434F1.mat')


dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

dougdir = '/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/';
[a,b,c] = fileparts(Petals.fullName);
jpegName = dougdir + b + c;

aa = imread("/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P434F1.JPG") %% doesn't work

aa = imread('/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P434F1.JPG') %% works...

ls "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P434F1.JPG"

ls '/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P434F1.JPG'



a = 'zzop';
b = "zzop";

class(a) %% single quote, = char
class(b) %% double quote, = string

a(1)
b(1)

%% so double quotes save the entire word as a unite (=string),
%% and single quotes save the word as a string of letters (=letter)

wd="/Users/danthomas/Documents/speckling/make_polygons/matObjW_pol"
cd(wd)

%load('P434F1.mat')

load('P248F2.mat')

dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";
[a,b,c] = fileparts(Petals.fullName);
jpegName = char(dougdir + b + c); %% gotta be a character object
jpegN = imread(jpegName) ;

imshow(jpegN)

[a,b,c] = fileparts(Petals.fullName);
jpegName = char(dougdir + b + c); %% gotta be a character object?
jpegN = imread(jpegName);
    %% plot a page:
    figure;
    %%%%%%%%% first row %%%%%%%%%%%%%%%
    subplot(3,3,[1,3]);
    imshow(jpegN);
    title(b) %% this is our plot title
    %%%%%%%%% second row %%%%%%%%%%%%%
    subplot(3,3,4);
    aa = mat2gray(Petals.Clusters.left);
    imshow(aa) 
    subplot(3,3,5);
    aa = mat2gray(Petals.Clusters.mid);
    imshow(aa) 
    subplot(3,3,6);
    aa = mat2gray(Petals.Clusters.right);
    imshow(aa) 
    %%%%%%%%%% third row %%%%%%%%%%%%%%
    subplot(3,3,7);
        if isfield(Petals.Polys.left,'petal');
        for i = Petals.Polys.left.petal;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        if isfield(Petals.Polys.left,'spots');
        for i = Petals.Polys.left.spots;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        daspect([1 1 1])
    subplot(3,3,8);
        if isfield(Petals.Polys.mid,'petal');
        for i = Petals.Polys.mid.petal;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        if isfield(Petals.Polys.mid,'spots');
        for i = Petals.Polys.mid.spots;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        daspect([1 1 1])
    subplot(3,3,9);
        if isfield(Petals.Polys.right,'petal');
        for i = Petals.Polys.right.petal;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        if isfield(Petals.Polys.right,'spots');
        for i = Petals.Polys.right.spots;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
        daspect([1 1 1])
    %%%%%%%%%%%%%%

%% can we export to pdf?

print("test.pdf",'-dpdf', '-fillpage')

%% works. Can we loop through, make them all?

wd="/Users/danthomas/Documents/speckling/make_polygons/matObjW_pol"  %% right now our structures live here
dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/"; %% but original images here
pdfDir = "/Users/danthomas/Documents/speckling/make_polygons/bigPDF/"; %% we'll put pdfs here
cd(wd)

files = dir('P*.mat');
for file = files';
    %% get things loaded
    load(file.name)
    [a,b,c] = fileparts(Petals.fullName);
    jpegName = char(dougdir + b + c); %% gotta be a character object?
    pdfName = pdfDir + b + ".pdf"; %% doesn't have to be a character object?
    jpegN = imread(jpegName);
        %% plot a page:
        figure;
        %%%%%%%%% first row %%%%%%%%%%%%%%%
        subplot(3,3,[1,3]);
        imshow(jpegN);
        title(b) %% this is our plot title
        %%%%%%%%% second row %%%%%%%%%%%%%
        subplot(3,3,4);
        aa = mat2gray(Petals.Clusters.left);
        imshow(aa) 
        subplot(3,3,5);
        aa = mat2gray(Petals.Clusters.mid);
        imshow(aa) 
        subplot(3,3,6);
        aa = mat2gray(Petals.Clusters.right);
        imshow(aa) 
        %%%%%%%%%% third row %%%%%%%%%%%%%%
        subplot(3,3,7);
            if isfield(Petals.Polys.left,'petal');
            for i = Petals.Polys.left.petal;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            if isfield(Petals.Polys.left,'spots');
            for i = Petals.Polys.left.spots;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            daspect([1 1 1])
        subplot(3,3,8);
            if isfield(Petals.Polys.mid,'petal');
            for i = Petals.Polys.mid.petal;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            if isfield(Petals.Polys.mid,'spots');
            for i = Petals.Polys.mid.spots;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            daspect([1 1 1])
        subplot(3,3,9);
            if isfield(Petals.Polys.right,'petal');
            for i = Petals.Polys.right.petal;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            if isfield(Petals.Polys.right,'spots');
            for i = Petals.Polys.right.spots;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            daspect([1 1 1])
        %%%%%%%%%%%%%%
    %% print as a pdf page
    print(pdfName,'-dpdf', '-fillpage')
    close %% added after running, not sure if this works
end;


%% horribly inefficient, but it worked. 


## to join these, try the built in script that comes with mac OS for this:

/System/Library/Automator/Combine\ PDF\ Pages.action/Contents/Resources/join.py -o PolyPipeline_140818.pdf ./bigPDF/*

## so now what? 

## the polygons are flawed, but it would be nice to have something to show about centering, etc

## what is a good one to look at? Which ones made it through the pipeline without issues?

%% back into matlab

%% P416F1 looks simple and well-digitized:

wd="/Users/danthomas/Documents/speckling/make_polygons/matObjW_pol/"  %% right now our structures live here
dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/"; %% but original images here
pdfDir = "/Users/danthomas/Documents/speckling/make_polygons/bigPDF/"; %% we'll put pdfs here
cd(wd)
file = wd + "P416F1.mat";
load(file);

%% how to mark the centroid of the petal?

pet = Petals.Polys.right.petal(1);
spotz = Petals.Polys.right.spots;
%% put all the spots into an array
allSpots = union(spotz);
%% Centroids
[x,y] = centroid(pet);
[v,w] = centroid(allSpots);
X=[x v];
Y=[y w];

%% plot polys
ppet = plot(pet);
ppet.FaceColor = [1 1 0];
ppet.FaceAlpha = 0.4;
hold on;
pg = plot(allSpots);
pg.FaceColor = 'red';
p3.FaceAlpha = 1;
hold on;

hold off;

%% plot centroids

%% make the line
plot(X, Y,...
    'LineWidth',2,...
    'Color','black');
hold on;
%% petal centroid
plot(x,y, 'o', 'MarkerSize', 15,...
    'MarkerEdgeColor','black',...
    'MarkerFaceColor','yellow')
    hold on 
%% polygon centroid
plot(x,y, '+', 'MarkerSize', 15,...
    'MarkerEdgeColor','black')
    hold on 
plot(v,w, 'o', 'MarkerSize', 15,...
    'MarkerEdgeColor','black',...
    'MarkerFaceColor','red')
    hold on
plot(v,w, '+', 'MarkerSize', 15,...
    'MarkerEdgeColor','black')
    hold off


%%%%%%%%%%%%%%%%%%%%%%


pdist(X, Y)




[x,y] = centroid(pet);





%% one idea for a quick spot centroid - union(polys) -- centroid()

pg = plot(allSpots);
pg.FaceColor = 'red';
pg.FaceAlpha = 1;
hold on;

ppet=plot(pet(1));
ppet.FaceColor = 'blue';
hold on;

plot(x,y, '-s', 'MarkerSize', 10,...
    'MarkerEdgeColor','black',...
    'MarkerFaceColor','black');
hold off





%% side note, what do the petal polygons look like in the flowers where spots look like they 
%% interfered with the petal outline


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


#################################################

## lets delve back into our python digitization process.

## while we are making our polygons, can we add hand digitizing and 
## corner detection?

## and maybe while we're in here, we see how digitizing from the jpegs works out for us.
## it may be better than Doug's color simplification outputs. 
## doubt it, but it's worth a look

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure, feature
from pprint import pprint 

petal = np.genfromtxt ('P431F1petal.csv', delimiter=",")

petal.shape

petal_marg = np.insert(petal, 439, 1, 1)
petal_marg = np.insert(petal_marg, 0, 1, 1)
petal_marg = np.insert(petal_marg, 561, 1, 0)
petal_marg = np.insert(petal_marg, 0, 1, 0)

Pcontours = measure.find_contours(petal_marg, 0)

## works as before. Now do we use this or the original 
## for corner detection?

## first let's try it on the doug petal outline:

petal_marg = np.transpose(petal_marg)

coords = feature.corner_peaks(
    feature.corner_harris(petal_marg),
    min_distance = 2
)


fig, ax = plt.subplots()
ax.imshow(petal_marg)
plt.show()
ax.plot(coords[:, 1], coords[:, 0], '.b', markersize=5)

## can we smooth/simplify the image a bit?
## or perhaps works better with the contours?

hand = np.array([[1.64516129, 1.16145833],
                 [1.64516129, 1.59375],
                 [1.35080645, 1.921875],
                 [1.375, 2.18229167],
                 [1.68548387, 1.9375],
                 [1.60887097, 2.55208333],
                 [1.68548387, 2.69791667],
                 [1.76209677, 2.56770833],
                 [1.83064516, 1.97395833],
                 [1.89516129, 2.75],
                 [1.9516129, 2.84895833],
                 [2.01209677, 2.76041667],
                 [1.99193548, 1.99479167],
                 [2.11290323, 2.63020833],
                 [2.2016129, 2.734375],
                 [2.25403226, 2.60416667],
                 [2.14919355, 1.953125],
                 [2.30645161, 2.36979167],
                 [2.39112903, 2.36979167],
                 [2.41532258, 2.1875],
                 [2.1733871, 1.703125],
                 [2.07782258, 1.16666667]])



new_hand = hand.copy()

new_hand = measure.subdivide_polygon(new_hand, degree=2, preserve_ends=True)

for _ in range(3):
    new_hand = measure.subdivide_polygon(new_hand, degree=2, preserve_ends=True)

fig, (ax1, ax2) = plt.subplots(ncols=2)

ax1.plot(hand[:, 0],hand[:, 1])
ax1.plot(new_hand[:, 0],new_hand[:, 1])

## interesting. awesome smoothing algorithm

## can we do something like this with our petal outline?

plt.ion()

Pcontours = measure.find_contours(petal_marg, 0)

new_contours = measure.subdivide_polygon(Pcontours[0], degree=2, preserve_ends=True) 

for _ in range(5):
    new_contours = measure.subdivide_polygon(Pcontours[0], degree=2, preserve_ends=True) 

fig, (ax1, ax2) = plt.subplots(ncols=2)
ax1.plot(Pcontours[0][:,0], Pcontours[0][:,1])
ax2.plot(new_contours[:,0], new_contours[:,1])

## doesn't really work, we need sort of the opposite here. Can we put hard corners on our
## petal outline?

aa = measure.approximate_polygon(Pcontours[0], tolerance=9)
fig, (ax1, ax2) = plt.subplots(ncols=2)
ax1.plot(Pcontours[0][:,0], Pcontours[0][:,1])
ax2.plot(aa[:,0], aa[:,1])

plt.show()

## now we're in business. Can we use this to find our corners?

coords = feature.corner_peaks(
    feature.corner_harris(aa),
    min_distance = 2
)


fig, (ax1, ax2, ax3) = plt.subplots(ncols=3)
ax1.plot(Pcontours[0][:,0], Pcontours[0][:,1])
ax2.plot(aa[:,0], aa[:,1])
ax3.plot(aa[:,0], aa[:,1])

## anyway, can we use aa to detect our bottom vertices?

aa[:,1]

aa[:,0]

aa[:,1], aa[:,0]

aa[

np.hstack((aa[:,1], aa[:,0]))

np.concatenate(aa[:,1], aa[:,0], axis = 1)

np.concatenate( [ np.array( [ [1,2], [2,3] ] ), np.array( [ [3],[4] ] ) ] , axis = 1)


bb = np.concatenate([aa[:,1],aa[:,0]], axis = 1)

fig, ax1 = plt.subplots()
ax1.plot(bb[:,0],bb[:,1])


np.array([[1,2],[3,4],[5,6]])

## back on this, where were we?

## oh yeah, can we modify our python digitization script to include finding the bottom corners 
## of our petals?

##############################

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure, feature
from pprint import pprint 

#plt.ion()

petalFile=('P431F1petal.csv')

petal = np.genfromtxt (petalFile, delimiter=",")


petal.shape[0]
petal.shape[1]

petal_marg = np.insert(petal, petal.shape[1], 1, 1)
petal_marg = np.insert(petal_marg, 0, 1, 1)
petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
petal_marg = np.insert(petal_marg, 0, 1, 0)

Pcontours = measure.find_contours(petal_marg, 0)
aa = measure.approximate_polygon(Pcontours[0], tolerance=9)

## get corners.. how?
## in these inverted images, these should be the highest points:
bb = aa.copy()
bb = bb[bb[:,1].argsort()[::-1]]
cc = bb[0:2,:]

fig, (ax1, ax2, ax3) = plt.subplots(ncols=3)
ax1.plot(Pcontours[0][:,0], Pcontours[0][:,1])
ax2.plot(aa[:,0], aa[:,1])
ax3.plot(aa[:,0], aa[:,1])
ax3.plot(aa[:,0], aa[:,1], 'ro') ## show vertices
ax3.plot(cc[:,0], cc[:,1], 'yo', fillstyle='none',markersize=10, linewidth=3) ## show vertices


## does this work with other petals? how about our side petals?

################### write a function #######
#!/usr/bin/env python3

## petal is single binary petal outline
## petal matrix ouputted from 
## doug's color simplification pipeline
## as a CSV

import numpy as np
import matplotlib.pyplot as plt
import shapely as sh
from skimage import data, io, filters, measure, feature

def digitizePols(petalFile):
    ## pad margins of image and get the contour of the petal shape
    petal = np.genfromtxt (petalFile, delimiter=",")
    petal_marg = np.insert(petal, petal.shape[1], 1, 1)
    petal_marg = np.insert(petal_marg, 0, 1, 1)
    petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
    petal_marg = np.insert(petal_marg, 0, 1, 0)
    Pcontours = measure.find_contours(petal_marg, 0)
    simplePoly = measure.approximate_polygon(Pcontours[0], tolerance=9)
    ## get corners
    ## in these inverted images, these should be the highest points:
    bb = simplePoly.copy()
    bb = bb[bb[:,1].argsort()[::-1]]
    corners = bb[0:2,:]
    return(Pcontours[0],simplePoly,corners) 

##############

## does it work?

petalFile=('P431F1petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)

def plotCor(Pcontours,simplePoly,corners):
    fig, (ax1, ax2, ax3, ax4) = plt.subplots(ncols=4)
    ax1.plot(Pcontours[:,0], Pcontours[:,1])
    ax2.plot(simplePoly[:,0], simplePoly[:,1])
    ax3.plot(simplePoly[:,0], simplePoly[:,1])
    ax3.plot(simplePoly[:,0], simplePoly[:,1], 'ro') ## show vertices
    ax3.plot(corners[:,0], corners[:,1], 'yo', fillstyle='none',markersize=10, linewidth=3) ## show vertices
    ax4.plot(Pcontours[:,0], Pcontours[:,1])
    ax4.plot(corners[:,0], corners[:,1], 'ro', fillstyle='none',markersize=10, linewidth=3) ## show vertices

## try side petals:

petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P431F1/mid/P431F1_mid_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
plotCor(Pcontours,simplePoly,corners)

petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P431F1/left/P431F1_left_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
plotCor(Pcontours,simplePoly,corners)

plt.savefig('P431F1_left_corners.png')
## doesn't capture our upper petal corners...

## how about some other bottom petals:


petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P375F2/left/P375F2_left_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
plotCor(Pcontours,simplePoly,corners)

## oops, that was an upper petal, but it worked!

plt.savefig('P375F2_left_corners.png')

## anyway other lower petals:

petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P375F2/right/P375F2_right_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)

petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P401F2/right/P401F2_right_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
plotCor(Pcontours,simplePoly,corners)

plt.savefig('P401F2_right_corners.png')

####################################


## works pretty well. 

## can we get our polygons into shapely objects?

## the goal is have the zones demarcated as part of the digitization 
## process. 

## to get our outline as a shapely polygon:

import shapely.geometry as sg
import shapely.affinity as sa

testP = sg.asPolygon(Pcontours)

xs, ys = testP.exterior.xy

fig, ax1 = plt.subplots()
ax1.fill(xs, ys)

## works. can we simplify?

s = testP.simplify(5, preserve_topology=False)

xsimp, ysimp = s.exterior.xy
fig, (ax1,ax2) = plt.subplots(ncols=2)
ax1.fill(xs, ys)
ax2.fill(xsimp, ysimp)

## let's make a plot function:

def plpo(pol, cl='blue'):
    xs, ys = pol.exterior.xy
    fig, ax1 = plt.subplots()
    ax1.fill(xs, ys)
    ax2.fill(xsimp, ysimp)

plpo(testP)

## okay, can we get the inside polygon?

## wait, first, let's scale and center

## how to do this in python?

petalFile=('P431F1petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)

testP = sg.asPolygon(Pcontours)
xs, ys = testP.exterior.xy
fig, ax1 = plt.subplots()
ax1.fill(xs, ys)

## how can we scale this? just multiply by square root?

## find the scalar 
bb = testP.area
#sc = bb**(1/2)
sc = bb**(-1/2)

## scale
dd = sa.scale(testP, xfact=sc, yfact=sc) 


## recenter (translate to origin)

## get center

cent = dd.centroid

cX, cY = cent.xy

(-1*cX[0])

ee = sa.translate(dd, (-1*cX[0]), (-1*cY[0]))

plpo(ee)

ee.area

##so a function for this, accepts a numpy array of points.
## so we can accept the array from skimage:

def standPet(pet):
    import shapely.geometry as sg
    import shapely.affinity as sa
    aa = sg.asPolygon(pet)
    bb = aa.area
    sc = bb**(-1/2)
    dd = sa.scale(aa, xfact=sc, yfact=sc) 
    ee = dd.centroid
    cX, cY = ee.xy
    ff = sa.translate(dd, (-1*cX[0]), (-1*cY[0]))
    return(ff)

## for spots?

def digitizePols(petalFile):
    ## pad margins of image and get the contour of the petal shape
    petal = np.genfromtxt (petalFile, delimiter=",")
    petal_marg = np.insert(petal, petal.shape[1], 1, 1)
    petal_marg = np.insert(petal_marg, 0, 1, 1)
    petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
    petal_marg = np.insert(petal_marg, 0, 1, 0)
    Pcontours = measure.find_contours(petal_marg, 0)
    simplePoly = measure.approximate_polygon(Pcontours[0], tolerance=9)
    ## get corners
    ## in these inverted images, these should be the highest points:
    bb = simplePoly.copy()
    bb = bb[bb[:,1].argsort()[::-1]]
    corners = bb[0:2,:]
    return(Pcontours[0],simplePoly,corners) 

spotsFile=('P431F1spots.csv')

testS = digitizePols('P431F1spots.csv')

def standFlower(pet, spots=None):
    import shapely.geometry as sg
    import shapely.affinity as sa
    ## get petal outline standardized, get center and scale
    aa = sg.asPolygon(pet)
    bb = aa.area
    sc = bb**(-1/2)
    dd = sa.scale(aa, xfact=sc, yfact=sc) 
    ee = dd.centroid
    cX, cY = ee.xy
    ff = sa.translate(dd, (-1*cX[0]), (-1*cY[0]))
    ## try spots
    if spots is not None: 


can this be a list comprehension?

def standFlower(pet, spots=None):
    import shapely.geometry as sg
    import shapely.affinity as sa

def getinfo(pet):
    aa = sg.asPolygon(pet)
    area = aa.area
    scalar = area**(-1/2)
    center = aa.centroid
    return(scalar, center)

getinfo(

    def stand(pol):
        ispot = sg.asPolygon(i)
        iscaled = sa.scale(ispot, xfact=sc, yfact=sc)
        itrans = sa.translate(iscaled, (-1*cX[0]), (-1*cY[0]))
        return(itrans)


    iStand = [ stand(i) for i in spots ]

pols=(ff, 
    return(pols)

## try it out:

petalFile=('P431F1petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
testP = standPet(Pcontours)

plpo(testP)

testP.area

## order would be:

## doug's stuff --> sckimage contours --> shapely polygon processing

## so


######## head is spinning. start over from a csv from doug's color simplifications


petalFile=('P431F1petal.csv')
spotsFile=('P431F1spots.csv')


## 1 get our polygons from our petals and spots:

def digitizePols(file):
    import numpy as np
    from skimage import measure
    ## pad margins of image and get the contour of the petal shape
    petal = np.genfromtxt (file, delimiter=",")
    petal_marg = np.insert(petal, petal.shape[1], 1, 1)
    petal_marg = np.insert(petal_marg, 0, 1, 1)
    petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
    petal_marg = np.insert(petal_marg, 0, 1, 0)
    Pcontours = measure.find_contours(petal_marg, 0)
    ## gotta ditch <3 points, they are lines
    polys = [ i for i in Pcontours if len(i) > 3 ]
    return(polys)


testP = digitizePols(petalFile)[0] ## for petals, take first polygon, always seems to work?
testS = digitizePols(spotsFile)

## 2 get information about centroid and scaling factor:

def getPetGeoInfo(pet):
    aa = sg.asPolygon(pet)
    area = aa.area
    scalar = area**(-1/2)
    center = aa.centroid.wkt
    centerCoor = (cX[0], cY[0])
    return(scalar, centerCoor)

scale, cent = getPetGeoInfo(testP)

## 3 standardize petals

def stand(pol, scale, cent):
    aa = sg.asPolygon(pol)
    trans = sa.translate(aa, (-1*cent[0]), (-1*cent[1]))
    scaled = sa.scale(trans, xfact=scale, yfact=scale, origin = (0,0))
    return(scaled)

standPet = stand(testP, scale, cent)

## 4 standardize spots

spotz = [ stand(i, scale, cent) for i in testS ]

## can we take a look at this?

## 5 get the corners:




fig, ax1 = plt.subplots()
xs, ys = standPet.exterior.xy
#xs, ys = trans.exterior.xy
#xs, ys = scaled.exterior.xy
ax1.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax1.fill(xs, ys, "r")
  

###########

## python
import numpy as np
import matplotlib.pyplot as plt
import shapely.geometry as sg
import shapely.affinity as sa
from skimage import data, io, filters, measure

def digitizePols(file):
    ## pad margins of image and get the contour of the petal shape
    petal = np.genfromtxt (file, delimiter=",")
    petal_marg = np.insert(petal, petal.shape[1], 1, 1)
    petal_marg = np.insert(petal_marg, 0, 1, 1)
    petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
    petal_marg = np.insert(petal_marg, 0, 1, 0)
    Pcontours = measure.find_contours(petal_marg, 0)
    ## gotta ditch <3 points, they are lines
    polys = [ i for i in Pcontours if len(i) > 3 ]
    return(polys)

def getPetGeoInfo(pet):
    aa = sg.asPolygon(pet)
    area = aa.area
    scalar = area**(-1/2)
    center = aa.centroid.wkt
    centerCoor = (center[0], center[1])
    return(scalar, centerCoor)

def getPetGeoInfo(pet):
    aa = sg.asPolygon(pet)
    area = aa.area
    scalar = area**(-1/2)
    center = aa.centroid
    centerCoor = (center.x, center.y)
    return(scalar, centerCoor)

def stand(pol, scale, cent):
    aa = sg.asPolygon(pol)
    trans = sa.translate(aa, (-1*cent[0]), (-1*cent[1]))
    scaled = sa.scale(trans, xfact=scale, yfact=scale, origin = (0,0))
    return(scaled)

## we have an example "right" or lower petal example in our wd:
petalFile=('P431F1petal.csv')
spotsFile=('P431F1spots.csv')

## 1 make our raw, unscaled, untranslated polygons:
testP = digitizePols(petalFile)[0] ## for petals, take first polygon, always seems to work?
testS = digitizePols(spotsFile)

## 2 get information about centroid and scaling factor:
scale, cent = getPetGeoInfo(testP)

## okay so we have a pipeline in python that gets us to 

## 3-4 standard petal and spots:

standPet = stand(testP, scale, cent)

spotz = [ stand(i, scale, cent) for i in testS ]

## plot
fig, ax1 = plt.subplots()
xs, ys = standPet.exterior.xy
#xs, ys = trans.exterior.xy
#xs, ys = scaled.exterior.xy
ax1.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax1.fill(xs, ys, "r")
    
## check area. = 1?
standPet.area

## looks good. Now can we make a margin that incorporates 
## 50% of the petal polygon?


hole = standPet
rad = 0
while hole.area > 0.5:
    hole = standPet.buffer(rad)
    rad -= .001

holeR = sg.polygon.asLinearRing(hole)
## now make a polygon with this as a hole
marg = sg.polygon.Polygon(
    standPet.exterior, 
    holes = [hole.exterior.coords])



def shaPl(pol):
    fig, ax1 = plt.subplots()
    xo, yo = pol.exterior.xy
    if pol.interiors:
        xi, yi = pol.interiors[0].xy
    ax1.fill(xo, yo, "y")
    if pol.interiors:
        ax1.fill(xi, yi, "w")

shaPl(marg)

shaPl(standPet)

#################

## find corners, define tongue:

## we need to find our corners. 

## simplify:

aa = marg.simplify(0.5)

aa = marg.simplify(0.1)
shaPl(aa)

## the super hard simplification 
## may be handy for the side petals..

## but here, with P431F1petal we need 
## more like:

aa = marg.simplify(0.05)

shaPl(aa)

## how do we find our throat? Should be the top four points:

ax, ay = aa.exterior.xy

max(ay)

## when done - cycle through all the images, show how the
##  throat finding algorithm works


cc = np.array(aa.interiors[0].xy).transpose()

## how to get the highest two points?


## unlike R, you can just refer to rows of an 
## array

aa = marg.simplify(0.05)
bb = np.array(aa.exterior.xy).transpose()
bb[:,0].argsort()
## gives us an array of ranks of the values, 
## use this to sort:
zz = bb[bb[:,1].argsort()[::-1]]
## for our corners, take the top two:
yy = zz[0:2]

shaPl(standPet)
plt.plot(yy[:,0], yy[:,1], 'ro', fillstyle='none',markersize=10, linewidth=3)

## works - do the same for the interior?

#aa = marg.simplify(0.05)
bb = np.array(aa.interiors[0].xy).transpose()
bb[:,0].argsort()
## gives us an array of ranks of the values, 
## use this to sort:
zz = bb[bb[:,1].argsort()[::-1]]
## for our corners, take the top two:
xx = zz[0:2,]
xx = np.flipud(xx) ## reverse the order for making polys

shaPl(standPet)
plt.plot(yy[:,0], yy[:,1], 'ro', fillstyle='none',markersize=10, linewidth=3)
plt.plot(xx[:,0], xx[:,1], 'ro', fillstyle='none',markersize=10, linewidth=3)

## can we make a polygon out of these?

## combine them:

tt = np.concatenate((yy,xx))

plt.plot(tt[:,0],tt[:,1])

throat = sg.polygon.Polygon(tt)


## plot

fig, (ax1,ax2) = plt.subplots(ncols=2)
xs, ys = standPet.exterior.xy
ax1.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax1.fill(xs, ys, "r")

xs, ys = standPet.exterior.xy
ax2.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax2.fill(xs, ys, "r")
xo, yo = marg.exterior.xy
ax2.plot(xo, yo, "b")
xo, yo = marg.interiors[0].xy
ax2.plot(xo, yo, "b")
xo, yo = throat.exterior.xy
ax2.plot(xo, yo, "b")





#shaPl(marg)

xo, yo = marg.exterior.xy
plt.plot(xo, yo, "b")

xo, yo = marg.interiors[0].xy
plt.plot(xo, yo, "b")

xo, yo = throat.exterior.xy
plt.plot(xo, yo, "b")

fig, ax1 = plt.subplots()

xo, yo = pol.exterior.xy
xi, yi = pol.interiors[0].xy
ax1.fill(xo, yo, "y")
ax1.fill(xi, yi, "w")

xo, yo = pol.exterior.xy
xi, yi = pol.interiors[0].xy
ax1.fill(xo, yo, "y")
ax1.fill(xi, yi, "w")

fig, ax1 = plt.subplots()
xs, ys = standPet.exterior.xy
#xs, ys = trans.exterior.xy
#xs, ys = scaled.exterior.xy
ax1.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax1.fill(xs, ys, "r")

## seems to work. make a function for defining zones? 

## takes a standardized petal polygon:

def findZones(standPol, percent):
    hole = standPol
    rad = 0
    ## iterate down till we get our percent margin:
    while hole.area > percent:
        hole = standPol.buffer(rad)
        rad -= .001
    holeR = sg.polygon.asLinearRing(hole)
    ## now make a polygon with this as a hole
    marg = sg.polygon.Polygon(
            standPet.exterior, 
            holes = [hole.exterior.coords])
    ## make throat.
    ## exterior corners:
    aa = marg.simplify(0.05)
    bb = np.array(aa.exterior.xy).transpose()
    bb[:,0].argsort()
    ## gives us an array of ranks of the values, 
    ## use this to sort:
    zz = bb[bb[:,1].argsort()[::-1]]
    ## for our corners, take the top two:
    yy = zz[0:2]
    ## interior corners:
    bb = np.array(aa.interiors[0].xy).transpose()
    bb[:,0].argsort()
    ## gives us an array of ranks of the values, 
    ## use this to sort:
    zz = bb[bb[:,1].argsort()[::-1]]
    ## for our corners, take the top two:
    xx = zz[0:2,]
    xx = np.flipud(xx) 
    ##combine corners, make throat:
    tt = np.concatenate((yy,xx))
    throat = sg.polygon.Polygon(tt)
    return(marg, throat)

## does this work?

marg,throat = findZones(standPet, 0.5)

#################
#################

## todo today

## define flower class
## zones 



fig, (ax1,ax2) = plt.subplots(ncols=2)
xs, ys = standPet.exterior.xy
ax1.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax1.fill(xs, ys, "r")

xs, ys = standPet.exterior.xy
ax2.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax2.fill(xs, ys, "r")

xo, yo = marg.exterior.xy
ax2.plot(xo, yo, "b")
xo, yo = marg.interiors[0].xy
ax2.plot(xo, yo, "b")
xo, yo = throat.exterior.xy
ax2.plot(xo, yo, "b")


##############

## Aug 29

## today:

## throat polygon - make it match the margin outline where they intersect. Then leave, you fucking perfectionist. 

## define flower class

## streamline code. 

################

## python
import numpy as np
import matplotlib.pyplot as plt
import shapely.geometry as sg
import shapely.affinity as sa
from skimage import measure
from descartes import PolygonPatch

## Let's redo the throat.

## our four functions so far for creating polygons:

def digitizePols(file):
    ## pad margins of image and get the contour of the petal shape
    petal = np.genfromtxt (file, delimiter=",")
    petal_marg = np.insert(petal, petal.shape[1], 1, 1)
    petal_marg = np.insert(petal_marg, 0, 1, 1)
    petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
    petal_marg = np.insert(petal_marg, 0, 1, 0)
    Pcontours = measure.find_contours(petal_marg, 0)
    ## gotta ditch <3 points, they are lines
    polys = [ i for i in Pcontours if len(i) > 3 ]
    return(polys)

def getPetGeoInfo(pet):
    aa = sg.asPolygon(pet)
    area = aa.area
    scalar = area**(-1/2)
    center = aa.centroid
    centerCoor = (center.x, center.y)
    return(scalar, centerCoor)

def stand(pol, scale, cent):
    aa = sg.asPolygon(pol)
    trans = sa.translate(aa, (-1*cent[0]), (-1*cent[1]))
    scaled = sa.scale(trans, xfact=scale, yfact=scale, origin = (0,0))
    return(scaled)


def findZones(standPol, percent):
    hole = standPol
    rad = 0
    ## iterate down till we get our percent margin:
    while hole.area > percent:
        hole = standPol.buffer(rad)
        rad -= .001
    ## now make a polygon with this as a hole
    marg = sg.polygon.Polygon(
            standPet.exterior,
            holes = [hole.exterior.coords])
    ## make throat.
    ## exterior corners:
    aa = marg.simplify(0.05)
    bb = np.array(aa.exterior.xy).transpose()
    bb[:,0].argsort()
    ## gives us an array of ranks of the values,
    ## use this to sort:
    zz = bb[bb[:,1].argsort()[::-1]]
    ## for our corners, take the top two:
    yy = zz[0:2]
    ## interior corners
    bb = np.array(aa.interiors[0].xy).transpose()
    bb[:,0].argsort()
    ## gives us an array of ranks of the values,
    ## use this to sort
    zz = bb[bb[:,1].argsort()[::-1]]
    xx = zz[0:2,]
    xx = np.flipud(xx)
    ## combine corners, make throat:
    tt = np.concatenate((yy,xx))
    throat = sg.polygon.Polygon(tt)
    return(marg, throat)

## rerun our samples:

## we have an example "right" or lower petal example in our wd:
petalFile=('P431F1petal.csv')
spotsFile=('P431F1spots.csv')
## 1 make our raw, unscaled, untranslated polygons:
testP = digitizePols(petalFile)[0] ## for petals, take first polygon, always seems to work?
testS = digitizePols(spotsFile)
## 2 get information about centroid and scaling factor:
scale, cent = getPetGeoInfo(testP)
## 3 standardize petals
standPet = stand(testP, scale, cent)
## 4 standardize spots
spotz = [ stand(i, scale, cent) for i in testS ]
## 5 define zones, at 50%:
marg,throat = findZones(standPet, 0.5)

## plot it:

fig, (ax1,ax2) = plt.subplots(ncols=2)
xs, ys = standPet.exterior.xy
ax1.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax1.fill(xs, ys, "r")

xs, ys = standPet.exterior.xy
ax2.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax2.fill(xs, ys, "r")

xo, yo = marg.exterior.xy
ax2.plot(xo, yo, "b")
xo, yo = marg.interiors[0].xy
ax2.plot(xo, yo, "b")
xo, yo = throat.exterior.xy
ax2.plot(xo, yo, "b") 

## okay, how do we get a nicer throat polygon:

fig, ax1 = plt.subplots()
xo, yo = marg.exterior.xy
ax1.plot(xo, yo, "r")
xo, yo = marg.interiors[0].xy
ax1.plot(xo, yo, "r")
xo, yo = throat.exterior.xy
ax1.plot(xo, yo, "b") 
 
## can we cut out the throat?

aa = throat.intersection(marg)

bb = marg.difference(throat)

cc = throat.difference(marg)

fig, ax1 = plt.subplots(ncols=1)
for i in bb:
    xo, yo = i.exterior.xy
    ax1.plot(xo, yo, "b")

## okay, how do we grab those little bits of margin 
## close to our first throat polygon 
## tking the rest of the margin?

## grow the throat polygon outward:

tb = throat.buffer(0.1)

fig, ax1 = plt.subplots(ncols=1)
xo, yo = tb.exterior.xy
ax1.fill(xo, yo, 
         facecolor="#FF9933",
         alpha=0.3)
for i in bb:
    xo, yo = i.exterior.xy
    ax1.plot(xo, yo, "b")

## how can we get just the polys inside our big throat buffer?
## it's a multpolygon, so we can sort treat it like a list
## polygons:

cc = [ i.within(tb) for i in bb ]

## how do we make a new polygon out of this?

cc = [ i for i in bb if i.within(tb) ]

## can we turn this back into a multipolygon?

dd = sg.multipolygon.MultiPolygon(cc)

## look at it:


fig, ax1 = plt.subplots(ncols=1)
xo, yo = tb.exterior.xy
ax1.fill(xo, yo, 
         facecolor="#FF9933",
         alpha=0.3)
for i in dd:
    xo, yo = i.exterior.xy
    ax1.plot(xo, yo, "b")


## promising - merge it with our throat/margin intersection 
## from above?

## our real throat polygon:
ee = aa.union(dd)

fig, ax1 = plt.subplots(ncols=1)
xo, yo = ee.exterior.xy
ax1.plot(xo, yo)
xo, yo = aa.exterior.xy
ax1.fill(xo, yo, 
         facecolor="#FF66B2",
         alpha=0.3)

## our center?

## let's revise our function to include this


## looks good. Can we break up our petal clean?
## into three polygons this way?

def findZones(standPol, percent):
    center = standPol
    rad = 0
    while center.area > percent:
        center = standPol.buffer(rad)
        rad -= .001
    marg = sg.polygon.Polygon(
            standPet.exterior,
            holes = [center.exterior.coords])
    simPol = marg.simplify(0.05)
    simPolA = np.array(simPol.exterior.xy).transpose()
    simPolA[:,0].argsort()
    simPolAsorted = simPolA[simPolA[:,1].argsort()[::-1]]
    outCorners = simPolAsorted[0:2]
    simPolB = np.array(simPol.interiors[0].xy).transpose()
    simPolB[:,0].argsort()
    simPolBsorted = simPolB[simPolB[:,1].argsort()[::-1]]
    inCorners = simPolBsorted[0:2,]
    inCorners = np.flipud(inCorners)
    tRap = np.concatenate((outCorners,inCorners))
    tRapPoly = sg.polygon.Polygon(tRap)
    tBuff = tRapPoly.buffer(0.1)
    noTrap = marg.difference(tRapPoly)
    notInTrap = [ i for i in noTrap if i.within(tBuff) ]
    mpNotInTrap = sg.multipolygon.MultiPolygon(notInTrap)
    throat = tRapPoly.union(mpNotInTrap )
    return(center, marg, throat)

## okay, we want to make this spit out non-overlapping zones, that cover 
## all surface of the original petal polygon.

percent = 0.5
center = standPol = standPet

def findZones(standPol, percent):
    center = standPol
    rad = 0
    while center.area > percent:
        center = standPol.buffer(rad)
        rad -= .001
    marg = sg.polygon.Polygon(
            standPet.exterior,
            holes = [center.exterior.coords])
    simPol = marg.simplify(0.05)
    simPolA = np.array(simPol.exterior.xy).transpose()
    simPolA[:,0].argsort()
    simPolAsorted = simPolA[simPolA[:,1].argsort()[::-1]]
    outCorners = simPolAsorted[0:2]
    simPolB = np.array(simPol.interiors[0].xy).transpose()
    simPolB[:,0].argsort()
    simPolBsorted = simPolB[simPolB[:,1].argsort()[::-1]]
    inCorners = simPolBsorted[0:2,]
    inCorners = np.flipud(inCorners)
    tRap = np.concatenate((outCorners,inCorners))
    tRapPoly = sg.polygon.Polygon(tRap)
    tBuff = tRapPoly.buffer(0.1)
    noTrap = marg.difference(tRapPoly)
    notInTrap = [ i for i in noTrap if i.within(tBuff) ]
    mpNotInTrap = sg.multipolygon.MultiPolygon(notInTrap)
    margInTrap = tRapPoly.intersection(marg)
    throat = margInTrap.union(mpNotInTrap )
    edge = marg.difference(throat)
    return(center, edge, throat)

center, edge, throat = findZones(standPet, 0.5)


## let's try this patches:

fig, ax1 = plt.subplots(ncols=1)
ax1.set_xlim(-0.8,0.8)
ax1.set_ylim(-0.8,0.8)

ax1.add_patch(PolygonPatch(edge, fc='blue', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(tRapPoly, fc='blue', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(margInTrap, fc='blue', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(noTrap, fc='blue', ec='blue', alpha=0.5))

for i in notInTrap:
    ax1.add_patch(PolygonPatch(i, fc='blue', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(mpNotInTrap, fc='blue', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(tBuff, fc='blue', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(center, fc='blue', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(edge, fc='red', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(throat, fc='yellow', ec='blue', alpha=1.0))

ax1.add_patch(PolygonPatch(standPet, fc='yellow', ec='blue', alpha=1.0))

## looks good. 

## so, lots to do from here:

## check out Melias new outputs.

## turn the above into a script that you can run on all of them. 

## run it on all of them. 

## improve corner detection for side petals

## get stats - edge spots, center spots, centeredness, throat spots, 


############ task #1 - check on side petals:

## how well does our algorithm perfom on the upper pettals? Their corners are not so pronounced as the lower:

## here is an upper petal that belongs to the same flower as our example:

petDir = ("/Users/danthomas/Documents/speckling"
          "/make_polygons/polygons/P431F1/left/")

petalFName=('P431F1_left_petal.csv')
spotsFName=('P431F1_left_spots.csv')
petalFile=(petDir + petalFName)
spotsFile=(petDir + spotsFName)

## run this through our pipeline:

testP = digitizePols(petalFile)[0] 
testS = digitizePols(spotsFile)
scale, cent = getPetGeoInfo(testP)
standPet = stand(testP, scale, cent)
spotz = [ stand(i, scale, cent) for i in testS ]
center, edge, throat = findZones(standPet, 0.5)


## can we make a plotting function:


## need to harden our polygons a bit more to get side petals to work...

## looks good

############### rerun Melia's data #########

## we need to get melia's new clusters into our python 
## pipeline. Everything should be the same, if Melia's
## side went smoothly. 

## so just plug in her new files into the right place:

## (doug's raster folder), then rerun the script "prepDougRasters.m"

## now we need a script for running our digitization all 
## the function

## then a script for showing them

## the script for digitizing a directory of a petal 
## we called this "get_pols.py", let's revise that 
## script to do what we need.





## draft script is used like this:

cd /Users/danthomas/Documents/speckling/make_polygons

ff="/Users/danthomas/Documents/speckling/make_polygons/polygons/P431F1/mid"
dd="/Users/danthomas/Desktop/tryScript"
./get_pols.py $ff 0.5 $dd

cd $dd

## did it work?

python3

import argparse, os, pickle

import numpy as np
import matplotlib.pyplot as plt
import shapely.geometry as sg
import shapely.affinity as sa
from skimage import measure
from descartes import PolygonPatch

zoop = "this is a piece of text"
pickle.dump(zoop, open("zoop.p", "wb"))
pickle.dump(zoop, open("zoop.p", "w")) ## doesn't work, 
pickle.dump(zoop, open("zoop.p", "wt")) ## doesn't work, 
del(zoop)
test = pickle.load(open("zoop.p", "rb"))

aa = pickle.load(open("P431F1_mid_polys.p", "r"))

aa = pickle.load(open("P431F1_mid_polys.p", "rb"))



## ugh, not working. 

#####

def pZones(standPet, spotz, center, edge, throat):
    fig, (ax1,ax2) = plt.subplots(ncols=2)
    xs, ys = standPet.exterior.xy
    ax1.fill(xs, ys, "y")
    for i in spotz:
        xs, ys = i.exterior.xy
        ax1.fill(xs, ys, "r")
     
    ax2.set_xlim(ax1.get_xlim())
    ax2.set_ylim(ax1.get_ylim())
    xs, ys = standPet.exterior.xy
    ax2.fill(xs, ys, "y")
    for i in spotz:
        xs, ys = i.exterior.xy
        ax2.fill(xs, ys, "r")

    alp=0.5
    l=5
    ax2.add_patch(PolygonPatch(center,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    ax2.add_patch(PolygonPatch(throat,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    ax2.add_patch(PolygonPatch(edge,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))

####

cd /Users/danthomas/Documents/speckling/make_polygons

python3 

import argparse, os, pickle, json, pprint
import numpy as np
import matplotlib.pyplot as plt
import shapely.geometry as sg
import shapely.affinity as sa
from skimage import measure
from descartes import PolygonPatch
from get_pols import *


#import get_pols 


## here is the __main__ script, minus imports, args etc

#folder="/Users/danthomas/Documents/speckling/make_polygons/polygons/P431F1/right"
folder="/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons/P431F1/right"
#destination="/Users/danthomas/Desktop/tryScript"
destination="/home/daniel/Desktop/tryScript"
centerSize=0.5


#######

os.chdir(folder)
aa = os.listdir()

for i in aa:
    if "petal" in i:
        petPol = digitizePols(i)[0]
    elif "spots" in i:
        spotPol = digitizePols(i)

scale, cent = getPetGeoInfo(petPol)

standPet = stand(petPol, scale, cent)
standSpot = sg.multipolygon.MultiPolygon([ stand(i, scale, cent) for i in spotPol ])

center, edge, throat = findZones(standPet, centerSize, 0.07)

polys = {
    'standPet': standPet,
    'standSpot': standSpot,
    'center': center,
    'edge': edge,
    'throat': throat
            }

sg.multipolygon.MultiPolygon

mply = sg.multipolygon.MultiPolygon([standPet, center, edge, throat])

mply = sg.multipolygon.MultiPolygon([standPet, center, edge, throat])

mply = sg.multipolygon.MultiPolygon([standPet, standSpot, center, edge, throat])



here = os.getcwd()
petalName = os.path.basename(here)
flowerName = os.path.basename(os.path.dirname(here))
gjName = (flowerName + "_" 
          + petalName 
          + "_polys")
outFileName = ( destination + "/"
                + flowerName + "_"
                + petalName
                + "_polys.geojson")


## can we output as a geojson?
gj = json.dumps(sg.mapping(standPet))

## can it handle multiple objects?



with open(outFileName, "w") as output:
    output.write(gj)

## works. can we do a multipolygon? like if the throat gets weird?

os.chdir("/Users/danthomas")

gj_throat = json.dumps(sg.mapping(throat))

with open("throat.geojson", "w") as output:
    output.write(gj_throat)

#######

    

os.chdir("/Users/danthomas/Desktop")

gj_throat = json.dumps(sg.mapping(aa))

with open("throat2.geojson", "w") as output:
    output.write(gj_throat)

### check plot

pZones(standPet, standSpot, center, edge, throat)

##### write out iterations ######### 

os.mkdir("") ## make home for geojsons
os.chdir("") ## go there



## seems to work

## can we collect all this into a geo collection, export 
## as geo json?


## nah. Let's reduce the nesting for the moment.



os.chdir("/home/daniel/Desktop")



## construct feature collection geojson


featC = {
        "type" : "FeatureCollection",
        "features" : [],
        } 

partNames = ['Petal', 'Spots', 'Center', 'Edge', 'Throat']

for i,part in enumerate([standPet, standSpot, center, edge, throat]):
    gj_i = sg.mapping(part)
    feature_i = {"type": "Feature",
          "geometry": gj_i,
          "properties": {"id":(partNames[i])}}
    featC['features'].append(feature_i)


with open('jsonDumpResult.json', 'w') as fp:
    json.dump(featC, fp)



## does this parse well back into shapely?

with open('jsonDumpResult.geojson') as gjf:
    aa = json.load(gjf)


len(aa['features'])


bb = sg.shape(aa)

for i in range(5):
    aa['features'][i].keys()

bb = sg.shape(aa['features'][0]['geometry']) ## works, but we need to retain names


aa['features'][0]['properties']['id']


## so get a list of geometries:

listP = (aa['features'])

## find the one that has petal outline:

bb = [ i for i in listP if i['properties']['id'] == 'Petal' ]

cc = bb[0]['geometry']

dd = sg.shape(cc)

## did this work?

fig, ax1 = plt.subplots()
x, y = dd.exterior.xy
ax1.fill(x, y, 'b')

## yup. so a general function for parsing this geojson:


with open('jsonDumpResult.geojson') as gjf:
    aa = json.load(gjf)

listP = (aa['features'])

## find the one that has petal outline:

bb = [ i for i in listP if i['properties']['id'] == 'Petal' ]

cc = bb[0]['geometry']

dd = sg.shape(cc)

## did this work?


########### geojson parse ###############3

## yup. so build a general function for parsing this geojson:

file="P400F2_right_polys.geojson"

with open(file) as gjf:
    spotsGJ = [ i for i in listP if i['properties']['id'] == 'Spots' ][0]['geometry'] 

    spotsPoly = sg.shape(spotsGJ)

#def parseGeoj(file):
    #with open(file) as gjf:

file="P400F2_right_polys.geojson"
with open(file) as gjf:
    aa = json.load(gjf)
    listP = (aa['features'])
    petalGJ = [ i for i in listP if i['properties']['id'] == 'Petal' ][0]['geometry'] 
    petalPoly = sg.shape(petalGJ)
    spotsGJ = [ i for i in listP if i['properties']['id'] == 'Spots' ][0]['geometry'] 
    spotsPoly = sg.shape(spotsGJ)
    print('made it here')
    centerGJ = [ i for i in listP if i['properties']['id'] == 'Center' ][0]['geometry'] 
    centerPoly = sg.shape(centerGJ)
    edgeGJ = [ i for i in listP if i['properties']['id'] == 'Edge' ][0]['geometry'] 
    edgePoly = sg.shape(edgeGJ)
    throatGJ = [ i for i in listP if i['properties']['id'] == 'Throat' ][0]['geometry'] 
    throatPoly = sg.shape(throatGJ)

   return(petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly)




## oops. looks like we need to clean up the edges, too..

## okay, debugging pile too big. Cleanup.

## modify the module so that it should spit out 
## geojsons. 

## try it, check results as above, see if more 
## debugging is needed.

## then add parsing to notebook


## try out the new script:

ff="/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons/P400F2/right"
dd="/home/daniel/Documents/mimulusSpeckling/make_polygons/tryscript"
./get_pols.py $ff 0.5 $dd

## failed...
## shapely.errors.TopologicalError

## start over....


import argparse, os, pickle, json, pprint
import numpy as np
import matplotlib.pyplot as plt
import shapely.geometry as sg
import shapely.affinity as sa
import shapely.errors
from skimage import measure
from descartes import PolygonPatch
from get_pols import *

## script minus the functions is:

folder="/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons/P400F2/right"
centerSize=0.5
destination="/home/daniel/Documents/mimulusSpeckling/make_polygons/tryscript" 

## run through digitizing, standardizing, zone calling pipeline
os.chdir(folder)
aa = os.listdir()
for i in aa:
    if "petal" in i:
        petPol = digitizePols(i)[0]
    elif "spots" in i:
        spotPol = digitizePols(i)


scale, cent = getPetGeoInfo(petPol)
standPet = stand(petPol, scale, cent)
standSpot = [ stand(i, scale, cent) for i in spotPol ]


try:

center, edge, throat = findZones(standPet, centerSize, 0.07)

except shapely.errors.TopologicalError as x:
    print("zones won't be available")
    center = edge = throat = {"type": "Polygon", "coordinates": []}

def findZones(standPol, percent, simp=0.05):

standPol=standPet
percent = 0.5
simp=0.05

center = standPol
rad = 0
while center.area > percent:
    center = standPol.buffer(rad)
    rad -= .001
marg = sg.polygon.Polygon(
        standPol.exterior,
        holes = [center.exterior.coords])
simPol = marg.simplify(simp)
simPolA = np.array(simPol.exterior.xy).transpose()
simPolAsorted = simPolA[simPolA[:,1].argsort()[::-1]]
outCorners = simPolAsorted[0:2]
simPolB = np.array(simPol.interiors[0].xy).transpose()
simPolBsorted = simPolB[simPolB[:,1].argsort()[::-1]]
inCorners = simPolBsorted[0:2,]
inCorners = np.flipud(inCorners)
tRap = np.concatenate((outCorners,inCorners))
tRapPoly = sg.polygon.Polygon(tRap)
tBuff = tRapPoly.buffer(0.1)

noTrap = marg.difference(tRapPoly)


notInTrap = [ i for i in noTrap if i.within(tBuff) ]
mpNotInTrap = sg.multipolygon.MultiPolygon(notInTrap)
margInTrap = tRapPoly.intersection(marg)
throatRaw = margInTrap.union(mpNotInTrap )
throat = cleanCollections(throatRaw)
edgeRaw = marg.difference(throat)
edge = cleanCollections(edgeRaw)
#    return(center, edge, throat)


##########

fig, ax1 = plt.subplots(ncols=1)
x, y = standPet.exterior.xy
ax1.fill(x, y, "y")
x, y = tRapPoly.exterior.xy
ax1.fill(x, y, "b")

x, y = standSpot[1].exterior.xy
ax1.fill(x, y, "r")


##########

## organize name
here = os.getcwd()
petalName = os.path.basename(here)
flowerName = os.path.basename(os.path.dirname(here))
gjName = (flowerName + "_"
          + petalName
          + "_polys")
outFileName = ( destination + "/"
                + flowerName + "_"
                + petalName
                + "_polys.geojson")

## outputs

## define get a dictionary that resembles a geojson feature collection:
featC = {
        "type" : "FeatureCollection",
        "features" : [],
        }

## fill it with features
partNames = ['Petal', 'Spots', 'Center', 'Edge', 'Throat']
## each geometry needs a feature wrapper
for i,part in enumerate([standPet, standSpot, center, edge, throat]):
    gj_i = sg.mapping(part)
    feature_i = {"type": "Feature",
          "geometry": gj_i,
          "properties": {"id":(partNames[i])}}
    featC['features'].append(feature_i)

aa = sg.mapping(standSpot)

bb = shapely.geometry.multipolygon.MultiPolygon(standSpot)

aa = sg.mapping(bb)

## write it out
with open(outFileName, 'w') as fp:
    json.dump(featC, fp)

###############33

Petal, Spots, Center, Edge, Throat = parseGeoj('P400F2_right_polys.geojson')

parseGeoj('P400F2_right_polys.geojson')

## so where were we? 

## we need our geoj parser to work, so we can make our 
## odf. 

## and we need our base digitization script to 
## work smoothly

## can't get it perfect right now, lots of exception handles

## cuz they probably don't want me spending another month 
## on this... 


## okay - can we run this script on all our folders?


## where do we want these files? 

## next step is a pdf that shows how they worked.

## do we want to 


## bash script - make our digitizations, for all polygons

##########################################
#!/usr/bin/env bash

getpols='/home/daniel/Documents/mimulusSpeckling/make_polygons/get_pols.py'
wd='/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons'

cd $wd

for i in *; do
    echo $i 
    cd $i 
    for j in *; do
        fullN=$PWD/$j
        $getpols $fullN 0.5 $fullN
    done
    cd ../
done

##################################################

## to run it
bash runAllDigs.sh |& tee runAllDigsLog.txt

ls -R /home/daniel/Documents/mimulusSpeckling/make_polygons/polygons/P247F1

cd /home/daniel/Documents/mimulusSpeckling/make_polygons/polygons/P247F1/left

## so that's running...

## how do we check the results?

## we probably want something like last time

## let's try one in matplotlib:

python3

import argparse, os, json, pprint
import numpy as np
import matplotlib.pyplot as plt
import shapely.geometry as sg
import shapely.affinity as sa
from skimage import measure
from descartes import PolygonPatch

## how do we plot a jpeg?

## let's use our very first petal as an example:



## we gotta fix our geojson parser:

## may god and stackoverflow forgive me




def parseGeoj(file):
    with open(file) as gjf:
        aa = json.load(gjf)
        listP = (aa['features'])
        try:
            petalGJ = [ i for i in listP if i['properties']['id'] == 'Petal' ][0]['geometry'] 
            petalPoly = sg.shape(petalGJ)
        except:
            petalPoly = sg.polygon.Polygon()
        try:
            spotsGJ = [ i for i in listP if i['properties']['id'] == 'Spots' ][0]['geometry'] 
            spotsPoly = sg.shape(spotsGJ)
        except:
            spotsPoly = sg.polygon.Polygon()
        try:
            centerGJ = [ i for i in listP if i['properties']['id'] == 'Center' ][0]['geometry'] 
            centerPoly = sg.shape(centerGJ)
        except:
            centerPoly = sg.polygon.Polygon()
        try:
            edgeGJ = [ i for i in listP if i['properties']['id'] == 'Edge' ][0]['geometry'] 
            edgePoly = sg.shape(edgeGJ)
        except:
            edgePoly = sg.polygon.Polygon()
        try:
            throatGJ = [ i for i in listP if i['properties']['id'] == 'Throat' ][0]['geometry'] 
            throatPoly = sg.shape(throatGJ)
        except:
            throatPoly = sg.polygon.Polygon()
    return(petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly)


## our first flower:

file="P247F1_left_polys.geojson"

os.chdir('/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons/P247F1/left')

petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly = parseGeoj(file)

## does this work?

alp=0.5
l=5




fig, ax1 = plt.subplots()

x, y = petalPoly.exterior.xy
ax1.fill(x, y, "y", alpha=1.0)

for i in spotsPoly:
    x, y = i.exterior.xy
    ax1.fill(x, y, "r")

x, y = centerPoly.exterior.xy
ax1.fill(x, y, "w", alpha=0.3)
x, y = edgePoly.exterior.xy
ax1.fill(x, y, "o", alpha=0.3)
x, y = throatPoly.exterior.xy
ax1.fill(x, y, "b", alpha=0.3)

## looks okay, but I think we're better off with the 
## graphing function in our notebook.

## think we need another script for this.
import os, json 
import numpy as np
import shapely.geometry as sg
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from descartes import PolygonPatch

## first, get matplot a jpeg to print. 

## gonna have to get this off doug's directory:

dougDir='/home/daniel/Documents/mimulusSpeckling/dougRaster/Rotated_and_Cropped'
os.chdir(dougDir)
aa = os.listdir()
bb = [ i for i in aa if 'JPG' in i]


## our first row is a plot using one of these jpegs:
i=0
imgFullName=(dougDir + '/' + bb[i])
ax1 = plt.subplot2grid((4,3), (0,0), colspan=3)
img=mpimg.imread(imgFullName)
ax1.imshow(img)

## sorta works. second row is doug's rasters of the leaves
## these are in our polygon folders. How can we find this?

cc = bb[0][0:-4] ##flower name
polDir='/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons'

os.chdir(polDir + "/" + cc)

fp = os.listdir()

for i in fp:
    os.chdir(i)
    spotsCSV = [ i for i in os.listdir() if 'spots' in i ][0]
    petalCSV = [ i for i in os.listdir() if 'petal' in i ][0]
    geoj = [ i for i in os.listdir() if 'geojson' in i ][0]
    petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly = parseGeoj(geoj)
    ## insert print page
    os.chdir(polDir + "/" + cc)





## we want a side=by-side of our rasters. can we read them  and plot them?

## how to read these in...

#petalCSV=('P402F1_left_petal.csv')
#spotsCSV=('P402F1_left_spots.csv')

petalMat = np.genfromtxt(petalCSV, delimiter=',')

plt.imshow(petalMat, cmap='gray')

spotsMat = np.genfromtxt(spotsCSV, delimiter=',')
plt.imshow(spotMat, cmap='gray')

## pretty simple
## maybe a row of six images, side-by-sides of all three petals

##########################


## polygons
## these we get from the geojsons, using our parsing function. 
## need one from each directory


## plotting function? We want a row without zones:

def plotNoZone(petalPoly, spotsPoly, x, y):
    alp=1.0
    l=2
    ax1 = plt.subplot2grid((4, 3), (x, y), colspan=1)
    ax1.set_aspect('equal')
    ax1.set_xlim(min(petalPoly.exterior.xy[0]), max(petalPoly.exterior.xy[0]))
    ax1.set_ylim(min(petalPoly.exterior.xy[1]), max(petalPoly.exterior.xy[1]))
    ax1.add_patch(PolygonPatch(petalPoly,
                  fc='yellow', ec='black',
                  linewidth=l, alpha=alp))
    ax1.add_patch(PolygonPatch(spotsPoly,
                  fc='red', ec='black',
                  linewidth=l, alpha=alp))


plotNozone(petalPoly, spotsPoly)

## works

##############


## okay, with zones?

def plotYesZone (petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly, x ,y):
    alp=0.3
    l=2
    ax1 = plt.subplot2grid((4, 3), (x, y), colspan=1)
    ax1.set_xlim(min(petalPoly.exterior.xy[0]), max(petalPoly.exterior.xy[0]))
    ax1.set_ylim(min(petalPoly.exterior.xy[1]), max(petalPoly.exterior.xy[1]))
    ax1.set_aspect('equal')
    ax1.add_patch(PolygonPatch(petalPoly,
                  fc='yellow', ec='black',
                  linewidth=l, alpha=1.0))
    ax1.add_patch(PolygonPatch(spotsPoly,
                  fc='red', ec='black',
                  linewidth=l, alpha=1.0))
    ax1.add_patch(PolygonPatch(centerPoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    ax1.add_patch(PolygonPatch(edgePoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    ax1.add_patch(PolygonPatch(throatPoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))


plotYesZone(petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly, 0,0)


#####################

## okay, that's everything, right?

## first row is jpg
## second row is doug's rasters
## third row is petal and spots
## fourth row is zones


## can we make a page with these?

## makePDFs.py
#########################################################
#!usr/bin//env python3

import os, json 
import numpy as np
import shapely.geometry as sg
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from descartes import PolygonPatch

def parseGeoj(file):
    with open(file) as gjf:
        aa = json.load(gjf)
        listP = (aa['features'])
        try:
            petalGJ = [ i for i in listP if i['properties']['id'] == 'Petal' ][0]['geometry'] 
            petalPoly = sg.shape(petalGJ)
        except:
            petalPoly = sg.polygon.Polygon()
        try:
            spotsGJ = [ i for i in listP if i['properties']['id'] == 'Spots' ][0]['geometry'] 
            spotsPoly = sg.shape(spotsGJ)
        except:
            spotsPoly = sg.polygon.Polygon()
        try:
            centerGJ = [ i for i in listP if i['properties']['id'] == 'Center' ][0]['geometry'] 
            centerPoly = sg.shape(centerGJ)
        except:
            centerPoly = sg.polygon.Polygon()
        try:
            edgeGJ = [ i for i in listP if i['properties']['id'] == 'Edge' ][0]['geometry'] 
            edgePoly = sg.shape(edgeGJ)
        except:
            edgePoly = sg.polygon.Polygon()
        try:
            throatGJ = [ i for i in listP if i['properties']['id'] == 'Throat' ][0]['geometry'] 
            throatPoly = sg.shape(throatGJ)
        except:
            throatPoly = sg.polygon.Polygon()
    return(petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly)

def plotNoZone(petalPoly, spotsPoly, x, y):
    alp=1.0
    l=2
    ax1 = plt.subplot2grid((4, 3), (x, y), colspan=1)
    ax1.set_aspect('equal')
    ax1.set_xlim(min(petalPoly.exterior.xy[0]), max(petalPoly.exterior.xy[0]))
    ax1.set_ylim(min(petalPoly.exterior.xy[1]), max(petalPoly.exterior.xy[1]))
    ax1.add_patch(PolygonPatch(petalPoly,
                  fc='yellow', ec='black',
                  linewidth=l, alpha=alp))
    ax1.add_patch(PolygonPatch(spotsPoly,
                  fc='red', ec='black',
                  linewidth=l, alpha=alp))

def plotYesZone (petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly, x ,y):
    alp=0.3
    l=2
    ax1 = plt.subplot2grid((4, 3), (x, y), colspan=1)
    ax1.set_xlim(min(petalPoly.exterior.xy[0]), max(petalPoly.exterior.xy[0]))
    ax1.set_ylim(min(petalPoly.exterior.xy[1]), max(petalPoly.exterior.xy[1]))
    ax1.set_aspect('equal')
    ax1.add_patch(PolygonPatch(petalPoly,
                  fc='yellow', ec='black',
                  linewidth=l, alpha=1.0))
    ax1.add_patch(PolygonPatch(spotsPoly,
                  fc='red', ec='black',
                  linewidth=l, alpha=1.0))
    ax1.add_patch(PolygonPatch(centerPoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    ax1.add_patch(PolygonPatch(edgePoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    ax1.add_patch(PolygonPatch(throatPoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))

## make these into command line args?
polDir='/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons'
dougDir='/home/daniel/Documents/mimulusSpeckling/dougRaster/Rotated_and_Cropped'
targetDir='/home/daniel/Documents/mimulusSpeckling/make_polygons/bigPDF/testNew'

os.chdir(dougDir)
aa = os.listdir()
bb = [ i for i in aa if 'JPG' in i]

for flowerJpg in bb:
    print(flowerJpg)


for flowerJpg in bb:
    flowerName = flowerJpg[0:-4] ##flower name
    fig = plt.figure()
    fig.suptitle(flowerName, fontsize=12)
    ## our first row is a plot using one of these jpegs:
    imgFullName=(dougDir + '/' + flowerJpg)
    ax1 = plt.subplot2grid((4,3), (0,0), colspan=3)
    img=mpimg.imread(imgFullName)
    ax1.imshow(img)
    ## second row is Doug's rasters
    os.chdir(polDir + "/" + flowerName) ## go to flower directory
    counter = 0 ## for keeping track of the 6 plots, second row
    for n,j in enumerate(['left', 'mid', 'right']):
        os.chdir(j)
        print("We are on " + j)
        spotsCSV = [ i for i in os.listdir() if 'spots' in i ][0]
        petalCSV = [ i for i in os.listdir() if 'petal' in i ][0]
        ## get rasters as CSVs
        petalMat = np.genfromtxt(petalCSV, delimiter=',')
        spotsMat = np.genfromtxt(spotsCSV, delimiter=',')
        ## plot these two rasters, petal outline and spots
        ax = plt.subplot2grid((4,6), (1, counter))
        ax.imshow(petalMat, cmap='gray')
        counter += 1
        ax = plt.subplot2grid((4,6), (1, counter))
        ax.imshow(spotsMat, cmap='gray')
        counter += 1
        ## get geojsons, turn them into polygons
        geoj = [ i for i in os.listdir() if 'geojson' in i ][0]
        print('current directory is:' + os.getcwd())
        petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly = parseGeoj(geoj)
        ## row 3 plot petal and spot geojsons
        plotNoZone(petalPoly, spotsPoly, 2, n)
        ## row 4 plot these with zones, if we have them:
        try:
                plotYesZone(petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly, 3, n)
        except: 
            ax=plt.subplot2grid((4,3),(3,n)) ## blank
        os.chdir(polDir + "/" + flowerName) ## go back to flower directory
    os.chdir(dougDir)

        plt.savefig



fig = plt.figure()

ax=plt.subplot2grid((4,3),(3,n))

ax1 = plt.subplot2grid((4, 3), (x, y), colspan=1)

petalPoly.is_empty
spotsPoly[0].is_empty
centerPoly.is_empty
edgePoly.is_empty
throatPoly.is_empty

##############

## can we make a big pdf out of these?


targetDir='/home/daniel/Documents/mimulusSpeckling/make_polygons/bigPDF/testNew'

cd $targetDir

pdftk !(echo * | sort) cat output digitizeBigPDF.09.06.2018.pdf

## okay, but text not searchable...



import os, json 
import numpy as np
import shapely.geometry as sg
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from descartes import PolygonPatch
from makePDFs import parseGeoj



## on the cases where there are no spots but all the petal 
## plots as a spot, is this real? Is this what dougs rasters
## say?

## P439F1 left and mid did this. Check them out:

wd='/home/daniel/Documents/mimulusSpeckling/make_polygons'
polDir='/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons'
dougDir='/home/daniel/Documents/mimulusSpeckling/dougRaster/Rotated_and_Cropped'
targetDir='/home/daniel/Documents/mimulusSpeckling/make_polygons/bigPDF/testNew'
#flowerName='P439F1'
flowerName='P430F1'

os.chdir(dougDir)

os.chdir(polDir + "/" + flowerName + "/" + 'left')

#show doug's images:

plt.ion()

spotsCSV = [ i for i in os.listdir() if 'spots' in i ][0]
petalCSV = [ i for i in os.listdir() if 'petal' in i ][0]
petalMat = np.genfromtxt(petalCSV, delimiter=',')
spotsMat = np.genfromtxt(spotsCSV, delimiter=',')

fig = plt.figure()
ax = plt.axes()
ax.imshow(petalMat, cmap='gray')

fig = plt.figure()
ax = plt.axes()
ax.imshow(spotsMat, cmap='gray')

## looks real...

## check one more:



## lots to do -

## get stats 
## update nb
## organize files - get geojsons where folks can use them


## ugh, gotta fix git. Some random large temp file is gumming
## things up

## not sure how this works, but here's a suggestion from stackoverflow
git filter-branch --index-filter 'git rm -r --cached --ignore-unmatch make_polygons/bigPDF/PolyPipeline_140818.pdf.part' HEAD


## worked,  can we do the merge?


##############################


## polygons traits. 

## we have a list of ~20 traits

## the goal is code all of them for one petal. 

## then automate to all three petals

## then automate to all flowers. 

## Melia asks that we then average flowers from
## the same plant together in all cases.

## to plot geojson:
def plotYesZone (petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly):
    alp=0.3
    l=2
    fig = plt.figure()
    ax1 = plt.axes()
    ax1.set_xlim(min(petalPoly.exterior.xy[0]), max(petalPoly.exterior.xy[0]))
    ax1.set_ylim(min(petalPoly.exterior.xy[1]), max(petalPoly.exterior.xy[1]))
    ax1.set_aspect('equal')
    ax1.add_patch(PolygonPatch(petalPoly,
                  fc='yellow', ec='black',
                  linewidth=l, alpha=1.0))
    try:
        ax1.add_patch(PolygonPatch(spotsPoly,
                      fc='red', ec='black',
                      linewidth=l, alpha=1.0))
    except:
        ax1.set_xlabel('No spots detected')
    ax1.add_patch(PolygonPatch(centerPoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    ax1.add_patch(PolygonPatch(edgePoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    try:
        ax1.add_patch(PolygonPatch(throatPoly,
                      fc='white', ec='black',
                      linewidth=l, alpha=alp))
    except:
        ax1.set_xlabel('throat and edges failed')


## our example petal:
## 297F2
## "right" lower petal

import os, json 
import numpy as np
import shapely.geometry as sg
import shapely.ops as so
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import pandas as pd
from descartes import PolygonPatch
from makePDFs import parseGeoj
from statistics import mean
from shapely.validation import explain_validity



## load the polygons:

wd='/home/daniel/Documents/mimulusSpeckling/make_polygons'
polyDir='/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons'
flowerName='P297F2'
petalName='right'
flpetDir= (polyDir + "/" + flowerName + "/" + petalName)
gjName = [ i for i in os.listdir(flpetDir) if "geojson" in i ][0]
petal, spots, center, edge, throat = parseGeoj(flpetDir + "/" + gjName)

## cleanup polys

edge = edge.buffer(0.0) 
aa = list(spots)
aa[1] = aa[1].buffer(0.0)
spots = sg.MultiPolygon(aa)

plt.ion()

plotYesZone(petal, spots, center, edge, throat)

## let's play with edges:

## this would be a loop through the spots to see
## which spots are "within","intersecting", or have "more than 50% intersecting"
 
## spots contained in center zone

spots.intersects(edge)

def plotOne(poly, l=2, a=1.0, col='yellow'):
    fig = plt.figure()
    ax1 = plt.axes()
    ax1.set_xlim(min(poly.exterior.xy[0]), max(poly.exterior.xy[0]))
    ax1.set_ylim(min(poly.exterior.xy[1]), max(poly.exterior.xy[1]))
    ax1.set_aspect('equal')
    ax1.add_patch(PolygonPatch(poly,
                  fc=col, ec='black',
                  linewidth=l, alpha=a))

plotOne(edge)

def addOne(poly, l=2, a=1.0, col='red'):
    ax1 = plt.axes()
    ax1.add_patch(PolygonPatch(poly,
                  fc=col, ec='black',
                  linewidth=l, alpha=a))

plotOne(edge)
addOne(spots, a=0.5)

## gotta check our polys, are they valid?


explain_validity(edge)

## self intersection. Can we buff it out?

aa = edge.buffer(0.0) 
aa.buffer(0.0).is_valid ## says its okay. 

## check plot:

edge = edge.buffer(0.0) 
edge.is_valid

plotOne(edge)

## do this for all polygons, make a function
## looks okay. Onward:

for i,j in enumerate(spots):
    print(i)
    j.intersects(edge)

## problem with second polygon:
spots[1].is_valid ## nope

plotOne(spots[1]) ## looks okay, what's wrong?

explain_validity(spots[1]) ## another self intersect. Buff it?

spots[1].buffer(0.0).is_valid ## looks okay

spots[1] = spots[1].buffer(0.0) ## doesn't work. 

## build new multipoly?

aa = list(spots)
aa[1] = aa[1].buffer(0.0)
spots = sg.MultiPolygon(aa)

[ i.intersects(edge) for i in spots ]

sum([ i.intersects(edge) for i in spots ]) / len(spots)

## that's cool, but wouldn't area be more informative?

## in case artificial lumping of spots occurred?

type(spots[0].intersection(edge))


aa = spots[0].intersection(edge)


aa.area
 
## seems okay. To get all the intersections:

partSpotsInEdge = [ i.intersection(edge) for i in spots ]

## does this look right?
partSpotsInEdge


##  why all the weird objects in this?

partSpotsInEdge[0].area

plotOne(edge)

addOne(partSpotsInEdge[0]) ## good
addOne(partSpotsInEdge[1]) ## good

addOne(partSpotsInEdge[2]) ## nope

partSpotsInEdge[2].area

partSpotsInEdge[2].is_empty


[ i.is_empty for i in partSpotsInEdge ]

[ type(i) for i in partSpotsInEdge ]

## so whereever a collection happened, empty

## and what about the multis?

partSpotsInEdge[5]


plotOne(edge)

[ addOne(i, a=0.5, col='blue') for i in partSpotsInEdge[5] ]

[ plotOne(i, a=0.5, col='blue') for i in partSpotsInEdge[5] ]

plotOne(partSpotsInEdge[5][0])

addOne(partSpotsInEdge[5][1])

addOne(spots, a=0.2)

## so they're legit. can we extract them, bring them to same
## level of nestedness?

list(partSpotsInEdge[5])

## back to the beginning, add conditional to keep out the empties
partSpotsInEdge = [ i.intersection(edge) for i in spots if i.intersects(edge) ]
## make a list of lists, even of single polygons
listz = [ list(i) if type(i) == sg.multipolygon.MultiPolygon else [i] for i in partSpotsInEdge ]
unNest = sum(listz, []) ## seems to work... not sure why...
## bring it back
partSpotsInEdge =  sg.multipolygon.MultiPolygon(unNest)
partSpotsInEdgeArea = sum([ i.area for i in partSpotsInEdge ])

plotOne(edge)
[ addOne(i, a=0.3) for i in spots ] 
[ addOne(i, col='blue') for i in partSpotsInEdge ] 

## okay, this can be used to find percent of edge covered by spots
## and percent of spot area in the edge:

## % edge covered by spots =

partSpotsInEdge

partSpotsInEdgeArea 

edgeCoveredbySpots = partSpotsInEdgeArea / edge.area  ## in this case, 0.26

## % spot area in the edge:

propSpotsInEdge = partSpotsInEdgeArea / spots.area  ## in this case, 0.39

## number of spots touching edge zone in some way

nuSpotsTouchEdge = len(partSpotsInEdge)

## how can tell how much of the actual edge has spot on it?

## get the exterior of the petal as a linestring

## make sure petal is valid:
petal.is_valid ## nope
## fix if possible:
petal = petal.buffer(0.0)
petal.is_valid ## yup

def plotLine(lin):
    ax1 = plt.axes()
    ax1.plot(lin.xy[0],lin.xy[1])

## so maybe:

shared = spots[1].intersection(petal.exterior)

#### nuSpotsTouchActualEdge

## to get the number of spots that contact the actual (not zone) edge:

nuSpotsTouchActualEdge = sum([ i.intersects(petal.exterior) for i in partSpotsInEdge ])


#### realEdgeSpotted

## to get the actual (not zone) edge that is covered by spots:

spotEdges = sum([ i.intersection(petal.exterior).length for i in partSpotsInEdge ])

realEdgeSpotted = spotEdges / petal.exterior.length ## 22% of petal edge is covered by spots

[ i.intersection(petal.exterior).length for i in partSpotsInEdge ]

#### how do get the distance from all spots to 

## do we want edge to edge, or centroid to edge of the polygon. 

## for one spot

plotOne(petal)
[ addOne(i) for i in spots ]

plotOne(petal)
[ addOne(i) for i in partSpotsInEdge ]

## to get the distance from edge of spot to edge of petal?

[ petal.exterior.distance(i) for i in spots if i.intersects(throat) ]

petal.exterior.distance(spots[0])

edge.exterior.distance(spots[0])

plotOne(petal)
[ addOne(i) for i in partSpotsInEdge ]


[ i.intersects(edge) for i in spots ]

## if throat worked, can we get a lower edge of the petal?
flowerCut = throat.intersection(petal.exterior)
notTube = [ i for i in spots if not i.intersects(flowerCut)] 
## works but depends of throat, will need to try

def plotLine(lin):
    ax1 = plt.axes()
    ax1.plot(lin.xy[0],lin.xy[1])

plotOne(petal)
addOne(throat)
[ plotLine(i) for i in flowerCut ]

## so how can we use this? 

plotOne(petal)
[ addOne(i) for i in notTube ]

plotOne(petal)
[ addOne(i) for i in spots ]

## use this subset

avgDistSpotEdgeEdge = mean([ petal.exterior.distance(i) for i in notTube ])

avgDistSpotEdge2Edge 

## can we do this with centroids?

avgDistSpotCentroid2Edge = [ petal.exterior.distance(i.centroid) for i in notTube ]

avgDistSpotCentroid2Edge


## so, can we get just the spots that are mostly in the edge?


len([ i for i in spots if i.intersects(edge) ])

spotsMostlyInEdge = [ i for i in spots if (i.intersection(edge).area / i.area > 0.5) ]

nuSpotsMostlyInEdge = len(spotsMostlyInEdge)

plotOne(petal)
[ addOne(i) for i in spotsMostlyInEdge ]

nuSpotsMostlyInEdge

## looks okay

## spots entirely in the edge:

spotsContainedInEdge = sum([ i.within(edge) for i in spots ])

[ i.within(edge) for i in spots ]

edge.is_valid

#################
## centeredness 

#### spotsContainedInCenter
# spots entirely contained in center zone

## if all polys are valid:

## find all spots entirely in center using within()

[ i.within(center) for i in spots ]

plotOne(petal)
addOne(center, col='orange')
[ addOne(i,  a=0.3) for i in spots ]

## none, this is a pretty strict measure and doesn't
## give us much for error in spots that got 
## merged in the image pipeline

nuSpotsContainedInCenter = sum([ i.within(center) for i in spots ])

##### nuSpotsTouchCenter

## spots touching the centerzone:

nuSpotsTouchCenter = sum([ i.intersects(center) for i in spots ])

###### nuSpotsMostlyInCenter 

## spots mostly in the centerzone:

spotsMostlyInCenter = [ i for i in spots if (i.intersection(center).area / i.area > 0.5) ]

nuSpotsMostlyInCenter = len(spotsMostlyInCenter)

plotOne(petal)
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i) for i in spotsMostlyInCenter ]
addOne(center, col='orange', a=0.3)

## looks okay.

#### nuSpotCentroidsInCenter

spotCentroidsInCenter = [ i for i in spots if (i.centroid.intersects(center)) ] 

nuSpotCentroidsInCenter = sum([ i.centroid.intersects(center) for i in spots ] )

plotOne(petal)
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i) for i in spotCentroidsInCenter ]
addOne(center, col='orange', a=0.3)
ax1 = plt.gca()
[ ax1.plot(i.centroid.x, i.centroid.y, "+", ms = 10) for i in spotCentroidsInCenter ]

## looks okay. 

#### avgDist2CenterAllSpots

## we'll use centroids of spots, dist to petal centroid:

[ i.centroid.distance(center.centroid) for i in spots ]

avgDist2CenterAllSpots = mean([ i.centroid.distance(center.centroid) for i in spots ])


#### avgDist2CenterCenterSpots

spotsMostlyInCenter = [ i for i in spots if (i.intersection(center).area / i.area > 0.5) ]

avgDist2CenterCenterSpots = mean([ i.centroid.distance(center.centroid) for i in spotsMostlyInCenter ])

avgDist2CenterCenterSpots

#### centerCoveredbySpots 

partSpotsInCenter = [ i.intersection(center) for i in spots if i.intersects(center) ]
## okay, but in case this divides up a spot and creates a multipolygon:
## make a list of lists, even of single polygons
listz = [ list(i) if type(i) == sg.multipolygon.MultiPolygon else [i] for i in partSpotsInCenter ]
unNest = sum(listz, []) ## seems to work... not sure why...
## bring it back
partSpotsInCenter =  sg.multipolygon.MultiPolygon(unNest)

partSpotsInCenterArea = partSpotsInCenter.area

## and the money stat
centerCoveredbySpots = partSpotsInCenterArea / center.area  ## in this case, 0.26

plotOne(petal)
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i) for i in partSpotsInCenter ]
addOne(center, col='orange', a=0.3)
## looks good...

#### propSpotsInCenter

## the above is how much of our center area is covered by 
## spots.

## but what percentage of our spotted area lies in the 
## center?

partSpotsInCenter 

partSpotsInCenterArea

propSpotsInCenter = partSpotsInCenterArea / spots.area  

## seems to work.

#### spotOnCentroid

## is there a spot on the centroid of the petal? just true/false:

spotOnCentroid = any([ i.intersects(petal.centroid) for i in spots ])


############# throat ############

#### propSpotsInThroat

partSpotsInThroat = [ i.intersection(throat) for i in spots if i.intersects(throat) ]
## okay, but in case this divides up a spot and creates a multipolygon:
## make a list of lists, even of single polygons
listz = [ list(i) if type(i) == sg.multipolygon.MultiPolygon else [i] for i in partSpotsInThroat ]
unNest = sum(listz, []) ## seems to work... not sure why...
## bring it back
partSpotsInThroat =  sg.multipolygon.MultiPolygon(unNest)

propSpotsInThroat = partSpotsInThroat.area / spots.area  

plotOne(petal)
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i) for i in partSpotsInThroat ]
addOne(throat, col='orange', a=0.3)

#### throatCoveredbySpots

throatCoveredbySpots = partSpotsInThroat.area / throat.area  

throatCoveredbySpots 

#### nuSpotsTouchThroat

spotsTouchThroat = [ i.intersects(throat) for i in spots ]

nuSpotsTouchThroat = sum(spotsTouchThroat)

plotOne(petal)
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i) for i in spots if i.intersects(throat) ]
addOne(throat, col='orange', a=0.3)

#### nuSpotsMostlyInThroat

nuSpotsMostlyInThroat

spotsMostlyInThroat = [ i for i in spots if (i.intersection(throat).area / i.area > 0.5) ]

plotOne(petal)
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i) for i in spotsMostlyInThroat ]
addOne(throat, col='orange', a=0.3)

## looks good. 

#### nuSpotsTouchCut

## how do we find the spots that acutally touch the base of the petal?

spotsOnCut = [ i for i in partSpotsInThroat if i.intersects(petal.exterior) ]

nuSpotsTouchCut = len(spotsOnCut)

plotOne(petal)
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i) for i in partSpotsInThroat ]
[ addOne(i, col='green') for i in spotsOnCut ]
addOne(throat, col='orange', a=0.3)

############# general polygon stats #################

#### biggestSpotArea

## this is probably not gong to be useful till
## we clean up the spot polygons.

## how to find the largest spot...

biggestSpotArea = max([ i.area for i in spots ])

## don't need this but to ID the polygon:

biggestSpot = [ i for i in spots if i.area == bigSpotArea ] 

#### smallestSpotArea

## not sure why to do this, but here we go:

smallestSpotArea = min([ i.area for i in spots ])

### avgSpotSize
avgSpotSize = mean([ i.area for i in spots ])

avgSpotSize

### medSpotSize
medSpotSize = np.median([ i.area for i in spots ])

medSpotSize

[ i.area for i in spots ]

#### nuSpots

nuSpots = len([ i.area for i in spots ])


################## quadrants ####################

## let's run through one quadrant. We should be able
## to get a nice function for this:

###### quad I ######

#### nuQuadISpots 
## in quad I, centroids need to be positive both X and y:

[ i for i in spots if i.centroid.x > 0 and i.centroid.y > 0 ]
quadIspots = [ i for i in spots if i.centroid.x > 0 and i.centroid.y > 0 ]
nuQuadISpots = len(quadIspots)

#### quadICoveredbySpots & propSpotsInQuadI

## make a box for quadI: 
quadIbox=sg.box(0,0,1,1)
## get the area of our petal in this box:
petalQuadI = petal.intersection(quadIbox)
## get the area of spots that fall into this 
spottedSurfaceQuadI = spots.intersection(petalQuadI)
quadICoveredbySpots = spottedSurfaceQuadI.area / petalQuadI.area
propSpotsInQuadI = spottedSurfaceQuadI.area / spots.area


###### Quad II ###### 

#### nuQuadIISpots 
## in quad II, centroids need to be positive on y-axis and neg on x-axis

[ i for i in spots if i.centroid.x > 0 and i.centroid.y > 0 ]
quadIIspots = [ i for i in spots if i.centroid.x < 0 and i.centroid.y > 0 ]
nuQuadIISpots = len(quadIIspots)

#### quadIICoveredbySpots & propSpotsInQuadII
## spotted surface in quadII / total area of spots 

## make a box for quadII: 
quadIIbox=sg.box(0,0,-1,1)
## get the area of our petal in this box:
petalQuadII = petal.intersection(quadIIbox)
## get the area of spots that fall into this 
spottedSurfaceQuadII = spots.intersection(petalQuadII)
quadIICoveredbySpots = spottedSurfaceQuadII.area / petalQuadII.area
propSpotsInQuadII = spottedSurfaceQuadII.area / spots.area


####### quad III  ######
#### nuQuadIIISpots 

## in quad III, centroids need to be neg both X and y:
[ i for i in spots if i.centroid.x < 0 and i.centroid.y < 0 ]
quadIIIspots = [ i for i in spots if i.centroid.x < 0 and i.centroid.y < 0 ]
nuQuadIIISpots = len(quadIIIspots)

#### quadIIICoveredbySpots & propSpotsInQuadIII
## spotted surface in quadIII / total area of spots 

## make a box for quadIII: 
quadIIIbox=sg.box(-1,-1,0,0)
## get the area of our petal in this box:
petalQuadIII = petal.intersection(quadIIIbox)
## get the area of spots that fall into this 
spottedSurfaceQuadIII = spots.intersection(petalQuadIII)
quadIIICoveredbySpots = spottedSurfaceQuadIII.area / petalQuadIII.area
propSpotsInQuadIII = spottedSurfaceQuadIII.area / spots.area


###### QuadIV #######
#### nuQuadIVSpots 
## in quad IV, centroids need to be neg on y-axis and pos on x-axis

[ i for i in spots if i.centroid.x > 0 and i.centroid.y < 0 ]

quadIVspots = [ i for i in spots if i.centroid.x > 0 and i.centroid.y < 0 ]
nuQuadIVSpots = len(quadIVspots)

#### quadIVCoveredbySpots & propSpotsInQuadIV
## spotted surface in quadIV / total area of spots 

## make a box for quadIV: 
quadIVbox=sg.box(0,-1,1,0)
## get the area of our petal in this box:
petalQuadIV = petal.intersection(quadIVbox)
## get the area of spots that fall into this 
spottedSurfaceQuadIV = spots.intersection(petalQuadIV)
quadIVCoveredbySpots = spottedSurfaceQuadIV.area / petalQuadIV.area
propSpotsInQuadIV = spottedSurfaceQuadIV.area / spots.area

## good plotting sequence to see the spots in a quad
plotOne(petal)
addOne(quadIVbox, a=0.3, col='white')
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i, col='red') for i in spottedSurfaceQuadIV ]


###### Proximal half #####

## should be additive, right?:
## proximal should be one and two:

## make a box 
proxBox=sg.box(-1,0,1,1)
## get the area of our petal in this box:
petalProx = petal.intersection(proxBox)
## get the area of spots that fall into this 
spottedSurfaceProx = spots.intersection(petalProx)
proxCoveredbySpots = spottedSurfaceProx.area / petalProx.area
propSpotsInProx = spottedSurfaceProx.area / spots.area



plotOne(petal)
addOne(proxBox, a=0.3, col='white')
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i, col='red') for i in spottedSurfaceProx ]

###### Distal half #####

## make a box 
distBox=sg.box(-1,-1,1,0)
## get the area of our petal in this box:
petalDist = petal.intersection(distBox)
## get the area of spots that fall into this 
spottedSurfaceDist = spots.intersection(petalDist)
distCoveredbySpots = spottedSurfaceDist.area / petalDist.area
propSpotsInDist = spottedSurfaceDist.area / spots.area

petalProx.area + petalDist.area
propSpotsInDist + propSpotsInProx ## works.

plotOne(petal)
addOne(distBox, a=0.3, col='white')
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i, col='red') for i in spottedSurfaceDist ]



## can we make a single row dataframe?

## seems like maybe a dictionary is the way to make a row. 

## we have ~46 traits? oh jeez...





## module

## 0) import stuff

## 1) function for each value, also function for
## cleaning up polys

## 2) create a class. Attributes will be made with 
## the above functions

## 3) script to deal with all files using these tools

from shapely.validation import explain_validity

FlowerPetal.py
#################################################
#!/user/bin/env python3

import os, json, pickle
import numpy as np
import shapely.geometry as sg
import shapely.ops as so
import matplotlib.pyplot as plt
import pandas as pd
from descartes import PolygonPatch
from statistics import mean
from FlowerPetal import FlowerPetal


## in bash, set up a nice directory to build the data frame:


for i in $(find /home/daniel/Documents/mimulusSpeckling/make_polygons/polygons/ -type f -name "*geojson");do
echo $i
cp $i /home/daniel/Documents/mimulusSpeckling/polygon_traits/geojs/
done

## now make our module so it can act on a directory and spit out a dataframe


## class is getting huge. Let's load it here.

## make flowers:
os.chdir(args.geojFolder)

os.chdir('/home/daniel/Documents/mimulusSpeckling/polygon_traits/geojs')

flowers = os.listdir()
flowers.sort()
flowerList = []

for i,flower in enumerate(flowers):
    fl = FlowerPetal()
    fl.flowerName = flower.split(sep='_')[0]
    fl.petalName = flower.split(sep='_')[1]
    fl.geojson = flower
    fl.parseGeoJson(flower)
    fl.cleanFlowerPetal()
    fl.fillColumns()
    row = vars(fl)
    flowerList.append(row)

aa = pd.DataFrame(flowerList)


aa.columns.values

aa.columns.values[0]

## we want to get rid of the geometries...

del aa['petal']
del aa['spots']
del aa['center']
del aa['edge']
del aa['throat']

## and reorder the columns:


bb = aa.reindex_axis(sorted(aa.columns), axis=1)
cc = aa.set_index('petalName').reset_index()
dd = cc.set_index('flowerName').reset_index()

aa.iloc[0:2,0:3]

bb.iloc[0:2,0:3]
cc.iloc[0:2,0:3]
dd.iloc[0:2,0:3]


aa = aa.set_index('petalName').reset_index()
aa = aa.set_index('flowerName').reset_index()

aa.to_csv("testFlowerPetal.csv")

pickle.dump(aa, open("testFlowerPetal.p", "wb"))

aa = pickle.load(open("testFlowerPetal.p", "rb"))


######### 

## wrangle the data a little so Melia can play with it:

import os, json, pickle
import numpy as np
import shapely.geometry as sg
import shapely.ops as so
import matplotlib.pyplot as plt
import pandas as pd
from descartes import PolygonPatch
from statistics import mean
from FlowerPetal import FlowerPetal

aa = pickle.load(open("testFlowerPetal.p", "rb"))


## she wants each upper petal set averaged for all values

## and all plants combined (average)

## then she wants 

