## let's try our vim script out

## symlink where gimp can find it:

ls /Users/danthomas/Documents/speckling/center/scriptfu/make_spot_polygons.scm 

ln -s /Users/danthomas/Documents/speckling/center/scriptfu/make_spot_polygons.scm "/Users/danthomas/Library/Application Support/GIMP/2.8/scripts/make_spot_polygons.scm" 

$gimp -i --verbose -b '(make_spot_polygons "/Users/danthomas/Documents/speckling/demo/test_spots3.png" "mooptest")' -b '(gimp-quit 0)'

## new install not working, missing "gdb". What is this? 

brew search gdb

brew info gdb

## then had to do a bunch of certificate stuff, info here: <https://sourceware.org/gdb/wiki/BuildingOnDarwin>

## to find out where gdb lives:

type -a gdb ## its in /usr/local/bin

## but 

ls -l /usr/local/bin/gdb

## its a soft link to our homebrew cellar:

ls -l /usr/local/Cellar/gdb/8.1/bin/gdb

## not writable. I want to keep it that way. So mac wants sudo or gui password input

codesign -s gdb-cert /usr/local/Cellar/gdb/8.1/bin/gdb

## okay, did this help?

$gimp -i --verbose -b '(make_spot_polygons "/Users/danthomas/Documents/speckling/demo/test_spots3.png" "mooptest")' -b '(gimp-quit 0)'

## and then a mountain of errors from gdb, about shared library incompatibilites. 

## meh. fuck all that. The command line will not work for my setup. It's not worth the time
## to now debug gdb for my setup. Too deep for me. 

## let's try just using the console while gimp is running. Then maybe we can make a macro 
## instead of a script. 

## example file: "/Users/danthomas/Documents/speckling/demo/test_spots3.png"

    (let* (
            ;; load files, set vars
            (image (car (gimp-file-load 
                                0 
                                "/Users/danthomas/Documents/speckling/demo/test_spots3.png" 
                                "/Users/danthomas/Documents/speckling/demo/test_spots3.png") ) )
            (drawable (car (gimp-image-get-active-layer image)))
          )
            ;; do stuff
            ;;1 select black/solid regions:
            (gimp-image-select-color 
                image
                CHANNEL-OP-REPLACE
                drawable
                '(0 0 0) ;; black
            ) ;'
            ;;2 Convert selection to path
            (plug-in-sel2path
                RUN-NONINTERACTIVE
                image
                drawable
            ) 
            ;;3 save path to file
        (gimp-vectors-export-to-file
            image
            "/Users/danthomas/Documents/speckling/make_polygons/spots_script_test.svg"
            0 ;; all vectors
        )
)

## so that works for copying and pasting to the console in GIMP.

## we need to either write a macro for running in the GUI that can handle lots of images or 
## try again with the command line. 


## I personally like the idea of the latter. But I still have no idea 
## how to run gimp command line from the terminal

## can we run the above from the terminal?


## we need to put a copy (symlink) where git wants it:

ln -s /Users/danthomas/Documents/speckling/make_polygons/make_spot_polygons.scm \
"/Users/danthomas/Library/Application Support/GIMP/2.10/scripts/make_spot_polygons.scm"

ls -l "/Users/danthomas/Library/Application Support/GIMP/2.10/scripts/"


ls /Applications/Gimp-2.10.app/Contents/MacOS/gimp-console-2.10

/Applications/Gimp-2.10.app/Contents/MacOS/gimp-console-2.10

## theoretically, we should be able to run this like so:
~/GIMP.app/Contents/MacOS/gimp-2.8 -i

## none of the above works. As before. I think the best strategy here is to try this on my
## linux machine, see if the same bugs pop up. 
cd /home/daniel/mimulusSpeckling/make_polygons


## all the above was for the lab mac. 

## try again with my linux laptop

## where to put gimp scripts on my laptop?

## here I think:
cd ~/.gimp-2.8/scripts

ls -al ~/.gimp-2.8/scripts

ln -s /home/daniel/mimulusSpeckling/make_polygons/make_spot_polygons.scm ~/.gimp-2.8/scripts/make_spot_polygons.scm 

## can we run it?


gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## let's do a test with a script from online:

gimp -i -b '(test-script "foo.png" 5.0 0.5 0)' -b '(gimp-quit 0)'

## okay works...why not ours?

## why is the the script name parsed as an undeclared variable?

cd ../demo
gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'
## nope

## is it because it is a symlink?

cp /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm /home/daniel/.gimp-2.8/scripts/

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## ah, that worked!
## is this a permission issue?

chmod 777 /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm

## try again

ln -s /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm ~/.gimp-2.8/scripts/makePetalPoly.scm 

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## yep. I feel pretty stupid. But good to know that symlink permissions 
## don't really mean anything

## sweet, so:

## 1 edit script to export other filenames that are related to the entered file
## 2 find a way to handle multiple files - either with bash or in scriptfu

## 1 should be simple?

## okay, works. 

#######################################

## back up. We need to use Doug's structures to generate binary pngs 
## that gimp will like. 

## since matlab sucks, as in not-free and license issues are complex
## even when paid for, we'll try octave here

## I'm waiting on the math department to talk to me about the desktop
## license at the lab.`

octave-cli

## get one of Doug's data structures:

load("/home/daniel/Documents/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P431F1.mat")

Petals

fieldnames(Petals)

Petals.left

fieldnames(Petals.left)

Petals.left.data

## can we turn this into an image?

fieldnames(Petals.right)

fieldnames(Petals.Clusters)

Petals.Clusters.left

imshow(Petals.Clusters.left) %% doesn't work

image(Petals.Clusters.left) %% works. Don't know why

image(Petals.Clusters.right); colorbar

%% get the image package 
pkg load image

aa = mat2gray(Petals.Clusters.right);

imshow(aa) %% that works. 

unique(aa) %% all values transformed to between 1 and 0. 
%% 1 is white, 0 is black

%% now we want a petal and a spot image. To do this:

%% get the spot shapes as black, background as white:
bb = aa < 1;
imshow(bb); 

%% petals black with white background
cc = aa == 0;
imshow(cc); 

%% okay. These should be digestable for our GIMP scripts. 

%% export:

imwrite(bb, 'P431F1_bottom_spots.png') %% some quality warnings. 
imwrite(cc, 'P431F1_bottom_petal.png')

%% can we get these to gimp now, and get svgs for both?

## shell/gimp

## ugh, got to remember how to use Gimp from command line 
## with our script...

## we have our scriptfu for this, does this work?:

gimp -i -b '(makePetalPoly "P431F1_bottom_spots.png")' -b '(gimp-quit 0)'

## nope.  What changed? the old command that worked:

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## doesn't work now... did I change something accidentally?

git log makePetalPoly.scm


## not really. The file worked on the last day it was modified.

## can we bring up the older versions, see if they work?

git checkout 759701d0688c1c08e76ca876dc25d08e122b09c4 makePetalPoly.scm

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## nope. What changed?

## looks like the link might be dead...

ln -s /home/daniel/Documents/mimulusSpeckling/make_polygons/makePetalPoly.scm /home/daniel/.gimp-2.8/scripts/makePetalPoly.scm

## work now?

gimp -i -b '(makePetalPoly "P431F1_bottom_spots.png")' -b '(gimp-quit 0)'

## yup, works. Note to self, watch those directory changes...remember they fuck with links 

## now can we flatten the svg bezier curves?

## ugh, all this would be so much more elegant with python. 
## http://scikit-image.org/docs/dev/api/skimage.draw.html

## anyway..

## so with svg bezier curves, we want to be rid of the control points 
## leave just the terminal points

## first get the svg to work,
## then figure out how to clean it all out so matlab can read it.

cp P431F1_bottom_spots.png_path.svg test.svg

## for svg, to flatten the beziers,
## change all C's to L's
## and get rid of the control points (keep only the first set of coordinates)

sed '/^\s*C/ s/C\s/L /' test.svg | \
sed -e 's/\([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\) \([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\) \([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\)/\1/g' > test2.svg

## okay, that seems to work...but the paths have been clipped somehow, which leaves 
## unclosed polygons. This must have happened during the gimp export?

## nope, the svg with the beziers is not broken, at least according to inkscape.
## so we introduced this with our SED modification

tail test.svg

tail test2.svg

## actually, it's ok. The svg lines do close up in both files, you just have to
## expand the svg canvas to see a little. 

## ok, relief. So...what do we need for matlab to understand that these are 
## polygons?

## gimp needs two vectors, x and y. 

## how can we convert our svg to this? 

## a couple of problems here.

## 1) get rid of chaff - remove all the non-drawing directions
## 2) break up the respective polygons
## 3) convert each polygon to two vectors, x and y. 

## this really needs some python. Sorry Doug. 

## which probably means we should back up and use a 
## single python script to fix our svgs in general
## (so I just spent an hour on a SED regex I don't need).
## good news is that the script should be fairly straight forward.

## actually, why use svgs at all? If we're going to 
## python, let's do it right and get our edge detection
## done with that

## hah. into the best rabbit hole I know...


########################################################

import numpy as np
op')

import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

## bring in our petal image:

bb = io.imread('P431F1_bottom_spots.png')
io.imshow(bb)
io.show()

cc = io.imread('P431F1_bottom_petal.png')
io.imshow(cc)
io.show()

edges = filters.sobel(bb)
io.imshow(edges)
io.show()

## okay, can we turn this into a polygon?

## meaning, can it be approximated into a 
## series of vertices? 

## what value are we chasing?

np.unique(edges)

## huh. 7 non-zero values...

contours = measure.find_contours(edges, 0.5)

type(contours)

contours[0].shape

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)


## almost works, but we're losing information by the png 
## conversion, methinks.

## so... back to octave/matlab:

####################################################

octave-cli

pkg load image

## get one grayscale image:

load("../dougRaster/Rotated_and_Cropped/P431F1.mat")
aa = mat2gray(Petals.Clusters.right);

Petals.Clusters.right

spots = aa < 1;
imshow(spots);

petal = aa == 0;
imshow(petal);

## save them as csv's:

csvwrite('P431F1petal.csv',petal)
csvwrite('P431F1spots.csv',spots)

%% and back to python...
#########################

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

petal = np.genfromtxt ('P431F1petal.csv', delimiter=",")
spots = np.genfromtxt ('P431F1spots.csv', delimiter=",")

np.unique(petal)

np.unique(spots)

## try spots

## can contours handle these directly?
contours = measure.find_contours(spots, 0)
for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.show()

## not bad, but still gaps...

contours = measure.find_contours(spots, 0)
for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

## same. Try finding the edges first:


edges = filters.sobel(spots)

io.imshow(edges)
io.show()

np.unique(edges)

contours = measure.find_contours(edges, 0.5)

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.show()

## same problem. can we add a margin of white to our 
## matrix?

## jog my memory, how to work with numpy again...

a = np.array([[1, 1], [2, 2], [3, 3]])

a
a = np.insert(a, 0, 5, 1)
a

a = np.array([[1, 1], [2, 2], [3, 3]])
np.insert(a, 0, 5, 0)

## rows are axis zero, columns axis one

a = np.array([[1, 1], [2, 2], [3, 3]])

a.shape
np.insert(a, 0, [6,6,6], 1)
np.insert(a, 2, [6,6,6], 1)

a = np.array([[1, 1], [2, 2], [3, 3]])
b = np.insert(a, 2, [6,6,6], 1) ## might be a more elegant way...

## can we add more than one column at a time?

a = np.array([[1, 1], [2, 2], [3, 3]])
b = np.insert(a, 2, [[5,5,5],[6,6,6]], 1)

## works, but probably better to build another matrix 
## and concatenate it 

## for our images, our polygons are black, = 0's

## so we want to add white space, or 1's. 

## seems pretty simple. try it with one of our images:


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

petal = np.genfromtxt ('P431F1petal.csv', delimiter=",")
spots = np.genfromtxt ('P431F1spots.csv', delimiter=",")

petal.shape
## (561, 439)

spots.shape
## same

## looks like the rows/columns are transposed 
## automatically by the scikit-image?

## to add one pixel of white to columns:
spots_marg = np.insert(spots, 439, 1, 1) 
spots_marg = np.insert(spots_marg, 0, 1, 1) 
## and rows:
spots_marg = np.insert(spots_marg, 561, 1, 0) 
spots_marg = np.insert(spots_marg, 0, 1, 0) 

spots.shape
spots_marg.shape


## does this help the detection of the polygons?

contours = measure.find_contours(spots_marg, 0)

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)


plt.show()


## to keep the relative positions accurate, we have to do the
## the same with the petal outline:

petal_marg = np.insert(petal, 439, 1, 1) 
petal_marg = np.insert(petal_marg, 0, 1, 1) 
## and rows:
petal_marg = np.insert(petal_marg, 561, 1, 0) 
petal_marg = np.insert(petal_marg, 0, 1, 0) 

Pcontours = measure.find_contours(petal_marg, 0)

## how does it look?:

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.plot(Pcontours[0][:,1], Pcontours[0][:,0], linewidth=1)

plt.show()

## looks good. 

## 1) Can we give these to Matlab?

## and if so, 

## 2) we need a script to generalize this. 

## 3) and a bash script that will work for anyone to repeat. 

## update notebook, then do these things. 

## okay, can we export one of these so that octave can read it?

## CSV is a little problematic, because we need a new for each 
## polygon.

## but building a json of nested arrays that python will make and 
## matlab will parse, sounds more tricky than I want to take on. 

np.savetxt("P431F1petal_polys.csv", contours) ## doesn't work

contours[0]

contours[0].astype(int)

## loop through the various polygons, save them individually?

photoname = 'P431F1'
partname  = 'spots'
petalname = 'bottom'

for n, contour in enumerate(contours):
    polyname = photoname + petalname + partname + str(n) + "_poly.csv"
    print(polyname)
    np.savetxt(fname=polyname, X=contour.astype(int), delimiter=',') 

## looks good. 

## so now the challenge is, given a single image, make a function 
## that exports the petal outline and all the respective 

## we start with..? a csv from matlab, which is the grayscale matrix
## of a single petal image:

## remember that as we have it here, we get a petal and a spots
## csv from matlab/octave. 

## but it is the same process for both. Make this agnostic: 


## get_pols.py
#################################3
#!/usr/bin/env python3

import argparse
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

## instantiate the argparser
parser = argparse.ArgumentParser()

## argument:
parser.add_argument('file', 
            help="Name of the .csv file from matlab that contains grayscale information about a petal.")

args = parser.parse_args()

## get our image in...
aa  = np.genfromtxt(args.file, delimiter = ",")

aR = aa.shape[0] ## number of rows
aC = aa.shape[1] ## number of cols

## add one pixel of white to rows:
aa_marg = np.insert(aa, aR, 1, 0)
aa_marg = np.insert(aa_marg, 0, 1, 0)
## and columns:
aa_marg = np.insert(aa_marg, aC, 1, 1)
aa_marg = np.insert(aa_marg, 0, 1, 1)

## find the contours:
contours = measure.find_contours(aa_marg, 0)

## save them out:

imageName = args.file[:-4] ## no file extension

for n, contour in enumerate(contours):
    polyname = imageName + "_poly" + str(n) + ".csv"
    np.savetxt(fname=polyname, X=contour.astype(int), delimiter=',')

#####################################

## try this out on one of our CSvs from matlab:

./get_pols.py P431F1spots.csv

## seems to work, but we'll need to check this
## out on matlab tomorrow. 

## how can we make this cleaner? We want to output
## to a folder...

## update notebook, fix tomorrow. 

###############################

## its tomorrow, again. 

## okay, so we need to make our script export all products into 
## a single folder. 

## let's work in the file itself...

./get_pols.py P431F1spots.csv

## 13 of them. is this the same as before?

## looks okay, I think. 

## works for our petal outline? 

./get_pols.py P431F1petal.csv

## works ok on the mac, looks like.

## switch over to matlab for a minute, can we plot our polygons 
## from this and do they look ok?

## if so, focus on getting all of doug's rasters into shape for 
## this script, 

## then run script on all of them. 

## want to run the matlab interpreter without the other junk
## but we gotta find our binaries apparently, doesn't add 
## anything to our path for us on the install...


## I hate matlab.

/Applications/MATLAB_R2018a.app/bin/matlab -nodisplay

## made an alias. should just work with:

matlab

%% now in matlab...

%% what do we want to do again?

wkd = '/Users/danthomas/Documents/speckling/make_polygons/';
%cd /Users/danthomas/Documents/speckling/make_polygons;
cd(wkd);
%name='P431F1petal';
name='P431F1spots';
cd(name);

%% empty vector to fill?

aa = []
counter=1
for i = 2:6;
    aa(counter) = i;
    counter = counter + 1;
end;


%% we need add these as cell arrays to
%% a single iterable structure..
%% so to read in these polygons:

aa = struct
counter = 1;
files = dir('*.csv');
for file = files';
    coords = csvread(file.name);
    aa(counter).coords=coords;
    counter = counter + 1;
end;

%% now to convert to polygons:

counter=1;
for i = aa';
    aa(counter).p = polyshape(aa(counter).coords);
    counter=counter+1;
end;
%% doesn't work, fails and doesn't retry
%% big ol fashioned ugly ifs and fors

counter=1;
for i = aa;
    disp(counter)
%    if length(aa(counter).coords) > 1;
        disp(i)
%    end;
    counter=counter+1;
end;


counter=1;
for i = aa;
disp(i)
end;

for i = 1:length(aa);
    size(aa(i).coords)
end

%% huh. all of the the three point ones aren't viable polygons

%% do we need them? We can increase the sensitivity of our polygon detection,
%% I'd imagine...

%% for the moment we plot them as lines?


%% I'm lost. What am I trying to do? 

%% trying to plot all the spots on a petal. Some of them are too thin to plot as polygons 
%% in matlab. 

%% I may have mentioned I fucking hate matlab. 

%% anyway, not matlab's fault. These are not polygons, they are lines. 

%% back up reset our structure:

aa = struct
counter = 1;
files = dir('*.csv');
for file = files';
    coords = csvread(file.name);
    aa(counter).coords=coords;
    counter = counter + 1;
end;

%% add polyshape if we can:

counter=1;
for i = aa;
    if length(i.coords(:,1)) > 3;
        aa(counter).p = polyshape(i.coords)
    end;
    counter=counter+1;
end;

%% can we plot this?

counter=1;
for i = aa;
    if ~isempty(i.p)
        plot(i.p)
        hold on
    end;
    counter=counter+1;
end;

%% add our petal outline:

Pcoords = csvread("/Users/danthomas/Documents/speckling/make_polygons/P431F1petal/P431F1petal_poly0.csv")
Ppoly = polyshape(Pcoords)
plot(Ppoly)


## lotsa work to do on this, but I think we're moving in the right direction...

##################

## okay, so back up. We need matlab to export the original petal and spots csv in a single folder, 
## so that our skimmage script can rip through them all at once. 

## and we need our skimmage script to handle a folder at a time. 

## then we need a matlab script to 


## looks like we probably need to learn about running matlab scripts from 
## the command line? 

## ugh, nah. Let's not. Others can do this if they want. 

## so first, let's get matlab to export petals and spots in two 
## matrices, in a folder:

%% separatePetPol.m
#############################

%% the goal here is grab all available petal images 
%% that have been through doug's raster transformations.
%% We make grayscle (0-1) matrices of his matrices, 
%% then "peel" them apart into spots and petal backgrounds.
%% these are then passed onto a python script for digitizing
%% the polygons.

%% first let's run through one image again
%% to output both matrices to a single, new folder:

%% following that, make it so all three petals are 
%% produced in their own folders, all within a 
%% single folder for each image

%% following that, make it so we can cycle through
%% all of our processed images

%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% go to working directory
wd = '/Users/danthomas/Documents/speckling/make_polygons/polygons/';
cd(wd);

dougRasterDir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

im = "P431F1.mat";
imName = regexprep(im,'\.mat', ''); 

%% go get our file, come back
cd(dougRasterDir);
rast=load(im);
cd(wd);

%% make a spot for our image, go to it:
mkdir(imName);
cd (imName);

%% get our petal names (left, right mid)
petNames = fieldnames(rast.Petals.Clusters);

%% split images into petal and spot, export, for each of the three petals:

for i = 1:length(petNames);
    pet = rast.Petals.Clusters.(petNames{i}); %petal at hand
    rastGray = mat2gray(pet); 
    spots = rastGray  < 1; 
    petal = rastGray == 0;
    mkdir(petNames{i});
    cd(petNames{i});
    fileNamePetal = imName + "_" +  petNames(i) + "_" + 'petal.csv';
    csvwrite(fileNamePetal,petal);
    fileNameSpots = imName + "_" +  petNames(i) + "_" + 'spots.csv';
    csvwrite(fileNameSpots,spots);
    cd ..;
end;

cd(wd);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%% generalize to catch all of dougs rasters

%%%%%%%%%%%%%%%%%%%%%%%%%%

%% a script to put all of Doug's rasters into a form we can use:

%% go to working directory
wd = '/Users/danthomas/Documents/speckling/make_polygons/polygons/';
cd(wd);

dougRasterDir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

cd(dougRasterDir)

files = dir('P*.mat');
for file = files';
    im = file.name;
    imName = regexprep(im,'\.mat', ''); 
    %% go get our file, come back
    cd(dougRasterDir);
    rast=load(im);
    cd(wd);
    %% make a spot for our image, go to it:
    mkdir(imName);
    cd (imName);
    %% get our petal names (left, right mid)
    petNames = fieldnames(rast.Petals.Clusters);
    %% split images into petal and spot, export, for each of the three petals:
    for i = 1:length(petNames);
        pet = rast.Petals.Clusters.(petNames{i}); %petal at hand
        rastGray = mat2gray(pet); 
        spots = rastGray  < 1; 
        petal = rastGray == 0;
        mkdir(petNames{i});
        cd(petNames{i});
        fileNamePetal = imName + "_" +  petNames(i) + "_" + 'petal.csv';
        csvwrite(fileNamePetal,petal);
        fileNameSpots = imName + "_" +  petNames(i) + "_" + 'spots.csv';
        csvwrite(fileNameSpots,spots);
        cd ..;
    end;
    cd(wd);
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

## think that worked...

## how do we check?

## back to python...

python

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

## some rando files to compare:

aa = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P247F1/right/P247F1_right_spots.csv'
bb = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P399F1/right/P399F1_right_spots.csv'
cc = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P399F1/left/P399F1_left_spots.csv'
dd = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P393F2/mid/P393F2_mid_spots.csv'
ee = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P257F2/left/P257F2_left_petal.csv'

## look at em

image = ee
sv = np.genfromtxt (image, delimiter=",")
contours = measure.find_contours(sv, 0)
for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.show()

## add a petal for cc
image = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P399F1/left/P399F1_left_petal.csv'
svp = np.genfromtxt (image, delimiter=",")
contoursp = measure.find_contours(svp, 0)
for n, contourp in enumerate(contoursp):
    plt.plot(contourp[:, 1], contourp[:, 0], linewidth=2)

## all looks good. 

## move on, digitize with python script... 

## okay, this script goes to home of each file, and builds directories right there, in place.

## so this will go to each of our blacknwhite matrices and build another folder in place with 
## a bunch of polygons 

## is this going to be hard to work with later?

## Probably. First let's just see if it works.

## How do we apply it all of our files? They are all buried in the nested folders...

## seems like a good use of find:

find ./ -name "P*csv" -type f  | wc -l
## hehzus, there 1080 of these. Is that right? 
## = 180 photos x 6, yup.

## sicking our script on these could be catastrophic... getting github uptodate...


find ../polygons/ -name "P*csv" -type f  -exec ./get_pols.py {} \;

## no errors reporting .. how do we check if we did a good job? 

## be sure to update get_pol.py  script on notebook when next we go there..

## let's let that run tonight...

## maybe we can do the commit/push remotely...

#######################################

##  update notebook


## branch

## then check these with matlab, and meld with doug's matlab structures

## how to do this, in matlab?...

## for each image:

%% 1) load doug matlab structure of image
%% 2) load all associated polygons and petal outlines csvs as matlab polyshapes 
%% 3) add these to doug's matlab stuctures



%% try just one:

wd = '/Users/danthomas/Documents/speckling/make_polygons/'
cd(wd)

dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

im = "P369F1";
pos='mid';
%typPol='spots';
typPol='petal';
imStructF = dougdir + im + ".mat";



%% how do we get a list of matlab structures of interest (images as structures)?

cd(dougdir)
files = dir('P*.mat');
for file = files';
    im = regexprep(file.name,'\.mat', ''); 
    disp(file.name + " " + im)
end;
%% works

load(imStructF)

wd + "tryscript/" + im + '_' + pos + '_' + typPol

%%"mid" (actually "right") petal:

aa = mat2gray(Petals.Clusters.mid);
imshow(aa)

%% there's a hole in this spot, I wonder how our python script
%% dealt with that. We'll see in a minute...

%% what are our accompanying python-defined csv?

%% two directories we need are:

"tryScript/P369F1_mid_petal"
"tryScript/P369F1_mid_spots"

%% could be restated as:

wd + "tryscript/" + im + '_' + pos + '_' + typPol

ls(wd + "tryscript/" + im + '_' + pos + '_' + typPol) %% seems to work

%% seems like it would be simplest to construct a structure that contains
%% all of our spot and petal polygons, then add this to the existing 
%% doug matlab structure for that image. 

%% 1) get image name from list of mat files in dougdir
%% 2) load and convert all the pertinent csvs to polyshapes
%% 3) save together in a structure
%% 4) add this to dougs existing structure

%% for 2, how do we find all the pertinent files?

%% im is scrounged off the file name, then...

dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";
wd = '/Users/danthomas/Documents/speckling/make_polygons/'
petNames = ["left", "mid", "right"];
typPols = ["petal", "spots"];

im = "P369F1";

cd(wd)
Polys = struct;
for i = petNames;
    for j = typPols;
        imdir = "tryScript/" + im + "_" + i + "_" + j;
        cd(imdir);
        files = dir('P*.csv');
        counter = 1;
        for file = files';
            disp(file.name)
            disp(counter)
            coords=csvread(file.name);
            if length(coords(:,1)) > 3; %% if there are enough points
                Polys.(i).(j)(counter) = polyshape(coords); %% convert to polyshape
                counter=counter+1;
            end;
        end;
    cd(wd)
    end;
end;

%% that seems to work. how would we add it?

%% one of Doug's structures looks like:


load ('/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P431F2.mat')

aa = load ('/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P431F2.mat')

save

bb = 'loop';
cc = 'poop';

save('test.mat', 'bb', 'cc')

clear(bb, cc)

load('test.mat')

%% just load the mat file of interest, and add the above as a field.

im = "P369F1";
aa = load(dougdir + im + ".mat");

%% add our polyshapes to it:

aa.Petals

aa.Petals.polys = Polys;

aa.Petals.polys

%% then save it back out. Does our naming the structure accidentally add a layer to our structure?
save("aatest.mat", "aa")
clear(aa)
load("aatest.mat")
%% yup. 

%% seems like maybe we just deal with files one at time here.

load(dougdir + im + ".mat");
Petals.Polys = Polys;
save(imFile,"Petals")


%% where shall we save these?


imFile = wd + "matObjW_pol/" + im + ".mat";

save(imFile,"Petals")

clear Petals

load(imFile)

%% works. Can we loop it?


dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";
wd = '/Users/danthomas/Documents/speckling/make_polygons/';
petNames = ["left", "mid", "right"];
typPols = ["petal", "spots"];

cd(dougdir)
hs = dir('P*.mat');
for h = hs';
    im = regexprep(h.name,'\.mat', ''); 
    cd(wd)
    Polys = struct;
    for i = petNames;
        for j = typPols;
            imdir = "tryScript/" + im + "_" + i + "_" + j;
            cd(imdir);
            files = dir('P*.csv');
            counter = 1;
            for file = files';
                disp(file.name)
                disp(counter)
                coords=csvread(file.name);
                if length(coords(:,1)) > 3; %% if there are enough points
                    Polys.(i).(j)(counter) = polyshape(coords); %% convert to polyshape
                    counter=counter+1;
                end;
            end;
        cd(wd)
        end;
    end;
    load(dougdir + im + ".mat"); %% get doug's matlab structure
    Petals.Polys = Polys; %% add our new Polys structure inside it
    imFile = wd + "matObjW_pol/" + im + ".mat"; %% save the modified structure 
    save(imFile,"Petals");
end;

%% did that work?

%% how to check a few of these?

%% import the 

im = "P369F1";
aa = load(dougdir + im + ".mat");

load("/Users/danthomas/Documents/speckling/make_polygons/matObjW_pol/P440F1.mat")

%% iterate through our petal outline and spots 

for i = Petals.Polys.left.petal
    if ~isempty(i)
        plot(i)
        hold on %% keep the plot open
    end;
end;

for i = Petals.Polys.left.spots
    if ~isempty(i)
        plot(i)
        hold on %% keep the plot open
    end;
end;


%%, but as Arielle mentioned, polygons are getting merged. 

%% let's see how common and how badly. 


%% can we make a function for viewing all three stages of the 
%% process. 

%% to just view the original jpeg?

cd /Users/danthomas/Documents/speckling/make_polygons/matObjW_pol 

files = dir('P*.mat');
counter = 1;
for file = files';
    disp(file.name)
end;


load('P434F1.mat')


dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

dougdir = '/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/';
[a,b,c] = fileparts(Petals.fullName);
jpegName = dougdir + b + c;

aa = imread("/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P434F1.JPG") %% doesn't work

aa = imread('/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P434F1.JPG') %% works...

ls "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P434F1.JPG"

ls '/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P434F1.JPG'



a = 'zzop';
b = "zzop";

class(a) %% single quote, = char
class(b) %% double quote, = string

a(1)
b(1)

%% so double quotes save the entire word as a unite (=string),
%% and single quotes save the word as a string of letters (=letter)

wd="/Users/danthomas/Documents/speckling/make_polygons/matObjW_pol"
cd(wd)

%load('P434F1.mat')

load('P248F2.mat')

dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";
[a,b,c] = fileparts(Petals.fullName);
jpegName = char(dougdir + b + c); %% gotta be a character object
jpegN = imread(jpegName) ;

imshow(jpegN)

[a,b,c] = fileparts(Petals.fullName);
jpegName = char(dougdir + b + c); %% gotta be a character object?
jpegN = imread(jpegName);
    %% plot a page:
    figure;
    %%%%%%%%% first row %%%%%%%%%%%%%%%
    subplot(3,3,[1,3]);
    imshow(jpegN);
    title(b) %% this is our plot title
    %%%%%%%%% second row %%%%%%%%%%%%%
    subplot(3,3,4);
    aa = mat2gray(Petals.Clusters.left);
    imshow(aa) 
    subplot(3,3,5);
    aa = mat2gray(Petals.Clusters.mid);
    imshow(aa) 
    subplot(3,3,6);
    aa = mat2gray(Petals.Clusters.right);
    imshow(aa) 
    %%%%%%%%%% third row %%%%%%%%%%%%%%
    subplot(3,3,7);
        if isfield(Petals.Polys.left,'petal');
        for i = Petals.Polys.left.petal;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        if isfield(Petals.Polys.left,'spots');
        for i = Petals.Polys.left.spots;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        daspect([1 1 1])
    subplot(3,3,8);
        if isfield(Petals.Polys.mid,'petal');
        for i = Petals.Polys.mid.petal;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        if isfield(Petals.Polys.mid,'spots');
        for i = Petals.Polys.mid.spots;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        daspect([1 1 1])
    subplot(3,3,9);
        if isfield(Petals.Polys.right,'petal');
        for i = Petals.Polys.right.petal;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        if isfield(Petals.Polys.right,'spots');
        for i = Petals.Polys.right.spots;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
        daspect([1 1 1])
    %%%%%%%%%%%%%%

%% can we export to pdf?

print("test.pdf",'-dpdf', '-fillpage')

%% works. Can we loop through, make them all?

wd="/Users/danthomas/Documents/speckling/make_polygons/matObjW_pol"  %% right now our structures live here
dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/"; %% but original images here
pdfDir = "/Users/danthomas/Documents/speckling/make_polygons/bigPDF/"; %% we'll put pdfs here
cd(wd)

files = dir('P*.mat');
for file = files';
    %% get things loaded
    load(file.name)
    [a,b,c] = fileparts(Petals.fullName);
    jpegName = char(dougdir + b + c); %% gotta be a character object?
    pdfName = pdfDir + b + ".pdf"; %% doesn't have to be a character object?
    jpegN = imread(jpegName);
        %% plot a page:
        figure;
        %%%%%%%%% first row %%%%%%%%%%%%%%%
        subplot(3,3,[1,3]);
        imshow(jpegN);
        title(b) %% this is our plot title
        %%%%%%%%% second row %%%%%%%%%%%%%
        subplot(3,3,4);
        aa = mat2gray(Petals.Clusters.left);
        imshow(aa) 
        subplot(3,3,5);
        aa = mat2gray(Petals.Clusters.mid);
        imshow(aa) 
        subplot(3,3,6);
        aa = mat2gray(Petals.Clusters.right);
        imshow(aa) 
        %%%%%%%%%% third row %%%%%%%%%%%%%%
        subplot(3,3,7);
            if isfield(Petals.Polys.left,'petal');
            for i = Petals.Polys.left.petal;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            if isfield(Petals.Polys.left,'spots');
            for i = Petals.Polys.left.spots;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            daspect([1 1 1])
        subplot(3,3,8);
            if isfield(Petals.Polys.mid,'petal');
            for i = Petals.Polys.mid.petal;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            if isfield(Petals.Polys.mid,'spots');
            for i = Petals.Polys.mid.spots;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            daspect([1 1 1])
        subplot(3,3,9);
            if isfield(Petals.Polys.right,'petal');
            for i = Petals.Polys.right.petal;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            if isfield(Petals.Polys.right,'spots');
            for i = Petals.Polys.right.spots;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            daspect([1 1 1])
        %%%%%%%%%%%%%%
    %% print as a pdf page
    print(pdfName,'-dpdf', '-fillpage')
    close %% added after running, not sure if this works
end;


%% horribly inefficient, but it worked. 


## to join these, try the built in script that comes with mac OS for this:

/System/Library/Automator/Combine\ PDF\ Pages.action/Contents/Resources/join.py -o PolyPipeline_140818.pdf ./bigPDF/*

## so now what? 

## the polygons are flawed, but it would be nice to have something to show about centering, etc

## what is a good one to look at? Which ones made it through the pipeline without issues?

%% back into matlab

%% P416F1 looks simple and well-digitized:

wd="/Users/danthomas/Documents/speckling/make_polygons/matObjW_pol/"  %% right now our structures live here
dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/"; %% but original images here
pdfDir = "/Users/danthomas/Documents/speckling/make_polygons/bigPDF/"; %% we'll put pdfs here
cd(wd)
file = wd + "P416F1.mat";
load(file);

%% how to mark the centroid of the petal?

pet = Petals.Polys.right.petal(1);
spotz = Petals.Polys.right.spots;
%% put all the spots into an array
allSpots = union(spotz);
%% Centroids
[x,y] = centroid(pet);
[v,w] = centroid(allSpots);
X=[x v];
Y=[y w];

%% plot polys
ppet = plot(pet);
ppet.FaceColor = [1 1 0];
ppet.FaceAlpha = 0.4;
hold on;
pg = plot(allSpots);
pg.FaceColor = 'red';
p3.FaceAlpha = 1;
hold on;

hold off;

%% plot centroids

%% make the line
plot(X, Y,...
    'LineWidth',2,...
    'Color','black');
hold on;
%% petal centroid
plot(x,y, 'o', 'MarkerSize', 15,...
    'MarkerEdgeColor','black',...
    'MarkerFaceColor','yellow')
    hold on 
%% polygon centroid
plot(x,y, '+', 'MarkerSize', 15,...
    'MarkerEdgeColor','black')
    hold on 
plot(v,w, 'o', 'MarkerSize', 15,...
    'MarkerEdgeColor','black',...
    'MarkerFaceColor','red')
    hold on
plot(v,w, '+', 'MarkerSize', 15,...
    'MarkerEdgeColor','black')
    hold off


%%%%%%%%%%%%%%%%%%%%%%


pdist(X, Y)




[x,y] = centroid(pet);





%% one idea for a quick spot centroid - union(polys) -- centroid()

pg = plot(allSpots);
pg.FaceColor = 'red';
pg.FaceAlpha = 1;
hold on;

ppet=plot(pet(1));
ppet.FaceColor = 'blue';
hold on;

plot(x,y, '-s', 'MarkerSize', 10,...
    'MarkerEdgeColor','black',...
    'MarkerFaceColor','black');
hold off





%% side note, what do the petal polygons look like in the flowers where spots look like they 
%% interfered with the petal outline


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


#################################################

## lets delve back into our python digitization process.

## while we are making our polygons, can we add hand digitizing and 
## corner detection?

## and maybe while we're in here, we see how digitizing from the jpegs works out for us.
## it may be better than Doug's color simplification outputs. 
## doubt it, but it's worth a look

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure, feature
from pprint import pprint 

petal = np.genfromtxt ('P431F1petal.csv', delimiter=",")

petal.shape

petal_marg = np.insert(petal, 439, 1, 1)
petal_marg = np.insert(petal_marg, 0, 1, 1)
petal_marg = np.insert(petal_marg, 561, 1, 0)
petal_marg = np.insert(petal_marg, 0, 1, 0)

Pcontours = measure.find_contours(petal_marg, 0)

## works as before. Now do we use this or the original 
## for corner detection?

## first let's try it on the doug petal outline:

petal_marg = np.transpose(petal_marg)

coords = feature.corner_peaks(
    feature.corner_harris(petal_marg),
    min_distance = 2
)


fig, ax = plt.subplots()
ax.imshow(petal_marg)
plt.show()
ax.plot(coords[:, 1], coords[:, 0], '.b', markersize=5)

## can we smooth/simplify the image a bit?
## or perhaps works better with the contours?

hand = np.array([[1.64516129, 1.16145833],
                 [1.64516129, 1.59375],
                 [1.35080645, 1.921875],
                 [1.375, 2.18229167],
                 [1.68548387, 1.9375],
                 [1.60887097, 2.55208333],
                 [1.68548387, 2.69791667],
                 [1.76209677, 2.56770833],
                 [1.83064516, 1.97395833],
                 [1.89516129, 2.75],
                 [1.9516129, 2.84895833],
                 [2.01209677, 2.76041667],
                 [1.99193548, 1.99479167],
                 [2.11290323, 2.63020833],
                 [2.2016129, 2.734375],
                 [2.25403226, 2.60416667],
                 [2.14919355, 1.953125],
                 [2.30645161, 2.36979167],
                 [2.39112903, 2.36979167],
                 [2.41532258, 2.1875],
                 [2.1733871, 1.703125],
                 [2.07782258, 1.16666667]])



new_hand = hand.copy()

new_hand = measure.subdivide_polygon(new_hand, degree=2, preserve_ends=True)

for _ in range(3):
    new_hand = measure.subdivide_polygon(new_hand, degree=2, preserve_ends=True)

fig, (ax1, ax2) = plt.subplots(ncols=2)

ax1.plot(hand[:, 0],hand[:, 1])
ax1.plot(new_hand[:, 0],new_hand[:, 1])

## interesting. awesome smoothing algorithm

## can we do something like this with our petal outline?

plt.ion()

Pcontours = measure.find_contours(petal_marg, 0)

new_contours = measure.subdivide_polygon(Pcontours[0], degree=2, preserve_ends=True) 

for _ in range(5):
    new_contours = measure.subdivide_polygon(Pcontours[0], degree=2, preserve_ends=True) 

fig, (ax1, ax2) = plt.subplots(ncols=2)
ax1.plot(Pcontours[0][:,0], Pcontours[0][:,1])
ax2.plot(new_contours[:,0], new_contours[:,1])

## doesn't really work, we need sort of the opposite here. Can we put hard corners on our
## petal outline?

aa = measure.approximate_polygon(Pcontours[0], tolerance=9)
fig, (ax1, ax2) = plt.subplots(ncols=2)
ax1.plot(Pcontours[0][:,0], Pcontours[0][:,1])
ax2.plot(aa[:,0], aa[:,1])

plt.show()

## now we're in business. Can we use this to find our corners?

coords = feature.corner_peaks(
    feature.corner_harris(aa),
    min_distance = 2
)


fig, (ax1, ax2, ax3) = plt.subplots(ncols=3)
ax1.plot(Pcontours[0][:,0], Pcontours[0][:,1])
ax2.plot(aa[:,0], aa[:,1])
ax3.plot(aa[:,0], aa[:,1])

## anyway, can we use aa to detect our bottom vertices?

aa[:,1]

aa[:,0]

aa[:,1], aa[:,0]

aa[

np.hstack((aa[:,1], aa[:,0]))

np.concatenate(aa[:,1], aa[:,0], axis = 1)

np.concatenate( [ np.array( [ [1,2], [2,3] ] ), np.array( [ [3],[4] ] ) ] , axis = 1)


bb = np.concatenate([aa[:,1],aa[:,0]], axis = 1)

fig, ax1 = plt.subplots()
ax1.plot(bb[:,0],bb[:,1])


np.array([[1,2],[3,4],[5,6]])

## back on this, where were we?

## oh yeah, can we modify our python digitization script to include finding the bottom corners 
## of our petals?

##############################

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure, feature
from pprint import pprint 

#plt.ion()

petalFile=('P431F1petal.csv')

petal = np.genfromtxt (petalFile, delimiter=",")


petal.shape[0]
petal.shape[1]

petal_marg = np.insert(petal, petal.shape[1], 1, 1)
petal_marg = np.insert(petal_marg, 0, 1, 1)
petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
petal_marg = np.insert(petal_marg, 0, 1, 0)

Pcontours = measure.find_contours(petal_marg, 0)
aa = measure.approximate_polygon(Pcontours[0], tolerance=9)

## get corners.. how?
## in these inverted images, these should be the highest points:
bb = aa.copy()
bb = bb[bb[:,1].argsort()[::-1]]
cc = bb[0:2,:]

fig, (ax1, ax2, ax3) = plt.subplots(ncols=3)
ax1.plot(Pcontours[0][:,0], Pcontours[0][:,1])
ax2.plot(aa[:,0], aa[:,1])
ax3.plot(aa[:,0], aa[:,1])
ax3.plot(aa[:,0], aa[:,1], 'ro') ## show vertices
ax3.plot(cc[:,0], cc[:,1], 'yo', fillstyle='none',markersize=10, linewidth=3) ## show vertices


## does this work with other petals? how about our side petals?

################### write a function #######
#!/usr/bin/env python3

## petal is single binary petal outline
## petal matrix ouputted from 
## doug's color simplification pipeline
## as a CSV

import numpy as np
import matplotlib.pyplot as plt
import shapely as sh
from skimage import data, io, filters, measure, feature

def digitizePols(petalFile):
    ## pad margins of image and get the contour of the petal shape
    petal = np.genfromtxt (petalFile, delimiter=",")
    petal_marg = np.insert(petal, petal.shape[1], 1, 1)
    petal_marg = np.insert(petal_marg, 0, 1, 1)
    petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
    petal_marg = np.insert(petal_marg, 0, 1, 0)
    Pcontours = measure.find_contours(petal_marg, 0)
    simplePoly = measure.approximate_polygon(Pcontours[0], tolerance=9)
    ## get corners
    ## in these inverted images, these should be the highest points:
    bb = simplePoly.copy()
    bb = bb[bb[:,1].argsort()[::-1]]
    corners = bb[0:2,:]
    return(Pcontours[0],simplePoly,corners) 

##############

## does it work?

petalFile=('P431F1petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)

def plotCor(Pcontours,simplePoly,corners):
    fig, (ax1, ax2, ax3, ax4) = plt.subplots(ncols=4)
    ax1.plot(Pcontours[:,0], Pcontours[:,1])
    ax2.plot(simplePoly[:,0], simplePoly[:,1])
    ax3.plot(simplePoly[:,0], simplePoly[:,1])
    ax3.plot(simplePoly[:,0], simplePoly[:,1], 'ro') ## show vertices
    ax3.plot(corners[:,0], corners[:,1], 'yo', fillstyle='none',markersize=10, linewidth=3) ## show vertices
    ax4.plot(Pcontours[:,0], Pcontours[:,1])
    ax4.plot(corners[:,0], corners[:,1], 'ro', fillstyle='none',markersize=10, linewidth=3) ## show vertices

## try side petals:

petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P431F1/mid/P431F1_mid_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
plotCor(Pcontours,simplePoly,corners)

petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P431F1/left/P431F1_left_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
plotCor(Pcontours,simplePoly,corners)

plt.savefig('P431F1_left_corners.png')
## doesn't capture our upper petal corners...

## how about some other bottom petals:


petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P375F2/left/P375F2_left_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
plotCor(Pcontours,simplePoly,corners)

## oops, that was an upper petal, but it worked!

plt.savefig('P375F2_left_corners.png')

## anyway other lower petals:

petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P375F2/right/P375F2_right_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)

petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P401F2/right/P401F2_right_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
plotCor(Pcontours,simplePoly,corners)

plt.savefig('P401F2_right_corners.png')

####################################


## works pretty well. 

## can we get our polygons into shapely objects?

## the goal is have the zones demarcated as part of the digitization 
## process. 

## to get our outline as a shapely polygon:

import shapely.geometry as sg
import shapely.affinity as sa

testP = sg.asPolygon(Pcontours)

xs, ys = testP.exterior.xy

fig, ax1 = plt.subplots()
ax1.fill(xs, ys)

## works. can we simplify?

s = testP.simplify(5, preserve_topology=False)

xsimp, ysimp = s.exterior.xy
fig, (ax1,ax2) = plt.subplots(ncols=2)
ax1.fill(xs, ys)
ax2.fill(xsimp, ysimp)

## let's make a plot function:

def plpo(pol, cl='blue'):
    xs, ys = pol.exterior.xy
    fig, ax1 = plt.subplots()
    ax1.fill(xs, ys)
    ax2.fill(xsimp, ysimp)

plpo(testP)

## okay, can we get the inside polygon?

## wait, first, let's scale and center

## how to do this in python?

petalFile=('P431F1petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)

testP = sg.asPolygon(Pcontours)
xs, ys = testP.exterior.xy
fig, ax1 = plt.subplots()
ax1.fill(xs, ys)

## how can we scale this? just multiply by square root?

## find the scalar 
bb = testP.area
#sc = bb**(1/2)
sc = bb**(-1/2)

## scale
dd = sa.scale(testP, xfact=sc, yfact=sc) 


## recenter (translate to origin)

## get center

cent = dd.centroid

cX, cY = cent.xy

(-1*cX[0])

ee = sa.translate(dd, (-1*cX[0]), (-1*cY[0]))

plpo(ee)

ee.area

##so a function for this, accepts a numpy array of points.
## so we can accept the array from skimage:

def standPet(pet):
    import shapely.geometry as sg
    import shapely.affinity as sa
    aa = sg.asPolygon(pet)
    bb = aa.area
    sc = bb**(-1/2)
    dd = sa.scale(aa, xfact=sc, yfact=sc) 
    ee = dd.centroid
    cX, cY = ee.xy
    ff = sa.translate(dd, (-1*cX[0]), (-1*cY[0]))
    return(ff)

## for spots?

def digitizePols(petalFile):
    ## pad margins of image and get the contour of the petal shape
    petal = np.genfromtxt (petalFile, delimiter=",")
    petal_marg = np.insert(petal, petal.shape[1], 1, 1)
    petal_marg = np.insert(petal_marg, 0, 1, 1)
    petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
    petal_marg = np.insert(petal_marg, 0, 1, 0)
    Pcontours = measure.find_contours(petal_marg, 0)
    simplePoly = measure.approximate_polygon(Pcontours[0], tolerance=9)
    ## get corners
    ## in these inverted images, these should be the highest points:
    bb = simplePoly.copy()
    bb = bb[bb[:,1].argsort()[::-1]]
    corners = bb[0:2,:]
    return(Pcontours[0],simplePoly,corners) 

spotsFile=('P431F1spots.csv')

testS = digitizePols('P431F1spots.csv')

def standFlower(pet, spots=None):
    import shapely.geometry as sg
    import shapely.affinity as sa
    ## get petal outline standardized, get center and scale
    aa = sg.asPolygon(pet)
    bb = aa.area
    sc = bb**(-1/2)
    dd = sa.scale(aa, xfact=sc, yfact=sc) 
    ee = dd.centroid
    cX, cY = ee.xy
    ff = sa.translate(dd, (-1*cX[0]), (-1*cY[0]))
    ## try spots
    if spots is not None: 


can this be a list comprehension?

def standFlower(pet, spots=None):
    import shapely.geometry as sg
    import shapely.affinity as sa

def getinfo(pet):
    aa = sg.asPolygon(pet)
    area = aa.area
    scalar = area**(-1/2)
    center = aa.centroid
    return(scalar, center)

getinfo(

    def stand(pol):
        ispot = sg.asPolygon(i)
        iscaled = sa.scale(ispot, xfact=sc, yfact=sc)
        itrans = sa.translate(iscaled, (-1*cX[0]), (-1*cY[0]))
        return(itrans)


    iStand = [ stand(i) for i in spots ]

pols=(ff, 
    return(pols)

## try it out:

petalFile=('P431F1petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
testP = standPet(Pcontours)

plpo(testP)

testP.area

## order would be:

## doug's stuff --> sckimage contours --> shapely polygon processing

## so


######## head is spinning. start over from a csv from doug's color simplifications


petalFile=('P431F1petal.csv')
spotsFile=('P431F1spots.csv')


## 1 get our polygons from our petals and spots:

def digitizePols(file):
    import numpy as np
    from skimage import measure
    ## pad margins of image and get the contour of the petal shape
    petal = np.genfromtxt (file, delimiter=",")
    petal_marg = np.insert(petal, petal.shape[1], 1, 1)
    petal_marg = np.insert(petal_marg, 0, 1, 1)
    petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
    petal_marg = np.insert(petal_marg, 0, 1, 0)
    Pcontours = measure.find_contours(petal_marg, 0)
    ## gotta ditch <3 points, they are lines
    polys = [ i for i in Pcontours if len(i) > 3 ]
    return(polys)


testP = digitizePols(petalFile)[0] ## for petals, take first polygon, always seems to work?
testS = digitizePols(spotsFile)

## 2 get information about centroid and scaling factor:

def getPetGeoInfo(pet):
    aa = sg.asPolygon(pet)
    area = aa.area
    scalar = area**(-1/2)
    center = aa.centroid.wkt
    centerCoor = (cX[0], cY[0])
    return(scalar, centerCoor)

scale, cent = getPetGeoInfo(testP)

## 3 standardize petals

def stand(pol, scale, cent):
    aa = sg.asPolygon(pol)
    trans = sa.translate(aa, (-1*cent[0]), (-1*cent[1]))
    scaled = sa.scale(trans, xfact=scale, yfact=scale, origin = (0,0))
    return(scaled)

standPet = stand(testP, scale, cent)

## 4 standardize spots

spotz = [ stand(i, scale, cent) for i in testS ]

## can we take a look at this?

## 5 get the corners:




fig, ax1 = plt.subplots()
xs, ys = standPet.exterior.xy
#xs, ys = trans.exterior.xy
#xs, ys = scaled.exterior.xy
ax1.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax1.fill(xs, ys, "r")
  

###########

## python
import numpy as np
import matplotlib.pyplot as plt
import shapely.geometry as sg
import shapely.affinity as sa
from skimage import data, io, filters, measure

def digitizePols(file):
    ## pad margins of image and get the contour of the petal shape
    petal = np.genfromtxt (file, delimiter=",")
    petal_marg = np.insert(petal, petal.shape[1], 1, 1)
    petal_marg = np.insert(petal_marg, 0, 1, 1)
    petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
    petal_marg = np.insert(petal_marg, 0, 1, 0)
    Pcontours = measure.find_contours(petal_marg, 0)
    ## gotta ditch <3 points, they are lines
    polys = [ i for i in Pcontours if len(i) > 3 ]
    return(polys)

def getPetGeoInfo(pet):
    aa = sg.asPolygon(pet)
    area = aa.area
    scalar = area**(-1/2)
    center = aa.centroid.wkt
    centerCoor = (center[0], center[1])
    return(scalar, centerCoor)

def getPetGeoInfo(pet):
    aa = sg.asPolygon(pet)
    area = aa.area
    scalar = area**(-1/2)
    center = aa.centroid
    centerCoor = (center.x, center.y)
    return(scalar, centerCoor)

def stand(pol, scale, cent):
    aa = sg.asPolygon(pol)
    trans = sa.translate(aa, (-1*cent[0]), (-1*cent[1]))
    scaled = sa.scale(trans, xfact=scale, yfact=scale, origin = (0,0))
    return(scaled)

## we have an example "right" or lower petal example in our wd:
petalFile=('P431F1petal.csv')
spotsFile=('P431F1spots.csv')

## 1 make our raw, unscaled, untranslated polygons:
testP = digitizePols(petalFile)[0] ## for petals, take first polygon, always seems to work?
testS = digitizePols(spotsFile)

## 2 get information about centroid and scaling factor:
scale, cent = getPetGeoInfo(testP)

## okay so we have a pipeline in python that gets us to 

## 3-4 standard petal and spots:

standPet = stand(testP, scale, cent)

spotz = [ stand(i, scale, cent) for i in testS ]

## plot
fig, ax1 = plt.subplots()
xs, ys = standPet.exterior.xy
#xs, ys = trans.exterior.xy
#xs, ys = scaled.exterior.xy
ax1.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax1.fill(xs, ys, "r")
    
## check area. = 1?
standPet.area

## looks good. Now can we make a margin that incorporates 
## 50% of the petal polygon?


hole = standPet
rad = 0
while hole.area > 0.5:
    hole = standPet.buffer(rad)
    rad -= .001

holeR = sg.polygon.asLinearRing(hole)
## now make a polygon with this as a hole
marg = sg.polygon.Polygon(
    standPet.exterior, 
    holes = [hole.exterior.coords])



def shaPl(pol):
    fig, ax1 = plt.subplots()
    xo, yo = pol.exterior.xy
    if pol.interiors:
        xi, yi = pol.interiors[0].xy
    ax1.fill(xo, yo, "y")
    if pol.interiors:
        ax1.fill(xi, yi, "w")

shaPl(marg)

shaPl(standPet)

#################

## find corners, define tongue:

## we need to find our corners. 

## simplify:

aa = marg.simplify(0.5)

aa = marg.simplify(0.1)
shaPl(aa)

## the super hard simplification 
## may be handy for the side petals..

## but here, with P431F1petal we need 
## more like:

aa = marg.simplify(0.05)

shaPl(aa)

## how do we find our throat? Should be the top four points:

ax, ay = aa.exterior.xy

max(ay)

## when done - cycle through all the images, show how the
##  throat finding algorithm works


cc = np.array(aa.interiors[0].xy).transpose()

## how to get the highest two points?


## unlike R, you can just refer to rows of an 
## array

aa = marg.simplify(0.05)
bb = np.array(aa.exterior.xy).transpose()
bb[:,0].argsort()
## gives us an array of ranks of the values, 
## use this to sort:
zz = bb[bb[:,1].argsort()[::-1]]
## for our corners, take the top two:
yy = zz[0:2]

shaPl(standPet)
plt.plot(yy[:,0], yy[:,1], 'ro', fillstyle='none',markersize=10, linewidth=3)

## works - do the same for the interior?

#aa = marg.simplify(0.05)
bb = np.array(aa.interiors[0].xy).transpose()
bb[:,0].argsort()
## gives us an array of ranks of the values, 
## use this to sort:
zz = bb[bb[:,1].argsort()[::-1]]
## for our corners, take the top two:
xx = zz[0:2,]
xx = np.flipud(xx) ## reverse the order for making polys

shaPl(standPet)
plt.plot(yy[:,0], yy[:,1], 'ro', fillstyle='none',markersize=10, linewidth=3)
plt.plot(xx[:,0], xx[:,1], 'ro', fillstyle='none',markersize=10, linewidth=3)

## can we make a polygon out of these?

## combine them:

tt = np.concatenate((yy,xx))

plt.plot(tt[:,0],tt[:,1])

throat = sg.polygon.Polygon(tt)


## plot

fig, (ax1,ax2) = plt.subplots(ncols=2)
xs, ys = standPet.exterior.xy
ax1.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax1.fill(xs, ys, "r")

xs, ys = standPet.exterior.xy
ax2.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax2.fill(xs, ys, "r")
xo, yo = marg.exterior.xy
ax2.plot(xo, yo, "b")
xo, yo = marg.interiors[0].xy
ax2.plot(xo, yo, "b")
xo, yo = throat.exterior.xy
ax2.plot(xo, yo, "b")





#shaPl(marg)

xo, yo = marg.exterior.xy
plt.plot(xo, yo, "b")

xo, yo = marg.interiors[0].xy
plt.plot(xo, yo, "b")

xo, yo = throat.exterior.xy
plt.plot(xo, yo, "b")

fig, ax1 = plt.subplots()

xo, yo = pol.exterior.xy
xi, yi = pol.interiors[0].xy
ax1.fill(xo, yo, "y")
ax1.fill(xi, yi, "w")

xo, yo = pol.exterior.xy
xi, yi = pol.interiors[0].xy
ax1.fill(xo, yo, "y")
ax1.fill(xi, yi, "w")

fig, ax1 = plt.subplots()
xs, ys = standPet.exterior.xy
#xs, ys = trans.exterior.xy
#xs, ys = scaled.exterior.xy
ax1.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax1.fill(xs, ys, "r")

## seems to work. make a function for defining zones? 

## takes a standardized petal polygon:

def findZones(standPol, percent):
    hole = standPol
    rad = 0
    ## iterate down till we get our percent margin:
    while hole.area > percent:
        hole = standPol.buffer(rad)
        rad -= .001
    holeR = sg.polygon.asLinearRing(hole)
    ## now make a polygon with this as a hole
    marg = sg.polygon.Polygon(
            standPet.exterior, 
            holes = [hole.exterior.coords])
    ## make throat.
    ## exterior corners:
    aa = marg.simplify(0.05)
    bb = np.array(aa.exterior.xy).transpose()
    bb[:,0].argsort()
    ## gives us an array of ranks of the values, 
    ## use this to sort:
    zz = bb[bb[:,1].argsort()[::-1]]
    ## for our corners, take the top two:
    yy = zz[0:2]
    ## interior corners:
    bb = np.array(aa.interiors[0].xy).transpose()
    bb[:,0].argsort()
    ## gives us an array of ranks of the values, 
    ## use this to sort:
    zz = bb[bb[:,1].argsort()[::-1]]
    ## for our corners, take the top two:
    xx = zz[0:2,]
    xx = np.flipud(xx) 
    ##combine corners, make throat:
    tt = np.concatenate((yy,xx))
    throat = sg.polygon.Polygon(tt)
    return(marg, throat)

## does this work?

marg,throat = findZones(standPet, 0.5)

#################
#################

## todo today

## define flower class
## zones 



fig, (ax1,ax2) = plt.subplots(ncols=2)
xs, ys = standPet.exterior.xy
ax1.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax1.fill(xs, ys, "r")

xs, ys = standPet.exterior.xy
ax2.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax2.fill(xs, ys, "r")

xo, yo = marg.exterior.xy
ax2.plot(xo, yo, "b")
xo, yo = marg.interiors[0].xy
ax2.plot(xo, yo, "b")
xo, yo = throat.exterior.xy
ax2.plot(xo, yo, "b")


##############

## Aug 29

## today:

## throat polygon - make it match the margin outline where they intersect. Then leave, you fucking perfectionist. 

## define flower class

## streamline code. 

################

## python
import numpy as np
import matplotlib.pyplot as plt
import shapely.geometry as sg
import shapely.affinity as sa
from skimage import measure
from descartes import PolygonPatch

## Let's redo the throat.

## our four functions so far for creating polygons:

def digitizePols(file):
    ## pad margins of image and get the contour of the petal shape
    petal = np.genfromtxt (file, delimiter=",")
    petal_marg = np.insert(petal, petal.shape[1], 1, 1)
    petal_marg = np.insert(petal_marg, 0, 1, 1)
    petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
    petal_marg = np.insert(petal_marg, 0, 1, 0)
    Pcontours = measure.find_contours(petal_marg, 0)
    ## gotta ditch <3 points, they are lines
    polys = [ i for i in Pcontours if len(i) > 3 ]
    return(polys)

def getPetGeoInfo(pet):
    aa = sg.asPolygon(pet)
    area = aa.area
    scalar = area**(-1/2)
    center = aa.centroid
    centerCoor = (center.x, center.y)
    return(scalar, centerCoor)

def stand(pol, scale, cent):
    aa = sg.asPolygon(pol)
    trans = sa.translate(aa, (-1*cent[0]), (-1*cent[1]))
    scaled = sa.scale(trans, xfact=scale, yfact=scale, origin = (0,0))
    return(scaled)


def findZones(standPol, percent):
    hole = standPol
    rad = 0
    ## iterate down till we get our percent margin:
    while hole.area > percent:
        hole = standPol.buffer(rad)
        rad -= .001
    ## now make a polygon with this as a hole
    marg = sg.polygon.Polygon(
            standPet.exterior,
            holes = [hole.exterior.coords])
    ## make throat.
    ## exterior corners:
    aa = marg.simplify(0.05)
    bb = np.array(aa.exterior.xy).transpose()
    bb[:,0].argsort()
    ## gives us an array of ranks of the values,
    ## use this to sort:
    zz = bb[bb[:,1].argsort()[::-1]]
    ## for our corners, take the top two:
    yy = zz[0:2]
    ## interior corners
    bb = np.array(aa.interiors[0].xy).transpose()
    bb[:,0].argsort()
    ## gives us an array of ranks of the values,
    ## use this to sort
    zz = bb[bb[:,1].argsort()[::-1]]
    xx = zz[0:2,]
    xx = np.flipud(xx)
    ## combine corners, make throat:
    tt = np.concatenate((yy,xx))
    throat = sg.polygon.Polygon(tt)
    return(marg, throat)

## rerun our samples:

## we have an example "right" or lower petal example in our wd:
petalFile=('P431F1petal.csv')
spotsFile=('P431F1spots.csv')
## 1 make our raw, unscaled, untranslated polygons:
testP = digitizePols(petalFile)[0] ## for petals, take first polygon, always seems to work?
testS = digitizePols(spotsFile)
## 2 get information about centroid and scaling factor:
scale, cent = getPetGeoInfo(testP)
## 3 standardize petals
standPet = stand(testP, scale, cent)
## 4 standardize spots
spotz = [ stand(i, scale, cent) for i in testS ]
## 5 define zones, at 50%:
marg,throat = findZones(standPet, 0.5)

## plot it:

fig, (ax1,ax2) = plt.subplots(ncols=2)
xs, ys = standPet.exterior.xy
ax1.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax1.fill(xs, ys, "r")

xs, ys = standPet.exterior.xy
ax2.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax2.fill(xs, ys, "r")

xo, yo = marg.exterior.xy
ax2.plot(xo, yo, "b")
xo, yo = marg.interiors[0].xy
ax2.plot(xo, yo, "b")
xo, yo = throat.exterior.xy
ax2.plot(xo, yo, "b") 

## okay, how do we get a nicer throat polygon:

fig, ax1 = plt.subplots()
xo, yo = marg.exterior.xy
ax1.plot(xo, yo, "r")
xo, yo = marg.interiors[0].xy
ax1.plot(xo, yo, "r")
xo, yo = throat.exterior.xy
ax1.plot(xo, yo, "b") 
 
## can we cut out the throat?

aa = throat.intersection(marg)

bb = marg.difference(throat)

cc = throat.difference(marg)

fig, ax1 = plt.subplots(ncols=1)
for i in bb:
    xo, yo = i.exterior.xy
    ax1.plot(xo, yo, "b")

## okay, how do we grab those little bits of margin 
## close to our first throat polygon 
## tking the rest of the margin?

## grow the throat polygon outward:

tb = throat.buffer(0.1)

fig, ax1 = plt.subplots(ncols=1)
xo, yo = tb.exterior.xy
ax1.fill(xo, yo, 
         facecolor="#FF9933",
         alpha=0.3)
for i in bb:
    xo, yo = i.exterior.xy
    ax1.plot(xo, yo, "b")

## how can we get just the polys inside our big throat buffer?
## it's a multpolygon, so we can sort treat it like a list
## polygons:

cc = [ i.within(tb) for i in bb ]

## how do we make a new polygon out of this?

cc = [ i for i in bb if i.within(tb) ]

## can we turn this back into a multipolygon?

dd = sg.multipolygon.MultiPolygon(cc)

## look at it:


fig, ax1 = plt.subplots(ncols=1)
xo, yo = tb.exterior.xy
ax1.fill(xo, yo, 
         facecolor="#FF9933",
         alpha=0.3)
for i in dd:
    xo, yo = i.exterior.xy
    ax1.plot(xo, yo, "b")


## promising - merge it with our throat/margin intersection 
## from above?

## our real throat polygon:
ee = aa.union(dd)

fig, ax1 = plt.subplots(ncols=1)
xo, yo = ee.exterior.xy
ax1.plot(xo, yo)
xo, yo = aa.exterior.xy
ax1.fill(xo, yo, 
         facecolor="#FF66B2",
         alpha=0.3)

## our center?

## let's revise our function to include this


## looks good. Can we break up our petal clean?
## into three polygons this way?

def findZones(standPol, percent):
    center = standPol
    rad = 0
    while center.area > percent:
        center = standPol.buffer(rad)
        rad -= .001
    marg = sg.polygon.Polygon(
            standPet.exterior,
            holes = [center.exterior.coords])
    simPol = marg.simplify(0.05)
    simPolA = np.array(simPol.exterior.xy).transpose()
    simPolA[:,0].argsort()
    simPolAsorted = simPolA[simPolA[:,1].argsort()[::-1]]
    outCorners = simPolAsorted[0:2]
    simPolB = np.array(simPol.interiors[0].xy).transpose()
    simPolB[:,0].argsort()
    simPolBsorted = simPolB[simPolB[:,1].argsort()[::-1]]
    inCorners = simPolBsorted[0:2,]
    inCorners = np.flipud(inCorners)
    tRap = np.concatenate((outCorners,inCorners))
    tRapPoly = sg.polygon.Polygon(tRap)
    tBuff = tRapPoly.buffer(0.1)
    noTrap = marg.difference(tRapPoly)
    notInTrap = [ i for i in noTrap if i.within(tBuff) ]
    mpNotInTrap = sg.multipolygon.MultiPolygon(notInTrap)
    throat = tRapPoly.union(mpNotInTrap )
    return(center, marg, throat)

## okay, we want to make this spit out non-overlapping zones, that cover 
## all surface of the original petal polygon.

percent = 0.5
center = standPol = standPet

def findZones(standPol, percent):
    center = standPol
    rad = 0
    while center.area > percent:
        center = standPol.buffer(rad)
        rad -= .001
    marg = sg.polygon.Polygon(
            standPet.exterior,
            holes = [center.exterior.coords])
    simPol = marg.simplify(0.05)
    simPolA = np.array(simPol.exterior.xy).transpose()
    simPolA[:,0].argsort()
    simPolAsorted = simPolA[simPolA[:,1].argsort()[::-1]]
    outCorners = simPolAsorted[0:2]
    simPolB = np.array(simPol.interiors[0].xy).transpose()
    simPolB[:,0].argsort()
    simPolBsorted = simPolB[simPolB[:,1].argsort()[::-1]]
    inCorners = simPolBsorted[0:2,]
    inCorners = np.flipud(inCorners)
    tRap = np.concatenate((outCorners,inCorners))
    tRapPoly = sg.polygon.Polygon(tRap)
    tBuff = tRapPoly.buffer(0.1)
    noTrap = marg.difference(tRapPoly)
    notInTrap = [ i for i in noTrap if i.within(tBuff) ]
    mpNotInTrap = sg.multipolygon.MultiPolygon(notInTrap)
    margInTrap = tRapPoly.intersection(marg)
    throat = margInTrap.union(mpNotInTrap )
    edge = marg.difference(throat)
    return(center, edge, throat)

center, edge, throat = findZones(standPet, 0.5)


## let's try this patches:

fig, ax1 = plt.subplots(ncols=1)
ax1.set_xlim(-0.8,0.8)
ax1.set_ylim(-0.8,0.8)

ax1.add_patch(PolygonPatch(edge, fc='blue', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(tRapPoly, fc='blue', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(margInTrap, fc='blue', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(noTrap, fc='blue', ec='blue', alpha=0.5))

for i in notInTrap:
    ax1.add_patch(PolygonPatch(i, fc='blue', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(mpNotInTrap, fc='blue', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(tBuff, fc='blue', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(center, fc='blue', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(edge, fc='red', ec='blue', alpha=0.5))

ax1.add_patch(PolygonPatch(throat, fc='yellow', ec='blue', alpha=1.0))

ax1.add_patch(PolygonPatch(standPet, fc='yellow', ec='blue', alpha=1.0))

## looks good. 

## so, lots to do from here:

## check out Melias new outputs.

## turn the above into a script that you can run on all of them. 

## run it on all of them. 

## improve corner detection for side petals

## get stats - edge spots, center spots, centeredness, throat spots, 


############ task #1 - check on side petals:

## how well does our algorithm perfom on the upper pettals? Their corners are not so pronounced as the lower:

## here is an upper petal that belongs to the same flower as our example:

petDir = ("/Users/danthomas/Documents/speckling"
          "/make_polygons/polygons/P431F1/left/")

petalFName=('P431F1_left_petal.csv')
spotsFName=('P431F1_left_spots.csv')
petalFile=(petDir + petalFName)
spotsFile=(petDir + spotsFName)

## run this through our pipeline:

testP = digitizePols(petalFile)[0] 
testS = digitizePols(spotsFile)
scale, cent = getPetGeoInfo(testP)
standPet = stand(testP, scale, cent)
spotz = [ stand(i, scale, cent) for i in testS ]
center, edge, throat = findZones(standPet, 0.5)


## can we make a plotting function:


## need to harden our polygons a bit more to get side petals to work...

## looks good

############### rerun Melia's data #########

## we need to get melia's new clusters into our python 
## pipeline. Everything should be the same, if Melia's
## side went smoothly. 

## so just plug in her new files into the right place:

## (doug's raster folder), then rerun the script "prepDougRasters.m"

## now we need a script for running our digitization all 
## the function

## then a script for showing them

## the script for digitizing a directory of a petal 
## we called this "get_pols.py", let's revise that 
## script to do what we need.





## draft script is used like this:

cd /Users/danthomas/Documents/speckling/make_polygons

ff="/Users/danthomas/Documents/speckling/make_polygons/polygons/P431F1/mid"
dd="/Users/danthomas/Desktop/tryScript"
./get_pols.py $ff 0.5 $dd

cd $dd

## did it work?

python3

import argparse, os, pickle

import numpy as np
import matplotlib.pyplot as plt
import shapely.geometry as sg
import shapely.affinity as sa
from skimage import measure
from descartes import PolygonPatch

zoop = "this is a piece of text"
pickle.dump(zoop, open("zoop.p", "wb"))
pickle.dump(zoop, open("zoop.p", "w")) ## doesn't work, 
pickle.dump(zoop, open("zoop.p", "wt")) ## doesn't work, 
del(zoop)
test = pickle.load(open("zoop.p", "rb"))

aa = pickle.load(open("P431F1_mid_polys.p", "r"))

aa = pickle.load(open("P431F1_mid_polys.p", "rb"))



## ugh, not working. 

#####

def pZones(standPet, spotz, center, edge, throat):
    fig, (ax1,ax2) = plt.subplots(ncols=2)
    xs, ys = standPet.exterior.xy
    ax1.fill(xs, ys, "y")
    for i in spotz:
        xs, ys = i.exterior.xy
        ax1.fill(xs, ys, "r")
     
    ax2.set_xlim(ax1.get_xlim())
    ax2.set_ylim(ax1.get_ylim())
    xs, ys = standPet.exterior.xy
    ax2.fill(xs, ys, "y")
    for i in spotz:
        xs, ys = i.exterior.xy
        ax2.fill(xs, ys, "r")

    alp=0.5
    l=5
    ax2.add_patch(PolygonPatch(center,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    ax2.add_patch(PolygonPatch(throat,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    ax2.add_patch(PolygonPatch(edge,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))

####

cd /Users/danthomas/Documents/speckling/make_polygons

python3 

import argparse, os, pickle, json, pprint
import numpy as np
import matplotlib.pyplot as plt
import shapely.geometry as sg
import shapely.affinity as sa
from skimage import measure
from descartes import PolygonPatch
from get_pols import *


#import get_pols 


## here is the __main__ script, minus imports, args etc

#folder="/Users/danthomas/Documents/speckling/make_polygons/polygons/P431F1/right"
folder="/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons/P431F1/right"
#destination="/Users/danthomas/Desktop/tryScript"
destination="/home/daniel/Desktop/tryScript"
centerSize=0.5


#######

os.chdir(folder)
aa = os.listdir()

for i in aa:
    if "petal" in i:
        petPol = digitizePols(i)[0]
    elif "spots" in i:
        spotPol = digitizePols(i)

scale, cent = getPetGeoInfo(petPol)

standPet = stand(petPol, scale, cent)
standSpot = sg.multipolygon.MultiPolygon([ stand(i, scale, cent) for i in spotPol ])

center, edge, throat = findZones(standPet, centerSize, 0.07)

polys = {
    'standPet': standPet,
    'standSpot': standSpot,
    'center': center,
    'edge': edge,
    'throat': throat
            }

sg.multipolygon.MultiPolygon

mply = sg.multipolygon.MultiPolygon([standPet, center, edge, throat])

mply = sg.multipolygon.MultiPolygon([standPet, center, edge, throat])

mply = sg.multipolygon.MultiPolygon([standPet, standSpot, center, edge, throat])



here = os.getcwd()
petalName = os.path.basename(here)
flowerName = os.path.basename(os.path.dirname(here))
gjName = (flowerName + "_" 
          + petalName 
          + "_polys")
outFileName = ( destination + "/"
                + flowerName + "_"
                + petalName
                + "_polys.geojson")


## can we output as a geojson?
gj = json.dumps(sg.mapping(standPet))

## can it handle multiple objects?



with open(outFileName, "w") as output:
    output.write(gj)

## works. can we do a multipolygon? like if the throat gets weird?

os.chdir("/Users/danthomas")

gj_throat = json.dumps(sg.mapping(throat))

with open("throat.geojson", "w") as output:
    output.write(gj_throat)

#######

    

os.chdir("/Users/danthomas/Desktop")

gj_throat = json.dumps(sg.mapping(aa))

with open("throat2.geojson", "w") as output:
    output.write(gj_throat)

### check plot

pZones(standPet, standSpot, center, edge, throat)

##### write out iterations ######### 

os.mkdir("") ## make home for geojsons
os.chdir("") ## go there



## seems to work

## can we collect all this into a geo collection, export 
## as geo json?


## nah. Let's reduce the nesting for the moment.



os.chdir("/home/daniel/Desktop")



## construct feature collection geojson


featC = {
        "type" : "FeatureCollection",
        "features" : [],
        } 

partNames = ['Petal', 'Spots', 'Center', 'Edge', 'Throat']

for i,part in enumerate([standPet, standSpot, center, edge, throat]):
    gj_i = sg.mapping(part)
    feature_i = {"type": "Feature",
          "geometry": gj_i,
          "properties": {"id":(partNames[i])}}
    featC['features'].append(feature_i)


with open('jsonDumpResult.json', 'w') as fp:
    json.dump(featC, fp)



## does this parse well back into shapely?

with open('jsonDumpResult.geojson') as gjf:
    aa = json.load(gjf)


len(aa['features'])


bb = sg.shape(aa)

for i in range(5):
    aa['features'][i].keys()

bb = sg.shape(aa['features'][0]['geometry']) ## works, but we need to retain names


aa['features'][0]['properties']['id']


## so get a list of geometries:

listP = (aa['features'])

## find the one that has petal outline:

bb = [ i for i in listP if i['properties']['id'] == 'Petal' ]

cc = bb[0]['geometry']

dd = sg.shape(cc)

## did this work?

fig, ax1 = plt.subplots()
x, y = dd.exterior.xy
ax1.fill(x, y, 'b')

## yup. so a general function for parsing this geojson:


with open('jsonDumpResult.geojson') as gjf:
    aa = json.load(gjf)

listP = (aa['features'])

## find the one that has petal outline:

bb = [ i for i in listP if i['properties']['id'] == 'Petal' ]

cc = bb[0]['geometry']

dd = sg.shape(cc)

## did this work?


########### geojson parse ###############3

## yup. so build a general function for parsing this geojson:

file="P400F2_right_polys.geojson"

with open(file) as gjf:
    spotsGJ = [ i for i in listP if i['properties']['id'] == 'Spots' ][0]['geometry'] 

    spotsPoly = sg.shape(spotsGJ)

#def parseGeoj(file):
    #with open(file) as gjf:

file="P400F2_right_polys.geojson"
with open(file) as gjf:
    aa = json.load(gjf)
    listP = (aa['features'])
    petalGJ = [ i for i in listP if i['properties']['id'] == 'Petal' ][0]['geometry'] 
    petalPoly = sg.shape(petalGJ)
    spotsGJ = [ i for i in listP if i['properties']['id'] == 'Spots' ][0]['geometry'] 
    spotsPoly = sg.shape(spotsGJ)
    print('made it here')
    centerGJ = [ i for i in listP if i['properties']['id'] == 'Center' ][0]['geometry'] 
    centerPoly = sg.shape(centerGJ)
    edgeGJ = [ i for i in listP if i['properties']['id'] == 'Edge' ][0]['geometry'] 
    edgePoly = sg.shape(edgeGJ)
    throatGJ = [ i for i in listP if i['properties']['id'] == 'Throat' ][0]['geometry'] 
    throatPoly = sg.shape(throatGJ)

   return(petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly)




## oops. looks like we need to clean up the edges, too..

## okay, debugging pile too big. Cleanup.

## modify the module so that it should spit out 
## geojsons. 

## try it, check results as above, see if more 
## debugging is needed.

## then add parsing to notebook


## try out the new script:

ff="/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons/P400F2/right"
dd="/home/daniel/Documents/mimulusSpeckling/make_polygons/tryscript"
./get_pols.py $ff 0.5 $dd

## failed...
## shapely.errors.TopologicalError

## start over....


import argparse, os, pickle, json, pprint
import numpy as np
import matplotlib.pyplot as plt
import shapely.geometry as sg
import shapely.affinity as sa
import shapely.errors
from skimage import measure
from descartes import PolygonPatch
from get_pols import *

## script minus the functions is:

folder="/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons/P400F2/right"
centerSize=0.5
destination="/home/daniel/Documents/mimulusSpeckling/make_polygons/tryscript" 

## run through digitizing, standardizing, zone calling pipeline
os.chdir(folder)
aa = os.listdir()
for i in aa:
    if "petal" in i:
        petPol = digitizePols(i)[0]
    elif "spots" in i:
        spotPol = digitizePols(i)


scale, cent = getPetGeoInfo(petPol)
standPet = stand(petPol, scale, cent)
standSpot = [ stand(i, scale, cent) for i in spotPol ]


try:

center, edge, throat = findZones(standPet, centerSize, 0.07)

except shapely.errors.TopologicalError as x:
    print("zones won't be available")
    center = edge = throat = {"type": "Polygon", "coordinates": []}

def findZones(standPol, percent, simp=0.05):

standPol=standPet
percent = 0.5
simp=0.05

center = standPol
rad = 0
while center.area > percent:
    center = standPol.buffer(rad)
    rad -= .001
marg = sg.polygon.Polygon(
        standPol.exterior,
        holes = [center.exterior.coords])
simPol = marg.simplify(simp)
simPolA = np.array(simPol.exterior.xy).transpose()
simPolAsorted = simPolA[simPolA[:,1].argsort()[::-1]]
outCorners = simPolAsorted[0:2]
simPolB = np.array(simPol.interiors[0].xy).transpose()
simPolBsorted = simPolB[simPolB[:,1].argsort()[::-1]]
inCorners = simPolBsorted[0:2,]
inCorners = np.flipud(inCorners)
tRap = np.concatenate((outCorners,inCorners))
tRapPoly = sg.polygon.Polygon(tRap)
tBuff = tRapPoly.buffer(0.1)

noTrap = marg.difference(tRapPoly)


notInTrap = [ i for i in noTrap if i.within(tBuff) ]
mpNotInTrap = sg.multipolygon.MultiPolygon(notInTrap)
margInTrap = tRapPoly.intersection(marg)
throatRaw = margInTrap.union(mpNotInTrap )
throat = cleanCollections(throatRaw)
edgeRaw = marg.difference(throat)
edge = cleanCollections(edgeRaw)
#    return(center, edge, throat)


##########

fig, ax1 = plt.subplots(ncols=1)
x, y = standPet.exterior.xy
ax1.fill(x, y, "y")
x, y = tRapPoly.exterior.xy
ax1.fill(x, y, "b")

x, y = standSpot[1].exterior.xy
ax1.fill(x, y, "r")


##########

## organize name
here = os.getcwd()
petalName = os.path.basename(here)
flowerName = os.path.basename(os.path.dirname(here))
gjName = (flowerName + "_"
          + petalName
          + "_polys")
outFileName = ( destination + "/"
                + flowerName + "_"
                + petalName
                + "_polys.geojson")

## outputs

## define get a dictionary that resembles a geojson feature collection:
featC = {
        "type" : "FeatureCollection",
        "features" : [],
        }

## fill it with features
partNames = ['Petal', 'Spots', 'Center', 'Edge', 'Throat']
## each geometry needs a feature wrapper
for i,part in enumerate([standPet, standSpot, center, edge, throat]):
    gj_i = sg.mapping(part)
    feature_i = {"type": "Feature",
          "geometry": gj_i,
          "properties": {"id":(partNames[i])}}
    featC['features'].append(feature_i)

aa = sg.mapping(standSpot)

bb = shapely.geometry.multipolygon.MultiPolygon(standSpot)

aa = sg.mapping(bb)

## write it out
with open(outFileName, 'w') as fp:
    json.dump(featC, fp)

###############33

Petal, Spots, Center, Edge, Throat = parseGeoj('P400F2_right_polys.geojson')

parseGeoj('P400F2_right_polys.geojson')

## so where were we? 

## we need our geoj parser to work, so we can make our 
## odf. 

## and we need our base digitization script to 
## work smoothly

## can't get it perfect right now, lots of exception handles

## cuz they probably don't want me spending another month 
## on this... 


## okay - can we run this script on all our folders?


## where do we want these files? 

## next step is a pdf that shows how they worked.

## do we want to 


## bash script - make our digitizations, for all polygons

##########################################
#!/usr/bin/env bash

getpols='/home/daniel/Documents/mimulusSpeckling/make_polygons/get_pols.py'
wd='/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons'

cd $wd

for i in *; do
    echo $i 
    cd $i 
    for j in *; do
        fullN=$PWD/$j
        $getpols $fullN 0.5 $fullN
    done
    cd ../
done

##################################################

## to run it
bash runAllDigs.sh |& tee runAllDigsLog.txt

ls -R /home/daniel/Documents/mimulusSpeckling/make_polygons/polygons/P247F1

cd /home/daniel/Documents/mimulusSpeckling/make_polygons/polygons/P247F1/left

## so that's running...

## how do we check the results?

## we probably want something like last time

## let's try one in matplotlib:

python3

import argparse, os, json, pprint
import numpy as np
import matplotlib.pyplot as plt
import shapely.geometry as sg
import shapely.affinity as sa
from skimage import measure
from descartes import PolygonPatch

## how do we plot a jpeg?

## let's use our very first petal as an example:



## we gotta fix our geojson parser:

## may god and stackoverflow forgive me




def parseGeoj(file):
    with open(file) as gjf:
        aa = json.load(gjf)
        listP = (aa['features'])
        try:
            petalGJ = [ i for i in listP if i['properties']['id'] == 'Petal' ][0]['geometry'] 
            petalPoly = sg.shape(petalGJ)
        except:
            petalPoly = sg.polygon.Polygon()
        try:
            spotsGJ = [ i for i in listP if i['properties']['id'] == 'Spots' ][0]['geometry'] 
            spotsPoly = sg.shape(spotsGJ)
        except:
            spotsPoly = sg.polygon.Polygon()
        try:
            centerGJ = [ i for i in listP if i['properties']['id'] == 'Center' ][0]['geometry'] 
            centerPoly = sg.shape(centerGJ)
        except:
            centerPoly = sg.polygon.Polygon()
        try:
            edgeGJ = [ i for i in listP if i['properties']['id'] == 'Edge' ][0]['geometry'] 
            edgePoly = sg.shape(edgeGJ)
        except:
            edgePoly = sg.polygon.Polygon()
        try:
            throatGJ = [ i for i in listP if i['properties']['id'] == 'Throat' ][0]['geometry'] 
            throatPoly = sg.shape(throatGJ)
        except:
            throatPoly = sg.polygon.Polygon()
    return(petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly)


## our first flower:

file="P247F1_left_polys.geojson"

os.chdir('/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons/P247F1/left')

petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly = parseGeoj(file)

## does this work?

alp=0.5
l=5




fig, ax1 = plt.subplots()

x, y = petalPoly.exterior.xy
ax1.fill(x, y, "y", alpha=1.0)

for i in spotsPoly:
    x, y = i.exterior.xy
    ax1.fill(x, y, "r")

x, y = centerPoly.exterior.xy
ax1.fill(x, y, "w", alpha=0.3)
x, y = edgePoly.exterior.xy
ax1.fill(x, y, "o", alpha=0.3)
x, y = throatPoly.exterior.xy
ax1.fill(x, y, "b", alpha=0.3)

## looks okay, but I think we're better off with the 
## graphing function in our notebook.

## think we need another script for this.
import os, json 
import numpy as np
import shapely.geometry as sg
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from descartes import PolygonPatch

## first, get matplot a jpeg to print. 

## gonna have to get this off doug's directory:

dougDir='/home/daniel/Documents/mimulusSpeckling/dougRaster/Rotated_and_Cropped'
os.chdir(dougDir)
aa = os.listdir()
bb = [ i for i in aa if 'JPG' in i]


## our first row is a plot using one of these jpegs:
i=0
imgFullName=(dougDir + '/' + bb[i])
ax1 = plt.subplot2grid((4,3), (0,0), colspan=3)
img=mpimg.imread(imgFullName)
ax1.imshow(img)

## sorta works. second row is doug's rasters of the leaves
## these are in our polygon folders. How can we find this?

cc = bb[0][0:-4] ##flower name
polDir='/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons'

os.chdir(polDir + "/" + cc)

fp = os.listdir()

for i in fp:
    os.chdir(i)
    spotsCSV = [ i for i in os.listdir() if 'spots' in i ][0]
    petalCSV = [ i for i in os.listdir() if 'petal' in i ][0]
    geoj = [ i for i in os.listdir() if 'geojson' in i ][0]
    petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly = parseGeoj(geoj)
    ## insert print page
    os.chdir(polDir + "/" + cc)





## we want a side=by-side of our rasters. can we read them  and plot them?

## how to read these in...

#petalCSV=('P402F1_left_petal.csv')
#spotsCSV=('P402F1_left_spots.csv')

petalMat = np.genfromtxt(petalCSV, delimiter=',')

plt.imshow(petalMat, cmap='gray')

spotsMat = np.genfromtxt(spotsCSV, delimiter=',')
plt.imshow(spotMat, cmap='gray')

## pretty simple
## maybe a row of six images, side-by-sides of all three petals

##########################


## polygons
## these we get from the geojsons, using our parsing function. 
## need one from each directory


## plotting function? We want a row without zones:

def plotNoZone(petalPoly, spotsPoly, x, y):
    alp=1.0
    l=2
    ax1 = plt.subplot2grid((4, 3), (x, y), colspan=1)
    ax1.set_aspect('equal')
    ax1.set_xlim(min(petalPoly.exterior.xy[0]), max(petalPoly.exterior.xy[0]))
    ax1.set_ylim(min(petalPoly.exterior.xy[1]), max(petalPoly.exterior.xy[1]))
    ax1.add_patch(PolygonPatch(petalPoly,
                  fc='yellow', ec='black',
                  linewidth=l, alpha=alp))
    ax1.add_patch(PolygonPatch(spotsPoly,
                  fc='red', ec='black',
                  linewidth=l, alpha=alp))


plotNozone(petalPoly, spotsPoly)

## works

##############


## okay, with zones?

def plotYesZone (petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly, x ,y):
    alp=0.3
    l=2
    ax1 = plt.subplot2grid((4, 3), (x, y), colspan=1)
    ax1.set_xlim(min(petalPoly.exterior.xy[0]), max(petalPoly.exterior.xy[0]))
    ax1.set_ylim(min(petalPoly.exterior.xy[1]), max(petalPoly.exterior.xy[1]))
    ax1.set_aspect('equal')
    ax1.add_patch(PolygonPatch(petalPoly,
                  fc='yellow', ec='black',
                  linewidth=l, alpha=1.0))
    ax1.add_patch(PolygonPatch(spotsPoly,
                  fc='red', ec='black',
                  linewidth=l, alpha=1.0))
    ax1.add_patch(PolygonPatch(centerPoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    ax1.add_patch(PolygonPatch(edgePoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    ax1.add_patch(PolygonPatch(throatPoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))


plotYesZone(petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly, 0,0)


#####################

## okay, that's everything, right?

## first row is jpg
## second row is doug's rasters
## third row is petal and spots
## fourth row is zones


## can we make a page with these?

## makePDFs.py
#########################################################
#!usr/bin//env python3

import os, json 
import numpy as np
import shapely.geometry as sg
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from descartes import PolygonPatch

def parseGeoj(file):
    with open(file) as gjf:
        aa = json.load(gjf)
        listP = (aa['features'])
        try:
            petalGJ = [ i for i in listP if i['properties']['id'] == 'Petal' ][0]['geometry'] 
            petalPoly = sg.shape(petalGJ)
        except:
            petalPoly = sg.polygon.Polygon()
        try:
            spotsGJ = [ i for i in listP if i['properties']['id'] == 'Spots' ][0]['geometry'] 
            spotsPoly = sg.shape(spotsGJ)
        except:
            spotsPoly = sg.polygon.Polygon()
        try:
            centerGJ = [ i for i in listP if i['properties']['id'] == 'Center' ][0]['geometry'] 
            centerPoly = sg.shape(centerGJ)
        except:
            centerPoly = sg.polygon.Polygon()
        try:
            edgeGJ = [ i for i in listP if i['properties']['id'] == 'Edge' ][0]['geometry'] 
            edgePoly = sg.shape(edgeGJ)
        except:
            edgePoly = sg.polygon.Polygon()
        try:
            throatGJ = [ i for i in listP if i['properties']['id'] == 'Throat' ][0]['geometry'] 
            throatPoly = sg.shape(throatGJ)
        except:
            throatPoly = sg.polygon.Polygon()
    return(petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly)

def plotNoZone(petalPoly, spotsPoly, x, y):
    alp=1.0
    l=2
    ax1 = plt.subplot2grid((4, 3), (x, y), colspan=1)
    ax1.set_aspect('equal')
    ax1.set_xlim(min(petalPoly.exterior.xy[0]), max(petalPoly.exterior.xy[0]))
    ax1.set_ylim(min(petalPoly.exterior.xy[1]), max(petalPoly.exterior.xy[1]))
    ax1.add_patch(PolygonPatch(petalPoly,
                  fc='yellow', ec='black',
                  linewidth=l, alpha=alp))
    ax1.add_patch(PolygonPatch(spotsPoly,
                  fc='red', ec='black',
                  linewidth=l, alpha=alp))

def plotYesZone (petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly, x ,y):
    alp=0.3
    l=2
    ax1 = plt.subplot2grid((4, 3), (x, y), colspan=1)
    ax1.set_xlim(min(petalPoly.exterior.xy[0]), max(petalPoly.exterior.xy[0]))
    ax1.set_ylim(min(petalPoly.exterior.xy[1]), max(petalPoly.exterior.xy[1]))
    ax1.set_aspect('equal')
    ax1.add_patch(PolygonPatch(petalPoly,
                  fc='yellow', ec='black',
                  linewidth=l, alpha=1.0))
    ax1.add_patch(PolygonPatch(spotsPoly,
                  fc='red', ec='black',
                  linewidth=l, alpha=1.0))
    ax1.add_patch(PolygonPatch(centerPoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    ax1.add_patch(PolygonPatch(edgePoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    ax1.add_patch(PolygonPatch(throatPoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))

## make these into command line args?
polDir='/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons'
dougDir='/home/daniel/Documents/mimulusSpeckling/dougRaster/Rotated_and_Cropped'
targetDir='/home/daniel/Documents/mimulusSpeckling/make_polygons/bigPDF/testNew'

os.chdir(dougDir)
aa = os.listdir()
bb = [ i for i in aa if 'JPG' in i]

for flowerJpg in bb:
    print(flowerJpg)


for flowerJpg in bb:
    flowerName = flowerJpg[0:-4] ##flower name
    fig = plt.figure()
    fig.suptitle(flowerName, fontsize=12)
    ## our first row is a plot using one of these jpegs:
    imgFullName=(dougDir + '/' + flowerJpg)
    ax1 = plt.subplot2grid((4,3), (0,0), colspan=3)
    img=mpimg.imread(imgFullName)
    ax1.imshow(img)
    ## second row is Doug's rasters
    os.chdir(polDir + "/" + flowerName) ## go to flower directory
    counter = 0 ## for keeping track of the 6 plots, second row
    for n,j in enumerate(['left', 'mid', 'right']):
        os.chdir(j)
        print("We are on " + j)
        spotsCSV = [ i for i in os.listdir() if 'spots' in i ][0]
        petalCSV = [ i for i in os.listdir() if 'petal' in i ][0]
        ## get rasters as CSVs
        petalMat = np.genfromtxt(petalCSV, delimiter=',')
        spotsMat = np.genfromtxt(spotsCSV, delimiter=',')
        ## plot these two rasters, petal outline and spots
        ax = plt.subplot2grid((4,6), (1, counter))
        ax.imshow(petalMat, cmap='gray')
        counter += 1
        ax = plt.subplot2grid((4,6), (1, counter))
        ax.imshow(spotsMat, cmap='gray')
        counter += 1
        ## get geojsons, turn them into polygons
        geoj = [ i for i in os.listdir() if 'geojson' in i ][0]
        print('current directory is:' + os.getcwd())
        petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly = parseGeoj(geoj)
        ## row 3 plot petal and spot geojsons
        plotNoZone(petalPoly, spotsPoly, 2, n)
        ## row 4 plot these with zones, if we have them:
        try:
                plotYesZone(petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly, 3, n)
        except: 
            ax=plt.subplot2grid((4,3),(3,n)) ## blank
        os.chdir(polDir + "/" + flowerName) ## go back to flower directory
    os.chdir(dougDir)

        plt.savefig



fig = plt.figure()

ax=plt.subplot2grid((4,3),(3,n))

ax1 = plt.subplot2grid((4, 3), (x, y), colspan=1)

petalPoly.is_empty
spotsPoly[0].is_empty
centerPoly.is_empty
edgePoly.is_empty
throatPoly.is_empty

##############

## can we make a big pdf out of these?


targetDir='/home/daniel/Documents/mimulusSpeckling/make_polygons/bigPDF/testNew'

cd $targetDir


pdftk $(echo * | sort) cat output digitizeBigPDF.10.08.2018.pdf

## okay, but text not searchable...


import os, json 
import numpy as np
import shapely.geometry as sg
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from descartes import PolygonPatch
from makePDFs import parseGeoj

## on the cases where there are no spots but all the petal 
## plots as a spot, is this real? Is this what dougs rasters
## say?

## P439F1 left and mid did this. Check them out:

wd='/home/daniel/Documents/mimulusSpeckling/make_polygons'
polDir='/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons'
dougDir='/home/daniel/Documents/mimulusSpeckling/dougRaster/Rotated_and_Cropped'
targetDir='/home/daniel/Documents/mimulusSpeckling/make_polygons/bigPDF/testNew'
#flowerName='P439F1'
flowerName='P430F1'

os.chdir(dougDir)

os.chdir(polDir + "/" + flowerName + "/" + 'left')

#show doug's images:

plt.ion()

spotsCSV = [ i for i in os.listdir() if 'spots' in i ][0]
petalCSV = [ i for i in os.listdir() if 'petal' in i ][0]
petalMat = np.genfromtxt(petalCSV, delimiter=',')
spotsMat = np.genfromtxt(spotsCSV, delimiter=',')

fig = plt.figure()
ax = plt.axes()
ax.imshow(petalMat, cmap='gray')

fig = plt.figure()
ax = plt.axes()
ax.imshow(spotsMat, cmap='gray')

## looks real...

## check one more:



## lots to do -

## get stats 
## update nb
## organize files - get geojsons where folks can use them


## ugh, gotta fix git. Some random large temp file is gumming
## things up

## not sure how this works, but here's a suggestion from stackoverflow
git filter-branch --index-filter 'git rm -r --cached --ignore-unmatch make_polygons/bigPDF/PolyPipeline_140818.pdf.part' HEAD


## worked,  can we do the merge?


##############################


## polygons traits. 

## we have a list of ~20 traits

## the goal is code all of them for one petal. 

## then automate to all three petals

## then automate to all flowers. 

## Melia asks that we then average flowers from
## the same plant together in all cases.

## to plot geojson:
def plotYesZone (petalPoly, spotsPoly, centerPoly, edgePoly, throatPoly):
    alp=0.3
    l=2
    fig = plt.figure()
    ax1 = plt.axes()
    ax1.set_xlim(min(petalPoly.exterior.xy[0]), max(petalPoly.exterior.xy[0]))
    ax1.set_ylim(min(petalPoly.exterior.xy[1]), max(petalPoly.exterior.xy[1]))
    ax1.set_aspect('equal')
    ax1.add_patch(PolygonPatch(petalPoly,
                  fc='yellow', ec='black',
                  linewidth=l, alpha=1.0))
    try:
        ax1.add_patch(PolygonPatch(spotsPoly,
                      fc='red', ec='black',
                      linewidth=l, alpha=1.0))
    except:
        ax1.set_xlabel('No spots detected')
    ax1.add_patch(PolygonPatch(centerPoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    ax1.add_patch(PolygonPatch(edgePoly,
                  fc='white', ec='black',
                  linewidth=l, alpha=alp))
    try:
        ax1.add_patch(PolygonPatch(throatPoly,
                      fc='white', ec='black',
                      linewidth=l, alpha=alp))
    except:
        ax1.set_xlabel('throat and edges failed')


## our example petal:
## 297F2
## "right" lower petal

import os, json 
import numpy as np
import shapely.geometry as sg
import shapely.ops as so
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import pandas as pd
from descartes import PolygonPatch
from makePDFs import parseGeoj
from statistics import mean
from shapely.validation import explain_validity



## load the polygons:

wd='/home/daniel/Documents/mimulusSpeckling/make_polygons'
polyDir='/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons'
flowerName='P297F2'
petalName='right'
flpetDir= (polyDir + "/" + flowerName + "/" + petalName)
gjName = [ i for i in os.listdir(flpetDir) if "geojson" in i ][0]
petal, spots, center, edge, throat = parseGeoj(flpetDir + "/" + gjName)

## cleanup polys

edge = edge.buffer(0.0) 
aa = list(spots)
aa[1] = aa[1].buffer(0.0)
spots = sg.MultiPolygon(aa)

plt.ion()

plotYesZone(petal, spots, center, edge, throat)

## let's play with edges:

## this would be a loop through the spots to see
## which spots are "within","intersecting", or have "more than 50% intersecting"
 
## spots contained in center zone

spots.intersects(edge)

def plotOne(poly, l=2, a=1.0, col='yellow'):
    fig = plt.figure()
    ax1 = plt.axes()
    ax1.set_xlim(min(poly.exterior.xy[0]), max(poly.exterior.xy[0]))
    ax1.set_ylim(min(poly.exterior.xy[1]), max(poly.exterior.xy[1]))
    ax1.set_aspect('equal')
    ax1.add_patch(PolygonPatch(poly,
                  fc=col, ec='black',
                  linewidth=l, alpha=a))

plotOne(edge)

def addOne(poly, l=2, a=1.0, col='red'):
    ax1 = plt.axes()
    ax1.add_patch(PolygonPatch(poly,
                  fc=col, ec='black',
                  linewidth=l, alpha=a))

plotOne(edge)
addOne(spots, a=0.5)

## gotta check our polys, are they valid?


explain_validity(edge)

## self intersection. Can we buff it out?

aa = edge.buffer(0.0) 
aa.buffer(0.0).is_valid ## says its okay. 

## check plot:

edge = edge.buffer(0.0) 
edge.is_valid

plotOne(edge)

## do this for all polygons, make a function
## looks okay. Onward:

for i,j in enumerate(spots):
    print(i)
    j.intersects(edge)

## problem with second polygon:
spots[1].is_valid ## nope

plotOne(spots[1]) ## looks okay, what's wrong?

explain_validity(spots[1]) ## another self intersect. Buff it?

spots[1].buffer(0.0).is_valid ## looks okay

spots[1] = spots[1].buffer(0.0) ## doesn't work. 

## build new multipoly?

aa = list(spots)
aa[1] = aa[1].buffer(0.0)
spots = sg.MultiPolygon(aa)

[ i.intersects(edge) for i in spots ]

sum([ i.intersects(edge) for i in spots ]) / len(spots)

## that's cool, but wouldn't area be more informative?

## in case artificial lumping of spots occurred?

type(spots[0].intersection(edge))


aa = spots[0].intersection(edge)


aa.area
 
## seems okay. To get all the intersections:

partSpotsInEdge = [ i.intersection(edge) for i in spots ]

## does this look right?
partSpotsInEdge


##  why all the weird objects in this?

partSpotsInEdge[0].area

plotOne(edge)

addOne(partSpotsInEdge[0]) ## good
addOne(partSpotsInEdge[1]) ## good

addOne(partSpotsInEdge[2]) ## nope

partSpotsInEdge[2].area

partSpotsInEdge[2].is_empty


[ i.is_empty for i in partSpotsInEdge ]

[ type(i) for i in partSpotsInEdge ]

## so whereever a collection happened, empty

## and what about the multis?

partSpotsInEdge[5]


plotOne(edge)

[ addOne(i, a=0.5, col='blue') for i in partSpotsInEdge[5] ]

[ plotOne(i, a=0.5, col='blue') for i in partSpotsInEdge[5] ]

plotOne(partSpotsInEdge[5][0])

addOne(partSpotsInEdge[5][1])

addOne(spots, a=0.2)

## so they're legit. can we extract them, bring them to same
## level of nestedness?

list(partSpotsInEdge[5])

## back to the beginning, add conditional to keep out the empties
partSpotsInEdge = [ i.intersection(edge) for i in spots if i.intersects(edge) ]
## make a list of lists, even of single polygons
listz = [ list(i) if type(i) == sg.multipolygon.MultiPolygon else [i] for i in partSpotsInEdge ]
unNest = sum(listz, []) ## seems to work... not sure why...
## bring it back
partSpotsInEdge =  sg.multipolygon.MultiPolygon(unNest)
partSpotsInEdgeArea = sum([ i.area for i in partSpotsInEdge ])

plotOne(edge)
[ addOne(i, a=0.3) for i in spots ] 
[ addOne(i, col='blue') for i in partSpotsInEdge ] 

## okay, this can be used to find percent of edge covered by spots
## and percent of spot area in the edge:

## % edge covered by spots =

partSpotsInEdge

partSpotsInEdgeArea 

edgeCoveredbySpots = partSpotsInEdgeArea / edge.area  ## in this case, 0.26

## % spot area in the edge:

propSpotsInEdge = partSpotsInEdgeArea / spots.area  ## in this case, 0.39

## number of spots touching edge zone in some way

nuSpotsTouchEdge = len(partSpotsInEdge)

## how can tell how much of the actual edge has spot on it?

## get the exterior of the petal as a linestring

## make sure petal is valid:
petal.is_valid ## nope
## fix if possible:
petal = petal.buffer(0.0)
petal.is_valid ## yup

def plotLine(lin):
    ax1 = plt.axes()
    ax1.plot(lin.xy[0],lin.xy[1])

## so maybe:

shared = spots[1].intersection(petal.exterior)

#### nuSpotsTouchActualEdge

## to get the number of spots that contact the actual (not zone) edge:

nuSpotsTouchActualEdge = sum([ i.intersects(petal.exterior) for i in partSpotsInEdge ])


#### realEdgeSpotted

## to get the actual (not zone) edge that is covered by spots:

spotEdges = sum([ i.intersection(petal.exterior).length for i in partSpotsInEdge ])

realEdgeSpotted = spotEdges / petal.exterior.length ## 22% of petal edge is covered by spots

[ i.intersection(petal.exterior).length for i in partSpotsInEdge ]

#### how do get the distance from all spots to 

## do we want edge to edge, or centroid to edge of the polygon. 

## for one spot

plotOne(petal)
[ addOne(i) for i in spots ]

plotOne(petal)
[ addOne(i) for i in partSpotsInEdge ]

## to get the distance from edge of spot to edge of petal?

[ petal.exterior.distance(i) for i in spots if i.intersects(throat) ]

petal.exterior.distance(spots[0])

edge.exterior.distance(spots[0])

plotOne(petal)
[ addOne(i) for i in partSpotsInEdge ]


[ i.intersects(edge) for i in spots ]

## if throat worked, can we get a lower edge of the petal?
flowerCut = throat.intersection(petal.exterior)
notTube = [ i for i in spots if not i.intersects(flowerCut)] 
## works but depends of throat, will need to try

def plotLine(lin):
    ax1 = plt.axes()
    ax1.plot(lin.xy[0],lin.xy[1])

plotOne(petal)
addOne(throat)
[ plotLine(i) for i in flowerCut ]

## so how can we use this? 

plotOne(petal)
[ addOne(i) for i in notTube ]

plotOne(petal)
[ addOne(i) for i in spots ]

## use this subset

avgDistSpotEdgeEdge = mean([ petal.exterior.distance(i) for i in notTube ])

avgDistSpotEdge2Edge 

## can we do this with centroids?

avgDistSpotCentroid2Edge = [ petal.exterior.distance(i.centroid) for i in notTube ]

avgDistSpotCentroid2Edge


## so, can we get just the spots that are mostly in the edge?


len([ i for i in spots if i.intersects(edge) ])

spotsMostlyInEdge = [ i for i in spots if (i.intersection(edge).area / i.area > 0.5) ]

nuSpotsMostlyInEdge = len(spotsMostlyInEdge)

plotOne(petal)
[ addOne(i) for i in spotsMostlyInEdge ]

nuSpotsMostlyInEdge

## looks okay

## spots entirely in the edge:

spotsContainedInEdge = sum([ i.within(edge) for i in spots ])

[ i.within(edge) for i in spots ]

edge.is_valid

#################
## centeredness 

#### spotsContainedInCenter
# spots entirely contained in center zone

## if all polys are valid:

## find all spots entirely in center using within()

[ i.within(center) for i in spots ]

plotOne(petal)
addOne(center, col='orange')
[ addOne(i,  a=0.3) for i in spots ]

## none, this is a pretty strict measure and doesn't
## give us much for error in spots that got 
## merged in the image pipeline

nuSpotsContainedInCenter = sum([ i.within(center) for i in spots ])

##### nuSpotsTouchCenter

## spots touching the centerzone:

nuSpotsTouchCenter = sum([ i.intersects(center) for i in spots ])

###### nuSpotsMostlyInCenter 

## spots mostly in the centerzone:

spotsMostlyInCenter = [ i for i in spots if (i.intersection(center).area / i.area > 0.5) ]

nuSpotsMostlyInCenter = len(spotsMostlyInCenter)

plotOne(petal)
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i) for i in spotsMostlyInCenter ]
addOne(center, col='orange', a=0.3)

## looks okay.

#### nuSpotCentroidsInCenter

spotCentroidsInCenter = [ i for i in spots if (i.centroid.intersects(center)) ] 

nuSpotCentroidsInCenter = sum([ i.centroid.intersects(center) for i in spots ] )

plotOne(petal)
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i) for i in spotCentroidsInCenter ]
addOne(center, col='orange', a=0.3)
ax1 = plt.gca()
[ ax1.plot(i.centroid.x, i.centroid.y, "+", ms = 10) for i in spotCentroidsInCenter ]

## looks okay. 

#### avgDist2CenterAllSpots

## we'll use centroids of spots, dist to petal centroid:

[ i.centroid.distance(center.centroid) for i in spots ]

avgDist2CenterAllSpots = mean([ i.centroid.distance(center.centroid) for i in spots ])


#### avgDist2CenterCenterSpots

spotsMostlyInCenter = [ i for i in spots if (i.intersection(center).area / i.area > 0.5) ]

avgDist2CenterCenterSpots = mean([ i.centroid.distance(center.centroid) for i in spotsMostlyInCenter ])

avgDist2CenterCenterSpots

#### centerCoveredbySpots 

partSpotsInCenter = [ i.intersection(center) for i in spots if i.intersects(center) ]
## okay, but in case this divides up a spot and creates a multipolygon:
## make a list of lists, even of single polygons
listz = [ list(i) if type(i) == sg.multipolygon.MultiPolygon else [i] for i in partSpotsInCenter ]
unNest = sum(listz, []) ## seems to work... not sure why...
## bring it back
partSpotsInCenter =  sg.multipolygon.MultiPolygon(unNest)

partSpotsInCenterArea = partSpotsInCenter.area

## and the money stat
centerCoveredbySpots = partSpotsInCenterArea / center.area  ## in this case, 0.26

plotOne(petal)
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i) for i in partSpotsInCenter ]
addOne(center, col='orange', a=0.3)
## looks good...

#### propSpotsInCenter

## the above is how much of our center area is covered by 
## spots.

## but what percentage of our spotted area lies in the 
## center?

partSpotsInCenter 

partSpotsInCenterArea

propSpotsInCenter = partSpotsInCenterArea / spots.area  

## seems to work.

#### spotOnCentroid

## is there a spot on the centroid of the petal? just true/false:

spotOnCentroid = any([ i.intersects(petal.centroid) for i in spots ])


############# throat ############

#### propSpotsInThroat

partSpotsInThroat = [ i.intersection(throat) for i in spots if i.intersects(throat) ]
## okay, but in case this divides up a spot and creates a multipolygon:
## make a list of lists, even of single polygons
listz = [ list(i) if type(i) == sg.multipolygon.MultiPolygon else [i] for i in partSpotsInThroat ]
unNest = sum(listz, []) ## seems to work... not sure why...
## bring it back
partSpotsInThroat =  sg.multipolygon.MultiPolygon(unNest)

propSpotsInThroat = partSpotsInThroat.area / spots.area  

plotOne(petal)
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i) for i in partSpotsInThroat ]
addOne(throat, col='orange', a=0.3)

#### throatCoveredbySpots

throatCoveredbySpots = partSpotsInThroat.area / throat.area  

throatCoveredbySpots 

#### nuSpotsTouchThroat

spotsTouchThroat = [ i.intersects(throat) for i in spots ]

nuSpotsTouchThroat = sum(spotsTouchThroat)

plotOne(petal)
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i) for i in spots if i.intersects(throat) ]
addOne(throat, col='orange', a=0.3)

#### nuSpotsMostlyInThroat

nuSpotsMostlyInThroat

spotsMostlyInThroat = [ i for i in spots if (i.intersection(throat).area / i.area > 0.5) ]

plotOne(petal)
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i) for i in spotsMostlyInThroat ]
addOne(throat, col='orange', a=0.3)

## looks good. 

#### nuSpotsTouchCut

## how do we find the spots that acutally touch the base of the petal?

spotsOnCut = [ i for i in partSpotsInThroat if i.intersects(petal.exterior) ]

nuSpotsTouchCut = len(spotsOnCut)

plotOne(petal)
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i) for i in partSpotsInThroat ]
[ addOne(i, col='green') for i in spotsOnCut ]
addOne(throat, col='orange', a=0.3)

############# general polygon stats #################

#### biggestSpotArea

## this is probably not gong to be useful till
## we clean up the spot polygons.

## how to find the largest spot...

biggestSpotArea = max([ i.area for i in spots ])

## don't need this but to ID the polygon:

biggestSpot = [ i for i in spots if i.area == bigSpotArea ] 

#### smallestSpotArea

## not sure why to do this, but here we go:

smallestSpotArea = min([ i.area for i in spots ])

### avgSpotSize
avgSpotSize = mean([ i.area for i in spots ])

avgSpotSize

### medSpotSize
medSpotSize = np.median([ i.area for i in spots ])

medSpotSize

[ i.area for i in spots ]

#### nuSpots

nuSpots = len([ i.area for i in spots ])


################## quadrants ####################

## let's run through one quadrant. We should be able
## to get a nice function for this:

###### quad I ######

#### nuQuadISpots 
## in quad I, centroids need to be positive both X and y:

[ i for i in spots if i.centroid.x > 0 and i.centroid.y > 0 ]
quadIspots = [ i for i in spots if i.centroid.x > 0 and i.centroid.y > 0 ]
nuQuadISpots = len(quadIspots)

#### quadICoveredbySpots & propSpotsInQuadI

## make a box for quadI: 
quadIbox=sg.box(0,0,1,1)
## get the area of our petal in this box:
petalQuadI = petal.intersection(quadIbox)
## get the area of spots that fall into this 
spottedSurfaceQuadI = spots.intersection(petalQuadI)
quadICoveredbySpots = spottedSurfaceQuadI.area / petalQuadI.area
propSpotsInQuadI = spottedSurfaceQuadI.area / spots.area


###### Quad II ###### 

#### nuQuadIISpots 
## in quad II, centroids need to be positive on y-axis and neg on x-axis

[ i for i in spots if i.centroid.x > 0 and i.centroid.y > 0 ]
quadIIspots = [ i for i in spots if i.centroid.x < 0 and i.centroid.y > 0 ]
nuQuadIISpots = len(quadIIspots)

#### quadIICoveredbySpots & propSpotsInQuadII
## spotted surface in quadII / total area of spots 

## make a box for quadII: 
quadIIbox=sg.box(0,0,-1,1)
## get the area of our petal in this box:
petalQuadII = petal.intersection(quadIIbox)
## get the area of spots that fall into this 
spottedSurfaceQuadII = spots.intersection(petalQuadII)
quadIICoveredbySpots = spottedSurfaceQuadII.area / petalQuadII.area
propSpotsInQuadII = spottedSurfaceQuadII.area / spots.area


####### quad III  ######
#### nuQuadIIISpots 

## in quad III, centroids need to be neg both X and y:
[ i for i in spots if i.centroid.x < 0 and i.centroid.y < 0 ]
quadIIIspots = [ i for i in spots if i.centroid.x < 0 and i.centroid.y < 0 ]
nuQuadIIISpots = len(quadIIIspots)

#### quadIIICoveredbySpots & propSpotsInQuadIII
## spotted surface in quadIII / total area of spots 

## make a box for quadIII: 
quadIIIbox=sg.box(-1,-1,0,0)
## get the area of our petal in this box:
petalQuadIII = petal.intersection(quadIIIbox)
## get the area of spots that fall into this 
spottedSurfaceQuadIII = spots.intersection(petalQuadIII)
quadIIICoveredbySpots = spottedSurfaceQuadIII.area / petalQuadIII.area
propSpotsInQuadIII = spottedSurfaceQuadIII.area / spots.area


###### QuadIV #######
#### nuQuadIVSpots 
## in quad IV, centroids need to be neg on y-axis and pos on x-axis

[ i for i in spots if i.centroid.x > 0 and i.centroid.y < 0 ]

quadIVspots = [ i for i in spots if i.centroid.x > 0 and i.centroid.y < 0 ]
nuQuadIVSpots = len(quadIVspots)

#### quadIVCoveredbySpots & propSpotsInQuadIV
## spotted surface in quadIV / total area of spots 

## make a box for quadIV: 
quadIVbox=sg.box(0,-1,1,0)
## get the area of our petal in this box:
petalQuadIV = petal.intersection(quadIVbox)
## get the area of spots that fall into this 
spottedSurfaceQuadIV = spots.intersection(petalQuadIV)
quadIVCoveredbySpots = spottedSurfaceQuadIV.area / petalQuadIV.area
propSpotsInQuadIV = spottedSurfaceQuadIV.area / spots.area

## good plotting sequence to see the spots in a quad
plotOne(petal)
addOne(quadIVbox, a=0.3, col='white')
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i, col='red') for i in spottedSurfaceQuadIV ]


###### Proximal half #####

## should be additive, right?:
## proximal should be one and two:

## make a box 
proxBox=sg.box(-1,0,1,1)
## get the area of our petal in this box:
petalProx = petal.intersection(proxBox)
## get the area of spots that fall into this 
spottedSurfaceProx = spots.intersection(petalProx)
proxCoveredbySpots = spottedSurfaceProx.area / petalProx.area
propSpotsInProx = spottedSurfaceProx.area / spots.area



plotOne(petal)
addOne(proxBox, a=0.3, col='white')
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i, col='red') for i in spottedSurfaceProx ]

###### Distal half #####

## make a box 
distBox=sg.box(-1,-1,1,0)
## get the area of our petal in this box:
petalDist = petal.intersection(distBox)
## get the area of spots that fall into this 
spottedSurfaceDist = spots.intersection(petalDist)
distCoveredbySpots = spottedSurfaceDist.area / petalDist.area
propSpotsInDist = spottedSurfaceDist.area / spots.area

petalProx.area + petalDist.area
propSpotsInDist + propSpotsInProx ## works.

plotOne(petal)
addOne(distBox, a=0.3, col='white')
[ addOne(i, col='blue', a= 0.5) for i in spots ]
[ addOne(i, col='red') for i in spottedSurfaceDist ]



## can we make a single row dataframe?

## seems like maybe a dictionary is the way to make a row. 

## we have ~46 traits? oh jeez...





## module

## 0) import stuff

## 1) function for each value, also function for
## cleaning up polys

## 2) create a class. Attributes will be made with 
## the above functions

## 3) script to deal with all files using these tools

from shapely.validation import explain_validity

FlowerPetal.py
#################################################
#!/user/bin/env python3

import os, json, pickle
import numpy as np
import shapely.geometry as sg
import shapely.ops as so
import matplotlib.pyplot as plt
import pandas as pd
from descartes import PolygonPatch
from statistics import mean
from FlowerPetal import FlowerPetal


## in bash, set up a nice directory to build the data frame:


for i in $(find /home/daniel/Documents/mimulusSpeckling/make_polygons/polygons/ -type f -name "*geojson");do
echo $i
cp $i /home/daniel/Documents/mimulusSpeckling/polygon_traits/geojs/
done

## now make our module so it can act on a directory and spit out a dataframe


## class is getting huge. Let's load it here.

## make flowers:
os.chdir(args.geojFolder)

os.chdir('/home/daniel/Documents/mimulusSpeckling/polygon_traits/geojs')

flowers = os.listdir()
flowers.sort()
flowerList = []

for i,flower in enumerate(flowers):
    fl = FlowerPetal()
    fl.flowerName = flower.split(sep='_')[0]
    fl.petalName = flower.split(sep='_')[1]
    fl.geojson = flower
    fl.parseGeoJson(flower)
    fl.cleanFlowerPetal()
    fl.fillColumns()
    row = vars(fl)
    flowerList.append(row)

aa = pd.DataFrame(flowerList)


aa.columns.values

aa.columns.values[0]

## we want to get rid of the geometries...

del aa['petal']
del aa['spots']
del aa['center']
del aa['edge']
del aa['throat']

## and reorder the columns:


bb = aa.reindex_axis(sorted(aa.columns), axis=1)
cc = aa.set_index('petalName').reset_index()
dd = cc.set_index('flowerName').reset_index()

aa.iloc[0:2,0:3]

bb.iloc[0:2,0:3]
cc.iloc[0:2,0:3]
dd.iloc[0:2,0:3]


aa = aa.set_index('petalName').reset_index()
aa = aa.set_index('flowerName').reset_index()

aa.to_csv("testFlowerPetal.csv")

pickle.dump(aa, open("testFlowerPetal.p", "wb"))

aa = pickle.load(open("testFlowerPetal.p", "rb"))


######### 

## wrangle the data a little so Melia can play with it:

import os, json, pickle, re
import numpy as np
import shapely.geometry as sg
import shapely.ops as so
import matplotlib.pyplot as plt
import pandas as pd
from descartes import PolygonPatch
from statistics import mean
from FlowerPetal import FlowerPetal

aa = pickle.load(open("testFlowerPetal.p", "rb"))

## she wants:

## rows for entire plant, not petals or flowers

## each upper petal set averaged for all values

## each trait reported twice - once for avereaged upper petals and once for lower petals


## one of our names looks like this:



fl.plantName
fl.flowerName
fl.petalName


os.chdir(geojFolder)

#os.chdir(args.geojFolder)


######## so how do we do this? #######

## not going to muck around with the 
## existing panda. 

## let's add an attribute, FlowerPetal.plant

## this will identify the plant from which a 
## a flower was taken. 

## then we can sort by this some how when we create our dataframe.

## then we can think about how to stack the petal info side by side as columns.

## say we want to generate a row for plant P421F1:


geojFolder="/home/daniel/Documents/mimulusSpeckling/polygon_traits/geojs"

os.chdir(geojFolder)

aa = pickle.load(open("testing.p", "rb"))


aa.set_index(['plantName', 'flowerName', 'petalName'], inplace=True)

aa.sort_index(inplace=True)

## okay, so that sorts our dataframe hierarchically. 

## useful. 

## todo:

## work from inside out:

## flatten the petal layer from 3 to 2: average the left and mid petal values for all traits

## flatten the flower layer for 2-3 to 1: average every corresponding cell 

## then each plant should have two rows: upper petals and lower petal

## how can we take averages of "left" and "mid" rows?

bb = aa.groupby('plantName').mean()

bb.describe() ##?

## I think we need a mask, just retain the left and mid images:

aa.head(3)

## how do we get just one row?
cc = aa.loc[('P247', 'F1', 'right')]
## works

## does making a column an index remove from the column vector?  
## yup. 

## we need to average those two rows, in each column. This would 
## be basically grouping by plant and petal, discarding the 
## right image row. 

## first, we need to make a mask that keeps only the left and mid 
## petal image rows:


## I think we gotta reset so we can treat these like data:
aa.reset_index(inplace = True)

## now mask out the lower petals ("right" petals)
bb = aa[aa.petalName != 'right']

## now can we group by plantName and flowerName, and take averages?

## i think we gotta put our indices back...

bb.head()

bb.index

bb.reset_index(inplace = True)

bb.set_index(['plantName', 'flowerName', 'petalName'], inplace=True)

bb.sort_index(inplace = True)

## for multi-indexing, need to say levels)

## I think this does it:
cc = bb.groupby(['plantName', 'flowerName']).mean()

## for some reason, this created a column for our integer index range.
## get rid of it:

del cc['level_0']

## can we restore the petalName, call it "upper"?
cc['petalName'] = 'upper'


## okay, now we need our other ('right') petals back, and need these 
## rows as columns

## make another df with the 'right' petals:

del aa['level_0']

aa.reset_index(inplace = True)


dd = aa[aa.petalName == 'right']

del dd['level_0']

dd['petalName'] = 'lower'

## combine the two dfs:

ee = pd.concat([cc,dd])

cc.shape

dd.shape

ee.shape

## weird new columns popping up. start over:

rawDataDF = pickle.load(open("testing.p", "rb"))
del rawDataDF['geojson']
uppersRaw = rawDataDF[rawDataDF.petalName != 'right']
lowerRaw = rawDataDF[rawDataDF.petalName == 'lower']
uppersMean = uppersRaw.groupby(['plantName','flowerName']).mean()
uppersMean.reset_index(inplace = True)
uppersMean['petalName'] = 'upper'

## check:
uppersMean.shape
lowerRaw.shape 

all([ i in lowerRaw.columns for i in uppersMean.columns ]) 
all([ i in uppersMean.columns for i in lowerRaw.columns ]) 

[ i in lowerRaw.columns for i in uppersMean.columns ]
[ i in uppersMean.columns for i in lowerRaw.columns ] 

uppersMean.columns
lowerRaw.columns 

msk = np.array([ i not in uppersMean.columns for i in lowerRaw.columns ] )
np.array(lowerRaw.columns)[ msk ]


## okay, combine them:

combRaw = pd.concat([ uppersMean, lowerRaw ])

## can we sort this and make it pretty?

combRaw.shape

combRaw.set_index(['plantName', 'flowerName', 'petalName'], inplace=True)
combRaw.sort_index(inplace = True)

combRaw.iloc[0:5,0:3]

combRaw.reset_index(inplace = True)

## now what - we want to average plants for all these traits...

plantDf = combRaw.groupby(['plantName','petalName']).mean()

## and flip things around a bit. 

meliaData = plantDf.unstack(level=1)

## okay, and Melia would like to merge the top two rows

aa = meliaData.reset_index() ## doesn't affect columns. 


## final pipeline:
import os, pickle
import numpy as np
import pandas as pd

##get our python file for this data (could use the CSV instead)
pickleFile="testing.p"
rawDataDF = pickle.load(open(pickleFile, "rb"))
## clean up 
del rawDataDF['geojson']
## split out the petal types
uppersRaw = rawDataDF[rawDataDF.petalName != 'right']
lowerRaw = rawDataDF[rawDataDF.petalName == 'right']
## group by flowers for upper petal, average the upper petals
uppersMean = uppersRaw.groupby(['plantName','flowerName']).mean()
## clean up new columns 
uppersMean.reset_index(inplace = True)
## add petalName back in (dropped above)
uppersMean['petalName'] = 'upper'
lowerRaw['petalName'] = 'lower'
## concatenate by row
combRaw = pd.concat([ uppersMean, lowerRaw ])
## take the average of each petal type nested within each plant
plantDf = combRaw.groupby(['plantName','petalName']).mean()
## localized transpose
meliaData = plantDf.unstack(level=1)
## collapse the hierarchical labels
newName = pd.Series([ '_'.join(i) for i in aa ])
meliaData.columns = newName
meliaData.to_csv('meliaData.csv', na_rep='NaN')


### backing up, melia wants the digitizing of the new images run:

matlab -nojvm -nodisplay -nosplash

## our script to use is: 
## prepDougRasters.m

## never really bothered how to get a script run outside of the interpreter for matlab, so...

#scp danthomas@10.4.2.6:/Users/danthomas/Desktop/plate2.zip .

## not sure we need this...

## all of our new images in the labcomp are here:

plate2=/Users/danthomas/Documents/flowerImages/Plate2CroppedImages

## get matlab going:

matlab -nojvm -nodisplay -nosplash

## our script for getting these out of matlab, modified for this new batch of files:

 
%%%%%%%%%%%%%%%%%%%%%%%%%%

%% a script to put all of Doug's rasters into a form we can use:

%% go to working directory

wd = '/Users/danthomas/Documents/speckling/make_polygons/polygons/'
cd(wd);

dougRasterDir = "/Users/danthomas/Documents/flowerImages/Plate2CroppedImages/"

cd(dougRasterDir)

files = dir('P*.mat');
for file = files';
    im = file.name;
    imName = regexprep(im,'\.mat', ''); 
    %% go get our file, come back
    cd(dougRasterDir);
    rast=load(im);
    cd(wd);
    %% make a spot for our image, go to it:
    mkdir(imName);
    cd (imName);
    %% get our petal names (left, right mid)
    petNames = fieldnames(rast.Petals.Clusters);
    %% split images into petal and spot, export, for each of the three petals:
    for i = 1:length(petNames);
        pet = rast.Petals.Clusters.(petNames{i}); %petal at hand
        rastGray = mat2gray(pet); 
        spots = rastGray  < 1; 
        petal = rastGray == 0;
        mkdir(petNames{i});
        cd(petNames{i});
        fileNamePetal = imName + "_" +  petNames(i) + "_" + 'petal.csv';
        csvwrite(fileNamePetal,petal);
        fileNameSpots = imName + "_" +  petNames(i) + "_" + 'spots.csv';
        csvwrite(fileNameSpots,spots);
        cd ..;
    end;
    cd(wd);
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

## did that work?

## files are there. 

## can we digitize and spit out a pdf?

## the old pdf script was written before I setup the FlowerPetal module
## does this matter?

## probably not... let's start a branch, try it out. 


scp -r danthomas@10.4.2.6:/Users/danthomas/Documents/flowerImages/Plate2CroppedImages .

/home/daniel/Documents/cooley_lab/flowerImages/Plate2CroppedImages

## did some shuffling, the old directories (dougRaster, makepoly) should have all
## the csvs, jpgs, mat files from melias now batch (plate2), in addition to the old 
## files. 

## but we gotta get the geojsons, that's in the get_pols script:

## can we adapt the old one?:

#!/usr/bin/env bash

getpols='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/get_pols.py'
wd='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons'

cd $wd

for i in *; do
    echo $i
    cd $i
    for j in *; do
        fullN=$PWD/$j
        $getpols $fullN 0.5 $fullN
    done
    cd ../
done

## okay, working...

## now, how do we improve the digitizing pipeline?

## start by improving the zoning. 
## this will be in the get_poly module  

## and will require using matplotlib interactively. How do we do this?

import FlowerPetal 
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import numpy as np
import pandas as pd
import shapely.geometry as sg

## create one flower petal:

geoJ='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/left/P247F1_left_polys.geojson'

fl = FlowerPetal.FlowerPetal()
fl.plantName = P765
fl.flowerName = 'F1'
fl.petalName = 'left'
fl.geojson = 'P247F1_left_polys.geojson'

fl.parseGeoJson()

fl.cleanFlowerPetal()

## plot it:
plt.ion()
fl.plotOne(fl.petal)
fl.addOne(fl.spots)
fl.addOne(fl.edge, a=0.5, col='white')

## a useful stackoverflow post at:
## https://stackoverflow.com/questions/25521120/store-mouse-click-event-coordinates-with-matplotlib


def onclick(event):
    print('Point at x=%d y=%d' %(event.x, event.y))
    xc, yc = event.xdata, event.ydata
    global points 
    points.append([xc,yc])  

aa=input('Is this throat polygon okay? (y/n)')  

points=[]
if aa == "y":
    print('moving on...')
elif aa == "n":
    print('Okay, click the four points pf the throat.')
    print("Start with one corner and click counterclockwise.")
    cid = plt.gcf().canvas.mpl_connect('button_press_event', onclick)
else: 
    print("answer with \"y\" or \"n\"")

plt.gcf().canvas.mpl_disconnect(cid)

## make a polygon from this

polA = sg.polygon.Polygon(points)

fl.addOne(polA, col='orange', a=1)


## okay, works. we need to integrate it into the digitizing 
## pipeline - the intersection of this trapezoid with exiting petal 
## outline, etc. 

## I think this means a branch. 

## we're on addInt now...

## grab one example petal for this work

## P247F3
csvDir="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F3/right"

## review: to use our old module:

getpols='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/get_pols.py'

$getpols $csvDir 0.5 ./

## okay, now how do we build in the interactive component?

## add in the zone calling to the findZones function...
## the center calling works almost perfectly. 
## Its just the throat

ls -ltr $csvDir


## so we made a module for breaking up spots. How do we use it?

## the plan would be to rerun Melias's corrected images with our 
## old digitizing pipeline, then run this on all the images. 

cd /home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons

## to use our spot breaker module

## example petal:
fl=/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P338F1/left/P338F1_left_polys.geojson

## the jpeg for this:

#jp=/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P760F1.JPG

jp=/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P338F1.JPG

./breakSpots.py $fl -o /home/daniel/test.geojson -j $jp



###### redigitize Melia's edited petals #######

## melia re-edited the photos, which is awesome.
## but she renamed a lot of them, adding the characters
## "_LI" to indicate if a photo was edited.

## let's get rid of this:

wd='/Users/danthomas/Documents/speckling/make_polygons/polygons'

cd $wd

ls -d *_*

for i in *_*; do
    echo $i
    echo ${i/_LI/}
    mv $i ${i/_LI/}
done

for i in  $(find . -name "*_LI*"); do
    echo $i
    echo ${i/_LI/}
    mv $i ${i/_LI/}
    echo ""
done

## worked, I think...now try the script:


########### 

#!/usr/bin/env bash

#getpols='/home/daniel/Documents/mimulusSpeckling/make_polygons/get_pols.py'
#wd='/home/daniel/Documents/mimulusSpeckling/make_polygons/polygons'

getpols='/Users/danthomas/Documents/speckling/make_polygons/get_pols.py/'
wd='/Users/danthomas/Documents/speckling/make_polygons/polygons'

cd $wd

for i in *; do
    echo $i
    cd $i
    for j in *; do
        fullN=$PWD/$j
        $getpols $fullN 0.5 $fullN
    done
    cd ../
done

####################

## throwing errors...

## try it out on one file, editing on my machine:

inF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/left/'
outF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/'

./get_pols.py $inF 0.5 $outF

###########

## back on labcomp

## get our script going...
(./runAllDigs.sh &) &

## check progress

ls -R | grep geojson

ls -R | grep geojson | wc -l

ls -R | grep "\.csv" | wc -l

## that's gotta run for a while...

## what to do in the meantime?

## the next step are the stats and PDF

## so debug the stats pipeline? This is all
## in the FlowerPetal module...

## check wth one file...

wd='/Users/danthomas/Documents/speckling/make_polygons'
#ex='/Users/danthomas/Documents/speckling/make_polygons/polygons/P247F1/left'

ex='/home/daniel/Documents/cooley_lab'

cd $wd

./FlowerPetal.py $ex 'test'

scp danthomas@10.4.2.6:/Users/danthomas/Documents/speckling/make_polygons/polygons/P247F1/left/P247F1_left_polys.geojson ./

## I forget, what does this program need?
## a flat folder with all the geojs of interest
## and 

cd $wd

find . -name "*.geojson" -exec cp {} $geojF \;

geojF="/Users/danthomas/Documents/geojsons"


cd $geojF

$wd/FlowerPetal.py $geojF "automated_stats_29.10.2018"

## looks fine. Just need the digitizing to finish...

## well, let's make sure the pdf maker is working too.

## huh, a lot of these failed. Shit, I didn't log them...

## okay, well, let's right a script that should run all night on the lab comp,

## first check pdf maker...should work out of the box...
## yeah right. 

## not a real module, the arguments are hard-coded into it,
## so if these are correct, should just need to:

(./makePDFs.py &) &


#targetDir='/Users/danthomas/Documents/bigPDF'

targetDir='/home/daniel/Documents/cooley_lab/bigPDF'


## while we're on the lab mac, there's a script 
"/System/Library/Automator/Combine PDF Pages.action/Contents/Resources/join.py" -o $targetDir  $targetDir/*.pdf

##(on my machine I'd use pdftk):

ls $targetDir/*

pdftk $targetDir/* output $targetDir/bigPDF_29.10.2018.pdf

pdftk $targetDir/* output $targetDir/bigPDF_01.11.2018.pdf

## well, shit. it looks like all of melias new images failed. 
## where? Why?

## presumably they're not digitizing... so repeat with one or two

## both 247s failed. Try one of these.

fl="247F1_LI.JPG"

flDir='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/right'

ls $flDir
## this failed...

## okay, running out of time. Plan, rerun the digitizing with some sort of logging. Check it when we get back.


## okay back. sync up the comps...

## now, what worked? The pdf is failing in a lot of ways, 
## but what about our geojsons?

## for instance...

## P247F3

## is not in our PDF. But there are geojsons:
ls -R /home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F3

## look at these in QGIS:
## looks good...

## hmm... so what happened in the pdf maker?

## let's try running our makepdf module in the interpreter...

## next time build in better error logging...

## ah, here we are - Melia's files have all lowercase extension, Doug's have
## uppercase. 

## and this script looks for the original jpgs files, so presumably the names
## aren't matching up. 

## so let's change the names in melia's folder Rotated_and_Cropped images
## to match the old names (no "_LI", and "jpg" to "JPG"):

## change polygon names:

cd /home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped

## get rid of the _LI

find . -name "*_LI*" 

for i in *_LI*; do
    echo $i
    echo ${i/_LI/}
    mv $i ${i/_LI/}
done

for i in *jpg; do
    echo $i
    echo ${i/jpg/JPG}
    mv $i ${i/jpg/JPG}
done


## okay... does this fix our PDFmaker prolems?


## do it on my comp:

./makePDFs.py  &> makePDF_log_29.10.2018.txt

## seems okay. Did I run these stats already? I forget...

## okay, got em. They are now at:

/home/daniel/Documents/cooley_lab/mimulusSpeckling/polygon_traits

## so what? I think we need to convert these to a form that 
## tassel can use... we had a script for this, too somewhere...

############ back to spots ##########

## okay time to break some spots. 

## first, we have to make our spotbreaker handle 
## situations where all spots are deleted by our editing.
## this is necessary where the entire petal space
## was interprested as a spot.

## example petal:
fl=/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P338F1/left/P338F1_left_polys.geojson
## the jpeg for this:
jp=/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P338F1.JPG

./breakSpots.py $fl -o /home/daniel/test.geojson -j $jp


## just curious, can we make our spotbreaker recursive?

def factorial(n):
    print("factorial has been called with n = " + str(n))
    if n == 1:
        return 1
    else:
        res = n * factorial(n-1)
        print("intermediate result for ", n, " * factorial(" ,n-1, "): ",res)
        return res  

print(factorial(5))

## neat, but can we apply this to our module?

## yup. Didn't even have to debug. 

## changing the location of a pyplot?

import matplotlib as mp
import matplotlib.pyplot as plt

plt.ion()
fig = plt.figure()
ax = plt.axes()
ax.plot([0,1],[1,1])

fig.canvas.manager.window.wm_geometry("+600+600")

dir(fig.canvas.manager.window)

## for my window, seems that the x goes from 0-1000, the y from 0-500?
## I have a 1600 x 900 pixel screen, so it seems like this is an
## absolute position system based on pixels.


## is there a way to change the size of a plotting window?
## forward parameter changes exisitng canvas size
## sizes in inches. weird. 

fig.set_size_inches([4,4], forward = True)

fig.get_size_inches()

fig.set_size_inches([8,8], forward = False)

fig.set_size_inches([8,8], forward = True)

plt.ion()

fig = plt.figure()
ax = plt.axes()
ax.plot([0,1],[1,1])
fig2 = plt.figure()
ax2 = plt.axes()
ax2.plot([0,1],[1,0])

if mp.get_backend() == 'TkAgg': 
    fig.canvas.manager.window.wm_geometry("+900+0")
    fig.set_size_inches([8,4], forward = True)
    fig2.canvas.manager.window.wm_geometry("+950+450")
    fig2.set_size_inches([4,4], forward = True)

## okay - put this on the moduel

## example petal:
fl=/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P338F1/left/P338F1_left_polys.geojson
## the jpeg for this:
jp=/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P338F1.JPG

./breakSpots.py $fl -o /home/daniel/test.geojson -j $jp


#########

## okay, so how do we apply this module to all the images 
## we've created?

## probably easiest to make a flat directory of the geojsons,
## and the jpegs, and one for outputs. 

## then we can get clever about subbing them back into our 
## file hierarchy with find or something. 

## flat directory of geojsons

pols='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons'
forSpot='/home/daniel/Documents/cooley_lab/forSpotBreak'
newSpot='/home/daniel/Documents/cooley_lab/editedGeojs'
dougDir='/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped'
toyDir='/home/daniel/Documents/cooley_lab/spotBreakToy'
## script is at:
breakSpots='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/breakSpots.py'

mkdir $forSpot

cd $pols

## get all our geojsons in there
find . -name "*.geojson" -exec cp {} $forSpot \;

## now we need all of our matching jpegs in there...

cd $forSpot

for i in *; do
    j=${i%%_*}
    k="$dougDir/$j"*JPG
    cp $k $forSpot
done

## okay, now how do we run through our images and correct?

## I don't think we'll be able to do these in one or a few sittings. 
## so the key may be to set aside the amount we want to do 

## let's try doing just the P240's
toyDir='/home/daniel/Documents/cooley_lab/spotBreakToy'
breakSpots=/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/breakSpots.py

mkdir $toyDir

cp /home/daniel/Documents/cooley_lab/forSpotBreak/P24?* $toyDir


cd $toyDir
## to do just these:

for i in *geojson; do 
    echo $i
    j=${i%%_*}.JPG
    k=${i/.geojson/_spots_edited.geojson}
    $breakSpots $i -o $k -j $j
    echo $k
done

## right... where was I?

## fix in the weird polygon issue.

## Done. What about the big pipeline...

## fails with this file:

i='P247F1_left_polys.geojson'

echo $i

j=${i%%_*}.JPG

k=${i/.geojson/_spots_edited.geojson}

$breakSpots $i -o $k -j $j

echo $k


## says the petal is a multipolygon. Weird...
makepols='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons'

cd $makepols

python3
import FlowerPetal
import os
import matplotlib.pyplot as plt

makepols='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons'
pols='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons'
forSpot='/home/daniel/Documents/cooley_lab/forSpotBreak'
newSpot='/home/daniel/Documents/cooley_lab/editedGeojs'
dougDir='/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped'
toyDir='/home/daniel/Documents/cooley_lab/spotBreakToy'

plt.ion()

os.chdir(toyDir)


geoJ='P247F1_left_polys.geojson'

fl = FlowerPetal.FlowerPetal()
fl.geojson = geoJ
fl.parseGeoJson()

fl.cleanFlowerPetal()

fl.plotOne(fl.petal)

fl.petal[1].area

[ i for i in fl.petal ]

areas = [ i.area for i in fl.petal ]
fl.petal = [ i for i in fl.petal if i.area == max(areas) ][0]



## okay, debugged. Now, why are some of these central ("right") petals failing?

cd /home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons

less runAllDigs.log

## not sure. no errors logged...

## manually rerun the digitizing of one polygon?


inF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/right/'
outF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/'
./get_pols.py $inF 0.5 $outF

## seems like invalid polygon is the problem...

## debugged, I think. Let's try rerunning our get_pols.py script 

## our script for this is: runAllDigs.sh

## but to be sure, let's get rid of the existing geojsons...

cd /home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons

find . -name "*.geojson" -exec rm {} \;

## then rerun the digitizations...

## what to do in the meantime?
## there are 180 flower images, so ~540 jsons 
## should result from this.

find . -name "*geojson" | wc -l 
## 33 right now, yeah, gonna run all night. 

## so waht can we do? Start breaking polygons on 
## the ones that are already done, right? 

## take a break then dive in...

## our process above was confusing, start over. 

## let's start with all thh 200 flowers

## We need a directory with the jpgs and the geojsons from these:

P200='/home/daniel/Documents/cooley_lab/P200'
pols='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons'
dougRaster='/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped'
 
#mkdir $P200


cd $P200

## get geojsons:
find $pols -name "P2*.geojson" -exec cp {} $P200 \;
## get JPGs:
find $dougRaster -name "P2*.JPG" -exec cp {} $P200 \;

## now break them up:

breakSpots=/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/breakSpots.py

cd $P200

for i in *geojson; do 
    echo $i
    j=${i%%_*}.JPG
    k=${i/.geojson/_spots_edited.geojson}
    $breakSpots $i -o $k -j $j
done

## well, that works well. How did our redigitizing go?


cd $pols

find . -name "*geojson" | wc -l

## 537, so just one fail? Seems promising. 

## now to rerun our pdf maker?

targetDir='/home/daniel/Documents/cooley_lab/bigPDF'


./makePDFs.py  &> makePDF_log_29.10.2018.txt


## okay, let's start archiving these curated petals

## now, we need to edit out the zone calls, and rerun. 
## then clean out the ones we just curated. 

## today just modify the digpol script and set it to 
## rerunning

## try it with the edits:

inF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/right/'
outF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/'
./get_pols.py $inF 0.5 $outF


## okay - check to make sure get_pols is behaving.
## the rerun on labcomp
## fix existing, curated files - 

## make zone calling a separate module?

## two digitizing modules - one for spots, stable, one for zones, under construction

## and then keep digitizing.


## let's split apart the spot-calling and the zone calling modules.

## the spot caller will create the geojson and slots in the geojson
## for the zones but not fill them

## the zone caller will , for the moment, only create the center zone.
## and be developed later for calling the throat and edges. 

inF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/right/'

outF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/'

./get_spots.py $inF $outF

## seems to work...

## now the zone caller, which right now only works for the center polygon:

inF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/right/P247F1_right_polys.geojson'
outF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/test.geojson'

./get_zones.py -h

./get_zones.py $inF 0.5 -o $outF

## does the default naming function work?

cp $inF .

./get_zones.py P247F1_right_polys.geojson 0.5 

## seems to work. 

## so now, rerun the digitizing on the lab comp.

## we need to change the shell script for this...


## get some food, then..

## okay, how can we clean our already spot-broken 
## flowerpetal geojsons?

## first, let's merge the edited files 

cur='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/curated_petals/P200'

cd $cur

for i in *edited*; do 
    ls $i
    ls ${i/_spots_edited/}
    mv $i ${i/_spots_edited/}
done


## did this work? yup

## so now... how do we get rid of the zones we don't want? 


## edit our existing module to make a convenient function for saving out
## our petals as geojsons...

## check our new  spot caller again:

inF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/right/'
outF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/'

./get_spots.py $inF $outF

## okay works. So use the new writeout function for our convenience in a mini-python script to fix these
## curate polygons?

wd='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons'

cd "$cur"
cp P247F1_left_polys.geojson ../../

cd "$wd"

python3

## cleanoutPolys.py
#########################################################

#! /usr/bin/env python3
import os, json, argparse
from get_spots import writeGeoJ
from get_zones import parseGeoJson 

## deal with arguments
parser = argparse.ArgumentParser()
parser.add_argument('geojson',
            help=("""Name of the geojson file to which you want to\
                    assign zones. """))
parser.add_argument('outFileName',
            help=("""Name of the geojson file to which you want to\
                    assign zones. """))

args = parser.parse_args()

petal,spots,center,edge,throat = parseGeoJson(args.geojson)

## now remove the throat and edge polygons (center should be fine?)

throat, edge = None, None 

aa = writeGeoJ(petal, spots, center, edge, throat)

with open(args.outFileName, 'w') as fp:
    json.dump(aa, fp)

#########################################################################3

## now try it out: 

cleanout='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/cleanoutPolys.py'

cd $cur

for i in *geojson; do
    ls $i
    echo ${i/.g/_edited.g}
    $cleanout $i ${i/.g/_edited.g}
done

## worked, it looks like. 

## merge these back in:

for i in *edited*; do 
    ls $i
    ls ${i/_edited/}
    mv $i ${i/_edited/}
done

## weird, one file at least is missing the center...

P247F1_right_polys

ls P247F1_right_polys*

## thanks to our breaking up the script we can rerun the 
## zone creation only on this:

getzone=/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/get_zones.py

cd $cur

$getzone P247F1_right_polys.geojson 0.5 -o P247F1_right_polys.geojson_edit


## so we're caught up, I think. Throats and edges are removed from all 
## spot-broken images. 

## new ones shouldn't have throat/edges. sync up and check this.

## looks good. 

## now, start digitizing the three hunnys


P300='/home/daniel/Documents/cooley_lab/P300'
pols='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons'
dougRaster='/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped'
 
mkdir $P300


cd $P300

## get geojsons:
find $pols -name "P3*.geojson" -exec cp {} $P300 \;
## get JPGs:
find $dougRaster -name "P3*.JPG" -exec cp {} $P300 \;

## now break them up:

breakSpots=/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/breakSpots.py
P300='/home/daniel/Documents/cooley_lab/P300'
cd $P300

for i in *geojson; do 
    echo $i
    j=${i%%_*}.JPG
    k=${i/.geojson/_spots_edited.geojson}
    $breakSpots $i -o $k -j $j
done

## not sure what to do about blushes, for instance P301F1. For now count as non-spot


## debug time. 


import breakSpots
import FlowerPetal
import os, copy, json, argparse
import matplotlib as mp
#import matplotlib.backend_bases
from matplotlib import pyplot as plt
import matplotlib.image as mpimg
from shapely import geometry as sg
from descartes import PolygonPatch


exJ='/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P247F1.JPG'
exF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/left/P247F1_left_polys.geojson'

plt.ion()
jpegFig=plt.figure()
img=mpimg.imread(exJ)
plt.imshow(img, origin='lower')
if mp.get_backend() == 'TkAgg':
    jpegFig.canvas.manager.window.wm_geometry("+900+0")
    jpegFig.set_size_inches([6,3], forward = True)


## load flower geojson and plot cartoon of flower:
fl = FlowerPetal.FlowerPetal()
fl.geojson = exF
fl.parseGeoJson()
fl.cleanFlowerPetal()
fl.plotOne(fl.petal)
fl.addOne(fl.spots, pick=True)

## hold onto these for the other objects
flf = plt.gcf()
flf.suptitle(fl.geojson)
fla = flf.gca()
if mp.get_backend() == 'TkAgg':
    flf.canvas.manager.window.wm_geometry("+900+400")
    flf.set_size_inches([5,5], forward = True)

ok = input('Spots okay? (y/n): ')

plt.ioff()


if ok == 'n':
    print("Pick a spot to edit.")
    ## pick it
    polyPicker = breakSpots.PolyPicker(fl, fig=flf, axs=fla)


elif ok == 'y': quit()

plt.ioff()
plt.show()
## the blocking by the plot is needed, to keep
## the script from ending before data is collected.

## check to make sure new spots are good
fl.plotOne(fl.petal)
fl.addOne(fl.spots, pick=True)
flf = plt.gcf()
flf.suptitle(fl.geojson)
fla = flf.gca()

#######################

breakSpots=/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/breakSpots.py
P300='/home/daniel/Documents/cooley_lab/P300'
cd $P300

for i in *geojson; do 
    echo $i
    j=${i%%_*}.JPG
    k=${i/.geojson/_spots_edited.geojson}
    $breakSpots $i -o $k -j $j
done


########################

## meh, let's see if we can do better than doug's 
## pipeline:


## let's explore the scikitimage tools, start with 
## the canny edge detector...

http://scikit-image.org/docs/stable/auto_examples/edges/plot_canny.html#sphx-glr-auto-examples-edges-plot-canny-py

import numpy as np
import matplotlib.pyplot as plt
from scipy import ndimage as ndi
import imageio

from skimage import feature

im = np.zeros((128, 128))
im[32:-32, 32:-32] = 1

im = ndi.rotate(im, 15, mode='constant')
im = ndi.gaussian_filter(im, 4)
im += 0.2 * np.random.random(im.shape)

# Compute the Canny filter for two values of sigma
edges1 = feature.canny(im)
edges2 = feature.canny(im, sigma=3)

fig, (ax1, ax2, ax3) = plt.subplots(nrows=1, ncols=3, figsize=(8, 3),
                                    sharex=True, sharey=True)


ax1.imshow(im, cmap=plt.cm.gray)
ax1.axis('off')
ax1.set_title('noisy image', fontsize=20)

ax2.imshow(edges1, cmap=plt.cm.gray)
ax2.axis('off')
ax2.set_title('Canny filter, $\sigma=1$', fontsize=20)

ax3.imshow(edges2, cmap=plt.cm.gray)
ax3.axis('off')
ax3.set_title('Canny filter, $\sigma=3$', fontsize=20)

fig.tight_layout()

plt.show()

## neat. Does it work on one of our petal images?

exJ='/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P247F1.JPG'

aa = imageio.imread(exJ)

## what if we just want the right most ('lower') petal? :

bb = aa[:,1000:,:]

fig, (ax1, ax2, ax3) = plt.subplots(nrows=1, ncols=3, figsize=(8, 3),
                                    sharex=True, sharey=True)

fig, (ax1,ax2) = plt.subplots(nrows=2,ncols=1,
                    #sharex = True,
                    #sharey = True,
                    figsize=(8,3),
                    )

[ i.set_aspect('equal') for i in [ax1,ax2] ]

ax1.imshow(aa)

ax2.imshow(bb)

plt.tight_layout()

## okay, how can we feed the second image to the edge detector?

## first step is to get the petal outlines:

## look at this example:
## http://scikit-image.org/docs/stable/auto_examples/color_exposure/plot_regional_maxima.html#sphx-glr-auto-examples-color-exposure-plot-regional-maxima-py


import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter
from skimage import data
from skimage import img_as_float
from skimage.morphology import reconstruction

# Convert to float: Important for subtraction later which won't work with uint8



fig, ax = plt.subplots()
ax.imshow(data.coins())

image = img_as_float(data.coins())


imageG = gaussian_filter(image, 1)

fig, (ax1,ax2) = plt.subplots(nrows=1,ncols=2)
ax1.imshow(image)
ax2.imshow(imageG)

image = gaussian_filter(image, 1)

seed = np.copy(image)

seed[1:-1, 1:-1] 

## make background to pixel with lowest brightness
seed[1:-1, 1:-1] = image.min()

fig, (ax1,ax2,ax3) = plt.subplots(nrows=3,ncols=1)

ax1.imshow(image)
ax2.imshow(imageG)
ax3.imshow(seed)

mask = image

dilated = reconstruction(seed, mask, method='dilation')

plt.close('all')

fig, (ax1,ax2,ax3,ax4) = plt.subplots(nrows=4,ncols=1)
fig, (ax1,ax2,ax3,ax4) = plt.subplots(nrows=1,ncols=4)

fig1, axes1 = plt.subplots(nrows=1,ncols=4)
type(axes1[0])

fig2, axes2 = plt.subplots(nrows=2,ncols=3)
type(axes2[0,0])

axes1[0].plot([0,1],[0,1])
axes2[0,0].plot([0,1],[0,1])

axes1[1].imshow(image)

axes2[0,1].imshow(image)

for i in range(2):
    for j in range(3):
        ax[i, j].text(0.5, 0.5, str((i, j)),
                      fontsize=18, ha='center')

fig3, axes = plt.subplots(nrows=2,ncols=2)
axes[0,0].imshow(image)
axes[0,0].set_title('image')
axes[0,1].imshow(imageG)
axes[0,1].set_title('imageG/mask')
axes[1,0].imshow(seed)
axes[1,0].set_title('seed')
axes[1,1].imshow(dilated)
axes[1,1].set_title('dilated')
fig3.tight_layout()

## what does reconstruct do? 

dilated = reconstruction(seed, mask, method='dilation')

## a little fuzzy on that. seems like:
## "seed" decides what values will grow, 
## "mask" decides the maximum amount of 
## change that can happen at each pixel


## still kind of hazy...
## but from there

fig = plt.figure()
ax = plt.axes()

ax.imshow(image - dilated, cmap='gray')
ax.set_title('image - dilated')

## alternatively, set some threshold manually
## use this to determine what colors get "saved"

h = 0.4
seed = image - h

dilated = reconstruction(seed, mask, method='dilation')
hdome = image - dilated

fig = plt.figure()
ax = plt.axes()
ax.imshow(
ax.set_title('image - '+h)






##############################

## just found out that none of Melia's 
## edits to the kmeans centers were
## be taken into account, doug's 
## "cluster" objects don't update
## with her manual edits

## so we need to grab "petals.____.data" for each petal

## hate matlab, so let's focus on just getting the matrices
## out into python, we'll reformat into images there

octave --no-gui

#wd = '/Users/danthomas/Documents/speckling/make_polygons/polygons/';
#dougRasterDir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

wd = '/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons';
dougRasterDir = '/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped';
cd(dougRasterDir)

files = dir('P*.mat');

for file = files';
    im = file.name;
    imName = regexprep(im,'\.mat', ''); 
    %% go get our file, come back
    cd(dougRasterDir);
    rast=load(im);
    cd(wd);
    %% make a spot for our image, go to it:
    mkdir(imName);
    cd (imName);
    %% get our petal names (left, right mid)
    petNames = fieldnames(rast.Petals.Clusters);
    %% split images into petal and spot, export, for each of the three petals:
    for i = 1:length(petNames);
        pet = rast.Petals.(petNames{i}).data; %petal at hand
        mkdir(petNames{i});
        cd(petNames{i});
        %% for octave
        fileNamePetal = [imName "_" char(petNames(i)) "_" 'melted.csv'];
        %% for matlab, this may work better?
        %%fileNamePetal = imName + "_" +  petNames(i) + "_" + 'melted.csv';
        csvwrite(fileNamePetal,pet);
        cd ..;
    end;
    cd(wd);
end;

## ' ## just because it's screwing up my syntax

## seems to work in octave

## okay, can we look at them in python?

python3 

import matplotlib, os
import numpy as np
import matplotlib.pyplot as plt
from skimage import img_as_float

ex="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/left/P247F1_left_melted.csv"

aa = np.genfromtxt(ex, delimiter=',')

## can we make a image matrix out of this?

## make an empty array from the max x and y coordinates:

## the third column - what is it? it only returns "2", which 
## I think means this is back ground?

np.unique(aa[:,2])

np.unique(aa[:,3])

#3 the fourth column returns two values,  
## seems more promising. Can we visualize this?

## first, how to turn it into a matrix?

## zip up the coordinates:

coords = list(zip(aa[:,0],aa[:,1]))

coords = list(zip(aa[:,0].astype(int),aa[:,1].astype(int)))


plt.ion()
fig = plt.figure()

ax = plt.axes()

ax.plot(coords)

plt.scatter(aa[:,0].astype(int),aa[:,1].astype(int))

plt.plot(aa[:,0].astype(int),aa[:,1].astype(int))

help(ax.plot)

## uh, weird. There's an extra line

ax.get_children()

bb = [ i for i in aa if isinstance(i, matplotlib.lines.Line2D) ]

bb[0]

## it's the first line object. Why is this created?
bb[0].set_visible(False) 

## not sure, but this works:

plt.gca().clear()
plt.plot(aa[:,0].astype(int),aa[:,1].astype(int))



## anyway..seems like we can use coords to make 
## a new matrix

## create matrix:

orig = np.genfromtxt(ex, delimiter=',')
orig = orig.astype(int)
Xmax=np.max(orig[:,1])
Ymax=np.max(orig[:,0])
petal = np.zeros([Xmax,Ymax])
spots = np.zeros([Xmax,Ymax])
for i in orig:
    petal[i[1]-1,i[0]-1] = i[2]
    spots[i[1]-1,i[0]-1] = i[3]

## how do we convert to grey scale?

petal = petal.astype(int)
petal[petal == 2] = 1
spots = spots.astype(int)
spots[spots == 2] = 0


np.unique(spots)


fig, axes = plt.subplots(nrows=1,ncols=2, sharey=True)
for i in axes:
    i.set_aspect('equal')

axes[0].imshow(petal, cmap='gray')
axes[1].imshow(spots, cmap='gray')

## now we want to get just the petal background:

## to get the petal only...
dd=cc.copy()
dd[dd == 3] = 2
ax.imshow(dd)

# to get the spots only...
ee=cc.copy()
ee[ee == 2] = 0
ax.imshow(ee)

## then save these out using our old file names
## want to get rid of the "_melted" and add in "petal" or "spot"

bn = os.path.basename(ex)
petalName=bn.replace("_melted","_petal")
spotsName=bn.replace("_melted","_spots")

## to save our petal background:

np.savetxt(petalName, petal, delimiter=",")
np.savetxt(spotsName, spots, delimiter=",")

## this should be readable to our previous scripts.
## may need to tweak or invert the grayscale values...

## but that's for tomorrow.

## basically, we applied the above new matlab script, 
## for extracting Melia's new petal images
## then we'll apply the above to write our new csvs 

## so make the above into a module runnable from the 
## command line. Then use find to apply to all 
## "melted" files. 

## ugh this is painful.

## so can we apply our python patch? or integrate it some how?

## seems like it should fit well into our det_spots script

## should take the form of a function or two to whip 

## we can skip the csv step, methinks, since get_pols takes 
## a numpy array anyway

## try out our modifies spot-finder with an example 

exL="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/left/P247F1_left_melted.csv"
exR="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/right/P247F1_right_melted.csv"
exF="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/left/"

./get_spots.py $exL -d $PWD

./get_spots.py $exR -d $PWD

## seems to work. Can we get our pipeline running for this?

## seems like we want to clean out our polygon folders of the old geojsons

#find . -name "*geojson" -exec rm {} \;

## for this we need to edit our runAllDigs.sh file

find . -name "*melted.csv" -exec ls {} \;

## or maybe we can just do something like this:

getSpots='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/get_spots.py'
getZones='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/get_zones.py'
wd='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons'

## lab mac

getSpots='/Users/danthomas/Documents/speckling/make_polygons/get_spots.py'
getZones='/Users/danthomas/Documents/speckling/make_polygons/get_zones.py'
wd='/Users/danthomas/Documents/speckling/make_polygons/polygons'


find . -name "*melted.csv" -exec $getSpots {} \; |& tee petals_and_spots.log

find . -name "*.geojson" -exec $getZones {} 0.5 \; |& tee zones.log


## okay, that works, but stopped it, because lotsabugs

## images like:
P261F3_mid_polys

P261F3_left_polys

## okay, debugged, reran digitizing. 

## can we get our pdfmaker fired up again?



wd='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons'
cd $wd

./makePDFs.py  |& tee makePDF_log_11.10.2018.txt

cd /home/daniel/Documents/cooley_lab/bigPDF


pdftk * output bigPDF_10.11.2018.pdf


## let's get a folder for josh to look at:

pols='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons'
geoj='/home/daniel/Documents/cooley_lab/geojsons'

find $pols -name "*geojson" -exec cp {} $geoj  \;

##############


## hop back into the zones...

## tweaked with the I/O of the two modules

## any bugs?

inF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/right/P247F1_right_melted.csv'
outF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/'

./get_spots.py $inF -d $outF

./get_zones.py P247F1_right_polys.geojson 0.5

## seems to work. Can we sick the lab computer on this?


getSpots='/Users/danthomas/Documents/speckling/make_polygons/get_spots.py'
getZones='/Users/danthomas/Documents/speckling/make_polygons/get_zones.py'
wd='/Users/danthomas/Documents/speckling/make_polygons/polygons'


find . -name "*melted.csv" -exec $getSpots {} \; |& tee petals_and_spots.log

find . -name "*.geojson" -exec $getZones {} 0.5 \; |& tee zones.log


### ok, did that work?

## qgis scan, looks maybe a little better but not much? 

## make a pdf



wd='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons'
cd $wd

./makePDFs.py  |& tee makePDF_log_13.11.2018.txt

cd /home/daniel/Documents/cooley_lab/bigPDF


pdftk * output bigPDF_13.11.2018.pdf

#########

## well, it seems to have improved things...

## but a manual checker still seems necessary. Since it 
## seems like I have given all the time I can to improving
## the automated calls on the spots, perhaps I can take 
## a couple days to make a manual zoneCaller. 

## how would we do this? 

## the program would be a modified version of the automated 
## zoneCaller, but would allow toggling of the simplification
## level and finally a complete point-and-click redraw of the 
## throat zone. 

wd="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons"

os.chdir(wd)

## the pnc ....

import os, argparse, json
import matplotlib.pyplot as plt
import numpy as np
import geojsonIO as gj
import shapely.geometry as sg

class polyMaker:
    def __init__(self,fig, ax):
        self.fig = fig
        self.ax = ax
        self.verts = []
        self.poly = None
        self.mouseCID = self.fig.canvas.mpl_connect('button_press_event', self)
        self.keyCID = self.fig.canvas.mpl_connect('key_press_event', self)
    def __call__(self,event):
        if plt.get_current_fig_manager().toolbar.mode != '': return
        self.event = event
        if event.name == "button_press_event":
            if event.button == 1: 
                self.verts.append((event.xdata,event.ydata))
            if event.button != 1: 
                try:
                    self.verts.pop()
                except IndexError:
                    pass
            aa = np.array(self.verts).transpose()
            self.ax.scatter(aa[0],aa[1], s=30, color='red')
            try:
                gj.clearOne()
                self.ax.scatter(aa[0],aa[1], s=30, color='red')
                gj.addOne(sg.Polygon(self.verts))
            except ValueError:
                pass
        elif event.name == "key_press_event" and event.key == 'enter': 
            self.ax.set_title('Creating/updating polygon')
            self.poly = sg.Polygon(self.verts)
            return

plt.ion()

fig, ax = plt.subplots(1,1)
z = polyMaker(fig, ax)


os.system('read -s -n 1 -p "Press any key to continue..."')
print

## and now?

z = 3

try:
    print('a')
    print('b')
    assert(z==4)
    print('c')
except AssertionError:
    print('d')

ex='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P338F1/right/P338F1_right_polys.geojson'

./manZoneCaller.py $ex 0.5 --out "test.geojson"

## okay, so can we create a loop for checking all the geojsons?

## get them all into one directory:

pols="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons"
geojFolder="/home/daniel/Documents/cooley_lab/geojsons"
wd="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons"

find $pols -name "*geojson" -exec cp {} $geojFolder \; 

## now go through these?

for i in *; do
    echo $i
    $wd/manZoneCaller.py $i 0.5 --out ${i/.geojson/_mod.geojson}
    echo ${i/.geojson/_mod.geojson}
done


## a couple problem petals...

i="P248F3_right_polys.geojson"

i="P399F1_right_polys.geojson"

i="P368F2_right_polys.geojson"

i="P422F2_right_polys.geojson"

i="P441F2_left_polys.geojson"

$wd/manZoneCaller.py $i 0.5 --out ${i/.geojson/_mod.geojson}

## wow, 348 out 535 files had to be modified. 

## next time, try the simplification at 0.1

## fold in the "mod" files:

for i in *mod.geojson; do
    echo $i
    mv $i ${i/_mod/}
done



makePDFs.py

wd='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons'
cd $wd

./makePDFs.py  |& tee makePDF_log_13.11.2018.txt

cd /home/daniel/Documents/cooley_lab/bigPDF


pdftk * output bigPDF_13.11.2018.pdf


## but shoot, our dougdebug has changed things a bit...

## can we insert our updated petal and spot matrices asCSVs where they are 
## wanted by the pdfmaker?

matfile="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/left/P247F1_left_melted.csv"

#!/usr/bin/env python3

import os
import numpy as np
from get_spots import parseDougMatrix

## args
parser = argparse.ArgumentParser()
parser.add_argument('meltedDir',
            help=("""Name of the melted matrix from Doug to which you want 
                    save as two CSVs (petal and spots). """))
parser.parse_args()
args.meltedDir = matfile


## parse melted dir, make petal and spot matrices
petal,spots = parseDougMatrix(matfile)

## name stuff
meltName = os.path.basename(matfile)
meltDir = os.path.dirname(matfile)
petalName = meltName.replace("melted","petal")
outPetalName = meltDir + "/" + petalName
spotsName = meltName.replace("melted","spots")
outSpotsName = meltDir + "/" + spotsName

## save out
np.savetxt(outPetalName, petal, delimiter = ',')
np.savetxt(outSpotsName, spots, delimiter = ',')


## to use it

ex="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P247F1/left/P247F1_left_melted.csv"

./updateCSVs.py $ex

## looks okay. Can we walk around the polygon directory and fix things?


wd='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons'
cd $wd

find . -name "*_melted.csv" -exec ./updateCSVs.py {} \;

## and to update our geojsons? The current ones are here:

geojF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/geojsons'

## polygon folder here:

polys='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons'

## we want to go through all of our files in this folder, and replace them 
## where they are found in the polygons folder....

for i in $geojF/*; do
    fn=$(basename $i)
    echo $fn
    dest=$(find $polys -name $fn)
    echo $dest
    cp $i $dest
done

## okay. Everything is uptodate, I think...

## can we make a pdf to be sure?

./makePDFs.py

wd='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons'
cd $wd

./makePDFs.py  |& tee makePDF_log_16.11.2018.txt

cd /home/daniel/Documents/cooley_lab/bigPDF


pdftk * output bigPDF_16.11.2018.pdf

## if that works...

## it doesn't. fuck. 


## can we rerun our stats? wake up brain, how do we do this?...

## I think we just need a directory full of geojsons, should spit out the files we need:

FlowerPetal='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/FlowerPetal.py'
geojF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/geojsons'

$FlowerPetal $geojF "automated_stats_16.11.2018" |& tee stats_log_16.11.2018.txt

## now we want to convert this to a form that tassel can use...

## 

cd /home/daniel/Documents/cooley_lab/mimulusSpeckling/polygon_traits/FlowerPetal2Tassel

## make a few changes... and...

./flowerPetal2tassel.py

####################################

## okay, so now what? do some spot breaking. 

## after things are fairly clean, start on the RNA project. 

## let's just break the large obvious ones. We'll keep the geojson folder current as the 
## place for curated geoj's, also the ones tucked into their respective plant 
## folders...

## the geoj folder will be the working folder,
## when all images in it are run through an
## edit, the individual flower folders will be
## updated.


breakSpots='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/breakSpots.py'
dougRaster='/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped'
geojF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/geojsons'

cd $geojF

for i in *geojson; do 
    ii=$geojF"/"$i
    j=${i%%_*}.JPG
    jj=$dougRaster"/"$j
    k=${i/.geojson/_spots_edited.geojson}
    kk=$geojF"/"$k
    echo $ii
    #echo $jj
    #echo $kk
    $breakSpots $ii -o $kk -j $jj
done


############# messedUpImages ##############

## images that didn't work at all, many spots lost: 

P339F1_mid_polys.geojson
P348F2_left_polys.geojson
P370F1_left_polys.geojson
P371F1_mid_polys.geojson
P385F2_mid_polys.geojson
P400F2_mid_polys.geojson
P405F3_right_polys.geojson
P424F1_left_polys.geojson
P424F1_mid_polys.geojson

########################################################################



## skipped accidentally:
P401F1_right_polys.geojson
P432F2_left

P440F2_mid to P442F1


## skipped by computer?
P424F2_mid, _right
P435F2_right_polys.geojson


## these last two weren't made. Why not?
## try rerunning the digitizing stuff on them. 

## how can we loop through these remainders?


P401F1_right_polys.geojson
P424F2_mid_polys.geojson
P424F2_right_polys.geojson
P432F2_left_polys.geojson
P435F2_right_polys.geojson
P440F2_mid_polys.geojson
P440F2_right_polys.geojson
P440F2_right_polys_spots_edited.geojson
P441F1_left_polys.geojson
P441F1_mid_polys.geojson
P441F1_right_polys.geojson
P441F2_left_polys.geojson
P441F2_mid_polys.geojson
P441F2_right_polys.geojson
P442F1_left_polys.geojson
P442F1_mid_polys.geojson
P442F1_right_polys.geojson

zoop=(\
P401F1_right_polys.geojson \
P432F2_left_polys.geojson \
P435F2_right_polys.geojson \
P440F2_mid_polys.geojson \
P441F1_left_polys.geojson \
P441F1_mid_polys.geojson \
P441F1_right_polys.geojson \
P441F2_left_polys.geojson \
P441F2_mid_polys.geojson \
P441F2_right_polys.geojson \
P442F1_left_polys.geojson \
P442F1_mid_polys.geojson \
P442F1_right_polys.geojson\
)

breakSpots='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/breakSpots.py'
dougRaster='/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped'
geojF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/geojsons'

cd $geojF

for i in ${zoop[@]}; do
    ii=$geojF"/"$i
    j=${i%%_*}.JPG
    jj=$dougRaster"/"$j
    k=${i/.geojson/_spots_edited.geojson}
    kk=$geojF"/"$k
    echo $ii
    #echo $jj
    #echo $kk
    $breakSpots $ii -o $kk -j $jj
done

## still fucked:

P435F2_right_polys.geojson

i='P435F2_right_polys.geojson'
ii=$geojF"/"$i
j=${i%%_*}.JPG
jj=$dougRaster"/"$j
k=${i/.geojson/_spots_edited.geojson}
kk=$geojF"/"$k
$breakSpots $ii -o $kk -j $jj

$breakSpots P435F2_right_polys_spots_edited.geojson -o P435F2_right_polys_spots_edited.geojson -j $jj

## rerun the latest data for melia - got to remap samples

data='/home/daniel/Documents/cooley_lab/mimulusSpeckling/polygon_traits/FlowerPetal2Tassel/automatedResuls_forTassle_16.11.2018.csv'

cd /home/daniel/Documents/cooley_lab/mimulusSpeckling/polygon_traits/Melia_Josh_rearrange

./sortJoshCSVs.py $data --map mapSample2plant.csv --outputName plate1forTassel_26.11.2018.csv

## okay, now what?

## merge in our edited polygons:

for i in *edited.geojson; do
    ls $i
    ls ${i/_spots_edited/}
    mv $i ${i/_spots_edited/}
done


## rerun pdf. stats using the edited geojsons

## the pdf:


## then figure out how to compare petals from the same 
## plant?

wd='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons'
cd $wd

./makePDFs.py  |& tee makePDF_log_27.11.2018.txt

cd /home/daniel/Documents/cooley_lab/bigPDF


pdftk * output bigPDF_27.11.2018.pdf

## should we exclude our messedUpImages?

##yeah

## first, rerun the one that we think can be easily corrected:

breakSpots='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/breakSpots.py'
dougRaster='/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped'
geojF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/geojsons_working'

$breakSpots P297F2_mid_polys.geojson -o P297F2_mid_polys_edit.geojson -j $dougRaster"/"P297F2.JPG 

## better

## now exclude the other funky ones:

mess=(\
P339F1_mid_polys.geojson \
P348F2_left_polys.geojson \
P370F1_left_polys.geojson \
P371F1_mid_polys.geojson \
P385F2_mid_polys.geojson \
P400F2_mid_polys.geojson \
P405F3_right_polys.geojson \
P424F1_left_polys.geojson \
P424F1_mid_polys.geojson)

for i in ${mess[@]}; do
    rm $i
done
## okay, and rerun stats:

## now FlowerPetal.py, on a folder of geojsons

FlowerPetal=/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/FlowerPetal.py 

./FlowerPetal.py $geojF "flowerPetalDF_27.11.2018" |& tee flowerPetalDF_27.11.2018.log

## now add the problem geojsons back in from 
## the classic file tree:

for i in ${mess[@]}; do
    echo $i
    find ../ -name $i -exec cp {} ./ \;
done

for i in ${mess[@]}; do
    ls $i
done

## okay, so now what?

#############################

## stats time - checking effect of plant

## Arielle wants us to check the effect of plant 
## on these petal phenotypes as we are measuring them 
## now.

cd /home/daniel/Documents/cooley_lab/mimulusSpeckling/polygon_traits/FlowerPetal2Tassel

python3 

import os
import pickle
import sklearn.datasets
import numpy as np
import pandas as pd
import shapely.geometry as sg
import matplotlib.pyplot as plt
import sklearn.manifold as manifold
import scipy.spatial.distance as dist
import skbio.stats.distance as skstat
from descartes import PolygonPatch

fp = pickle.load(open('flowerPetalDF_27.11.2018.p', 'rb'))
fp.drop(columns='geojson', inplace=True)

## separate by petals

upperLeft = fp[fp.petalName == 'left'].copy()
upperRight = fp[fp.petalName == 'mid'].copy()
lower = fp[fp.petalName == 'right'].copy()

#upperLeft.drop(columns='petalName', inplace=True)
#upperRight.drop(columns='petalName', inplace=True)
#lower.drop(columns='petalName', inplace=True)

## now can we create a distance matrix with bc?

## I think we want a dataframe without non=pheno labels:

#aa = upperLeft.drop(columns=['plantName', 'flowerName'])
aa = upperLeft

test1=np.sum(aa, axis=1) > 0
test2=aa.nuSpots > 0
all(test1==test2)

## yeah, so let's remove all petals with no spots

aaNoSpots = aa[aa.nuSpots > 0]

aa.shape
aaNoSpots.shape

bb = dist.pdist(aa, metric='braycurtis')

cc = dist.squareform(bb)

## there are lots of nan's in there. How many?

len(bb) ## 15225

np.isnan(bb)

sum(np.isnan(bb)) ## 10,274. Most of the comparisons. 

## why so many? are the comparisons brittle to NaNs?  

aa.isna().sum(axis=0) ## by column/trait. looks like 37 petals petals consistently failed

aa.isna().sum(axis=1) ## by row/petal. looks like 17 traits consistently fail

## what are these columns that consistently fail? note them and remove them?

aa.isna().sum(axis=0) 
## it looks like if we remove the prop____ columns we will greatly improve the
## situation. 

aa[aa['nuSpots'] == 0] 
## yeah, the problem is that the no-spot flowers are creating NaN comparisons
## two options - remove the proportion traits, or remove the no-spots petals

## do both? see if they say the same thing? 

## 1 - remove the proportion traits:

props=[ i for i in aa.columns if i.startswith('prop') ]

aa.isna().sum(axis=0) 

aa.isna().sum(axis=0) > 0
## edgeCoveredbySpots has two NaNs, maybe don't drop this?



sum(aa.isna().sum(axis=0) > 0) ##18
sum(aa.isna().sum(axis=0) > 2) ##17
sum(aa.isna().sum(axis=0) > 10)  ##17
## same. the only marginal trait is edgeCoveredbySpots
## where are those NaN's? What failed?

aa[aa['edgeCoveredbySpots'].isna()]

## the culprits are P408F1_left, P417F1_left
## I have no idea why these failed. They look fine. 
## hate to lose them, but maybe just let them get thrown 
## out? Not a huge loss..

## this throws them out:
bb = aa[aa['edgeCoveredbySpots'].notna()]

## actually, a better way to do this, using
## a threshhold of 10 or less NaNs

##bb = aa.dropna(axis='columns')

## clean out the columns with lotsa NaNs
bb = aa.dropna(axis='columns', thresh=len(aa)-10).copy()
bb.shape
bb.dropna(axis='rows', inplace=True)
bb.shape

aa.shape
bb.shape

## once these columns are out, does the pdist matrix look better?

## drop the naming columns, for the moment:
cc = bb.drop(['plantName', 'flowerName', 'petalName'], axis='columns')
dd = dist.pdist(cc, metric='braycurtis')
ee = dist.squareform(dd)

help(skstat.DistanceMatrix)

ff = skstat.DistanceMatrix(ee)

## not working... says NaNs somewhere

np.isnan(ee).any() ## in there somewhere:

bb.isna().any() ## not in our original data
cc.isna().any() ## same

## so where are these NaNs coming from?

sum(np.isnan(ee))

np.savetxt('zoop.txt', ee)

## okay, can we do a permanova on this?

skstat.permanova(ee, aa, 'plantName')

## what is causing the NaNs?

## for instance - what is the BC dist between 

## rows 13 and 14

## doesn't work
a12=cc.iloc[12,:]
a13=cc.iloc[13,:]
dist.braycurtis(a12,a13)


## works
a0=cc.iloc[0,:]
a1=cc.iloc[1,:]
dist.braycurtis(a0,a1)


b0=[0,0,0.345,True]
b1=[0,1,0.9,True]
dist.braycurtis(b0,b1)

b0=[0,0,0,False]
b1=[0,0,0,False]
dist.braycurtis(b0,b1)
## looks like all-zero comparisons.
## again 

## so I think we gotta get rid of all zero rows

np.sum(cc, axis=1) > 0

cc.loc[30]

aa.loc[30]

## yup. so, get rid of non-spot rows, back in the beginning...
## if we're doing this, we can keep the proportion stats

aaNoSpots.shape
bb.shape

aaNoSpots = aa[aa.nuSpots > 0] ## only want spotted petals
bb = aaNoSpots.dropna(axis='columns', thresh=len(aaNoSpots)-10).copy() ## get rid of any columns causing NAs, = edgeCoveredbySpots
bb.dropna(axis='rows', inplace=True)  ## get rid of any remain rows with NA
bb.reset_index(inplace=True, drop=True)
cc = bb.drop(['plantName', 'flowerName', 'petalName'], axis='columns') ## get rid of labels, to make dist matrix
dd = dist.pdist(cc, metric='braycurtis')
ee = dist.squareform(dd)

## does the dist matrix command work now?
ff = skstat.DistanceMatrix(ee)
## yup

permPlant = skstat.permanova(ff, bb, 'plantName') ## doesn't work

permPlant = skstat.permanova(ff, bb['plantName']) ## works

permPlant = skstat.permanova(ff, bb['plantName'], permutations=10000)


## huh, don't see any sort of variance explained measure. 

## can we visualize with NMS?

mds = manifold.MDS(n_components=2, metric=True, max_iter=3000, eps=1e-12,
                    dissimilarity="precomputed", n_jobs=1,
                    n_init=1)

nmds = manifold.MDS(n_components=2, metric=False, max_iter=3000, eps=1e-12,
                    dissimilarity="precomputed", n_jobs=1,
                    n_init=1)

nmds.fit_transform(ff) ## nope.


mpts = nmds.fit_transform(ee) ## works

pts = nmds.fit_transform(ee) ## works


plt.ion()

plt.scatter(pts[:,0],pts[:,1])

## can we draw hulls around the plant groups?

## make a dataframe with plant name as index

## group by plant name, create a polygor for each, buffered. 

## plot

## to start - make a dataframe or dictionary


polygon = sg.Polygon([[0, 0], [1, 0], [1, 1], [0, 1]])

## so it's good that this is coming as a list of lists?
## but hard to group this way. DF time

len(pts)

plant = bb['plantName']
XX = pd.Series(pts[:,0])
YY = pd.Series(pts[:,1])
nmsPts = pd.concat([plant,XX,YY],axis=1)
byPl = nmsPts.groupby('plantName')

mX = pd.Series(mpts[:,0])
mY = pd.Series(mpts[:,1])
msPts = pd.concat([plant,mX,mY],axis=1)
mbyPl = msPts.groupby('plantName')


## plot a line between the points:

fig = plt.figure()
ax = plt.axes()
for i in plant.unique():
    iDF=byPl.get_group(i)
    shpCoords=list(zip(iDF.iloc[:,1],iDF.iloc[:,2]))
    if len(shpCoords) == 1:
        shp=sg.Point(shpCoords)
    elif len(shpCoords) == 2:
        shp=sg.LineString(shpCoords)
    elif len(shpCoords) > 2:
        shp=sg.Polygon(shpCoords)
    #buff=shp.buffer(distance=0.1)
    #x,y = buff.exterior.xy
    #ax.plot(x, y)
    ax.plot(iDF.iloc[:,1],iDF.iloc[:,2])
    ax.scatter(iDF.iloc[:,1],iDF.iloc[:,2])

## redo this with mds

## send the bio
## then see if we can reconstruct from the pre-spotbreaking
## data. 

## save the dataframe that we did all the above with:

len(bb['plantName'])

upperLeftOut=pd.concat( [bb['plantName'], cc], axis=1)

help(pd.concat)

upperLeftOut.to_csv('upperLeft_phenotype.csv')

########### 

## seems like there's no estimate of variance explained by the 
## ugh, let's go to R

#install.packages('vegan')
library('vegan')

cc = read.csv('upperLeft_phenotype.csv', header=TRUE)

## remove the first column:

dd = cc[,-1]
plants = dd[,1]
phenData = dd[,-1]

## for permanova? need a dataframe of the phenotype data
## can we export our curated data fram from above? 

adonis(phenData ~ plants, permutations = 10000)

## oops looks like we need to change the True's to TRUE's, False to FALSE:

## sed 's/True/TRUE/g' upperLeft_phenotype.csv -i


upperLeft_spotsB_perm <- adonis(phenData ~ plants, permutations = 10000)

save(upperLeft_spotsB_perm, file="upperLeft_spotsB_perm.rda")



## can we do something like this for the older data?


## start over, in python:

## where is our pre-spot break data?

##############


## ugh, gotta find the old, pre-broken spot geojsons...
## looks like I have the good-zone, bad spot files in 
## my file tree for the polygons...

## make a directory of just these, recalculate the stats:

cd /home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons

mkdir spotsNotB

find /home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons -name "*geojson" -exec cp {} spotsNotB/ \;

spotsNotB='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/spotsNotB'

## rerun our flowerpetal script on this 

flowerPetal='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/FlowerPetal.py'

$flowerPetal spotsNotB "spotsNotB"

## is this what we need?

##############
python3

import os
import pickle
import sklearn.datasets
import numpy as np
import pandas as pd
import shapely.geometry as sg
import matplotlib.pyplot as plt
import sklearn.manifold as manifold
import scipy.spatial.distance as dist
import skbio.stats.distance as skstat
from descartes import PolygonPatch

phenoPickle='spotsNotB.p'
fp = pickle.load(open(phenoPickle, 'rb'))

fp.drop(columns='geojson', inplace=True)

upperLeft = fp[fp.petalName == 'left'].copy()
upperRight = fp[fp.petalName == 'mid'].copy()
lower = fp[fp.petalName == 'right'].copy()

aa = upperLeft

aaNoSpots = aa[aa.nuSpots > 0] ## only want spotted petals
bb = aaNoSpots.dropna(axis='columns', thresh=len(aaNoSpots)-10).copy() ## get rid of any columns causing NAs, = edgeCoveredbySpots
bb.dropna(axis='rows', inplace=True)  ## get rid of any remain rows with NA
bb.reset_index(inplace=True, drop=True)
cc = bb.drop(['plantName', 'flowerName', 'petalName'], axis='columns') ## get rid of labels, to make dist matrix
dd = dist.pdist(cc, metric='braycurtis')
ee = dist.squareform(dd)

## we lose a lot (~40 petals) when we get rid of nans, but this 
## is similar to the spots-broken above. 

## can we visualize with NMS?

nmds = manifold.MDS(n_components=2, metric=False, max_iter=3000, eps=1e-12,
                    dissimilarity="precomputed", n_jobs=1,
                    n_init=1)
pts = nmds.fit_transform(ee) ## works

plant = bb['plantName']
XX = pd.Series(pts[:,0])
YY = pd.Series(pts[:,1])
nmsPts = pd.concat([plant,XX,YY],axis=1)
byPl = nmsPts.groupby('plantName')

fig = plt.figure()
ax = plt.axes()
for i in plant.unique():
    iDF=byPl.get_group(i)
    shpCoords=list(zip(iDF.iloc[:,1],iDF.iloc[:,2]))
    if len(shpCoords) == 1:
        shp=sg.Point(shpCoords)
    elif len(shpCoords) == 2:
        shp=sg.LineString(shpCoords)
    elif len(shpCoords) > 2:
        shp=sg.Polygon(shpCoords)
    #buff=shp.buffer(distance=0.1)
    #x,y = buff.exterior.xy
    #ax.plot(x, y)
    ax.plot(iDF.iloc[:,1],iDF.iloc[:,2])
    ax.scatter(iDF.iloc[:,1],iDF.iloc[:,2])

## looks similar. Save out:

upperLeftOut=pd.concat( [bb['plantName'], cc], axis=1)


upperLeftOut.to_csv('upperLeft_spotsNotB_phenotype.csv')


## fix the t/f's with sed again,
## and back to R...

######################

## rerun our script with the unbroken spots csv

library('vegan')

cc = read.csv('upperLeft_spotsNotB_phenotype.csv', header=TRUE)

## remove the first column:

dd = cc[,-1]
plants = dd[,1]
phenData = dd[,-1]

adonis(phenData ~ plants, permutations = 10000)

upperLeft_spotsNotB_perm <- adonis(phenData ~ plants, permutations = 10000)

save(upperLeft_spotsNotB_perm, file="upperLeft_spotsNotB_perm.rda")

upperLeft_spotsB_perm

upperLeft_spotsNotB_perm


################ repeat with lower petals #############

## these might be different. let's look. Back to python:


python3

import os
import pickle
import spotMarker
import sklearn.datasets
import numpy as np
import pandas as pd
import shapely.geometry as sg
import shapely.ops as so
import matplotlib.pyplot as plt
import sklearn.manifold as manifold
import scipy.spatial.distance as dist
import skbio.stats.distance as skstat
from descartes import PolygonPatch
import FlowerPetal, geojsonIO
import matplotlib.pyplot as plt
from statistics import mean
from scipy.spatial import distance

## spots not broken
phenoPickle='spotsNotB.p'

fp = pickle.load(open(phenoPickle, 'rb'))
fp.drop(columns='geojson', inplace=True)
upperLeft = fp[fp.petalName == 'left'].copy()
upperRight = fp[fp.petalName == 'mid'].copy()
lower = fp[fp.petalName == 'right'].copy()

aa = lower

aaNoSpots = aa[aa.nuSpots > 0] ## only want spotted petals
bb = aaNoSpots.dropna(axis='columns', thresh=len(aaNoSpots)-10).copy() ## get rid of any columns causing NAs, = edgeCoveredbySpots
bb.dropna(axis='rows', inplace=True)  ## get rid of any remain rows with NA
bb.reset_index(inplace=True, drop=True)
cc = bb.drop(['plantName', 'flowerName', 'petalName'], axis='columns') ## get rid of labels, to make dist matrix
dd = dist.pdist(cc, metric='braycurtis')

dfOut=pd.concat( [bb['plantName'], cc], axis=1)
dfOut.to_csv('lower_spotsNotB_phenotype.csv')

## repeat, with spots broken:

## spots broken
phenoPickle='/home/daniel/Documents/cooley_lab/mimulusSpeckling/polygon_traits/FlowerPetal2Tassel/flowerPetalDF_27.11.2018.p'
fp = pickle.load(open(phenoPickle, 'rb'))
fp.drop(columns='geojson', inplace=True)
upperLeft = fp[fp.petalName == 'left'].copy()
upperRight = fp[fp.petalName == 'mid'].copy()
lower = fp[fp.petalName == 'right'].copy()
aa = lower

aaNoSpots = aa[aa.nuSpots > 0] ## only want spotted petals
bb = aaNoSpots.dropna(axis='columns', thresh=len(aaNoSpots)-10).copy() ## get rid of any columns causing NAs, = edgeCoveredbySpots
bb.dropna(axis='rows', inplace=True)  ## get rid of any remain rows with NA
bb.reset_index(inplace=True, drop=True)
cc = bb.drop(['plantName', 'flowerName', 'petalName'], axis='columns') ## get rid of labels, to make dist matrix
dd = dist.pdist(cc, metric='braycurtis')

dfOut=pd.concat( [bb['plantName'], cc], axis=1)
dfOut.to_csv('lower_spotsB_phenotype.csv')


## and to R


### lower broken spots:

cc = read.csv('lower_spotsB_phenotype.csv', header=TRUE)

## remove the first column:
dd = cc[,-1]
plants = dd[,1]
phenData = dd[,-1]
adonis(phenData ~ plants, permutations = 10000)

lower_spotsNotB_perm <- adonis(phenData ~ plants, permutations = 10000)

save(lower_spotsNotB_perm, file="lower_spotsNotB_perm.rda")

## lower, spots  brokem:

library('vegan')

cc = read.csv('lower_spotsNotB_phenotype.csv', header=TRUE)

## remove the first column:
dd = cc[,-1]
plants = dd[,1]
phenData = dd[,-1]
adonis(phenData ~ plants, permutations = 10000)

lower_spotsB_perm <- adonis(phenData ~ plants, permutations = 10000)

save(lower_spotsB_perm, file="lower_spotsB_perm.rda")

####

## summaries:

sink('byPlant_permanova_summaries.txt')
upperLeft_spotsNotB_perm
upperLeft_spotsB_perm
lower_spotsNotB_perm
lower_spotsB_perm
sink()


###############################

## and we're back, from Ecuador, etc...

## time to update documentation:

## first git flag the current versions, I think they'll be 
## needed 

## where is our petal plotting function these days? 

## looks like I haven't updated the archived, "official" polygons (geojsons)
## from our working versions. 
## the working versions had manually corrected zones, and broken spots. 

## check with qgis...

## actually, looks the zones are up to date. But spots are not broken 
## in our official archives. 

## I think it's time to do this, both Arielle and Josh's lab seem to 
## think that the the broken spots work. 

## how to do this...

find /home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/geojsons_working -name "P403F1_left_polys.geojson" -type f
find /home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons -name "P403F1_left_polys.geojson" -type f 

## so...

cd /home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/geojsons_working
 
for i in *; do
    ls $i
    aa=$(find /home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons -name $i -type f -exec dirname {} \; )
    ls $aa
    cp $i $aa
done

## looks good to me. updating on github

## now, catch up the documentation...how to talk about the interactive corrections?

## rerun our spotbreaker to get a screen shot:

 
breakSpots='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/breakSpots.py'
dougRaster='/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped'

geojF='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/geojsons'

cd $geojF

for i in *geojson; do 
    ii=$geojF"/"$i
    j=${i%%_*}.JPG
    jj=$dougRaster"/"$j
    k=${i/.geojson/_spots_edited.geojson}
    kk=$geojF"/"$k
    echo $ii
    echo $jj
    echo $kk
    $breakSpots $ii -o $kk -j $jj
done

$breakSpots $ii -o $kk -j $jj


find . -name "P423F2*"

find . -name "P423F2_mid_polys*" 


$breakSpots ./make_polygons/geojsons_working/P248F1_right_polys.geojson -o deleteme.geojson -j ./dougRaster/Rotated_and_Cropped/P248F1.JPG

## do it with our manual zone caller, too:

./manZoneCaller.py -o zoop ./geojsons_working/P248F1_right_polys.geojson 0.5


## testing edits in FlowerPetal:

plt.ion()
geojsonName = "/home/daniel/Documents/cooley_lab/mimulusSpeckling/\
make_polygons/polygons/P297F2/right/P297F2_right_polys.geojson"
flP = FlowerPetal.FlowerPetal()
flP.flowerName = 'P297F2'
flP.petalName = 'right'
## assign the geojson filename:
flP.geojson = geojsonName
## read the geojson, turn it into Shapely polygons 
flP.parseGeoJson()
flP.fillColumns()

geojsonIO.plotOne(flP.petal); geojsonIO.addOne(flP.spots)


plt.ion()

vars(flP)

flP.avgDistSpotEdge2Edge

flP.petal.exterior


fig = plt.figure()

ax = plt.gca()
x, y = flP.petal.exterior.xy
ax.plot(x, y)

## okay, we want just the edge of the petal, without the throat cut:

flowerCut = flP.throat.intersection(flP.petal.exterior)

## conversely:

dir(flP.petal.exterior)

aa = flP.petal.exterior.difference(flP.throat)

aa = flP.petal.exterior.difference(flP.throat.buffer(0.01))

fig = plt.figure()
ax = plt.axes()
for i in aa:
    x, y =  i.xy
    ax.plot(x, y)

fig, axes = plt.subplots(



fig = plt.figure()
ax = plt.axes()


## so buffer, then join 

throatfrags = flP.petal.exterior.difference(flP.throat.buffer(0.01))
if len(throatfrags) > 1:
    throatJoin = so.linemerge(throatfrags)

x, y =  lineJoin.xy
plt.gca().plot(x, y)

fig = plt.figure()
ax = plt.axes()
ax.plot(x, y)

## now, can we get the distance of the spots to there?

from statistics import mean

avgDistSpotEdge2Edge = mean([ flP.petal.exterior.distance(i) for i in flP.spots ])

avgDistSpotEdge2Edge = mean([ throatJoin.distance(i) for i in flP.spots ])

flP.avgDistSpotEdge2Edge 

flP.avgDistSpotCentroid2Edge

throatfrags = flP.petal.exterior.difference(flP.throat.buffer(0.01))
if len(throatfrags) > 1:
    throatJoin = so.linemerge(throatfrags)
else: throatJoin = throatfrags

[ throatJoin.distance(i) for i in flP.spots ]

[ flP.petal.exterior.distance(i.centroid) for i in flP.spots ]

#########

## we need a diagram showing the quadrats:

geojsonIO.plotOne(flP.petal); geojsonIO.addOne(flP.spots)
proxBox=sg.box(-1,0,1,1)
geojsonIO.addOne(proxBox, col='white', a=0.5)


quadIVbox=sg.box(0,-1,1,0)

geojsonIO.plotOne(quadIVbox)





plt.ion()
geojsonIO.plotOne(flP.petal); geojsonIO.addOne(flP.spots)
ax = plt.gca()
## moving spines we want
ax.spines['right'].set_position('zero')
ax.spines['bottom'].set_position('zero')
## removing the other spines
ax.spines['left'].set_visible(False)
ax.spines['top'].set_visible(False)
## removing the tick marks
ax.tick_params(bottom="off", right="off")
## get rid of the tick labels
ax.get_xaxis().set_ticks([])
ax.get_yaxis().set_ticks([])
## increase line width
ax.axhline(linewidth=4, color = "k")
ax.axvline(linewidth=4, color = "k")
props = dict(boxstyle='round', facecolor='wheat', alpha=0.7)
ax.text(0.25, 0.25, "I", fontsize=25,
        verticalalignment='top', bbox=props)
ax.text(-0.25, 0.25, "II", fontsize=25,
        verticalalignment='top', bbox=props)
ax.text(-0.25, -0.25, "III", fontsize=25,
        verticalalignment='top', bbox=props)
ax.text(0.25, -0.25, "IV", fontsize=25,
        verticalalignment='top', bbox=props)



#########

## we need a script for marking centers of spots by 
## eye. And drawing a circle around them. 

## blank plot:

plt.ion()
fig = plt.figure()
ax = plt.axes()


## we need an event handler that marks a spot and records 
## the x,y from the axes:

class SpotMarker:
    def __init__(self): 
        self.fig = plt.gcf()
        self.ax = plt.gca()
        self.event = None
        self.centerx = None
        self.centery = None
        self.centerpt = None
        self.circs = []
        self.centerpts = []
        self.circlePolys = []
        self.circle = None
        self.markCID = self.fig.canvas.mpl_connect('button_press_event', self)
        self.releaseCID = self.fig.canvas.mpl_connect('button_release_event', self)
    def __call__(self, event):
        if plt.get_current_fig_manager().toolbar.mode != '': return
        self.event = event
        if (self.event.name == 'button_press_event' 
            and self.event.button == 1):
            self.centerx = event.xdata; self.centery = event.ydata
            try:
                self.centerpt, = self.ax.plot(event.xdata, event.ydata, 
                        marker='+', markersize=3, color = 'k')
                self.centerpts.append(self.centerpt)
            except ValueError:
                pass
        elif (self.event.name == 'button_release_event'
            and self.event.button == 1):
            circleRad = distance.euclidean((self.centerx, self.centery),
                                    (event.xdata, event.ydata))
            self.circle = plt.Circle((self.centerx, self.centery), circleRad)
            self.circs.append(self.circle)
            self.ax.add_patch(self.circle)
            circlePoly = sg.Polygon(self.circle.get_verts())
            self.circlePolys.append(circlePoly)
        elif (self.event.name == 'button_press_event' 
            and self.event.button != 1):
            try:
                self.centerpt.remove()
                self.circle.remove()
                del(self.centerpts[-1])
                self.centerpt = self.centerpts[-1]
                del(self.circs[-1])
                self.circle = self.circs[-1]
                del(self.self.circlePolys[-1])
            except (ValueError, IndexError):
                pass


## okay, use that to make a polygon

fig.canvas.mpl_disconnect(aa.markCID)
fig.canvas.mpl_disconnect(aa.releaseCID)
del(aa)

aa = SpotMarker()

aa.event.xdata, aa.event.ydata

bb = 1
cc = 2
if (bb == 1 
    and cc == 2):
    print("zzop")


cc = ['a','b','c','d']


### okay, unwieldy, time to start treating this like a module:

import spotMarker




import os
import json
import pickle
import spotMarker
import sklearn.datasets
import pprint as pp
import numpy as np
import pandas as pd
import shapely.geometry as sg
import shapely.ops as so
import matplotlib.pyplot as plt
import sklearn.manifold as manifold
import scipy.spatial.distance as dist
import skbio.stats.distance as skstat
from descartes import PolygonPatch
import FlowerPetal, geojsonIO
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from statistics import mean
from scipy.spatial import distance

plt.ion()
geojsonName = "/home/daniel/Documents/cooley_lab/mimulusSpeckling/\
make_polygons/polygons/P297F2/right/P297F2_right_polys.geojson"
flP = FlowerPetal.FlowerPetal()
flP.flowerName = 'P297F2'
flP.petalName = 'right'
## assign the geojson filename:
flP.geojson = geojsonName
## read the geojson, turn it into Shapely polygons 
flP.parseGeoJson()
flP.fillColumns()
petArt = geojsonIO.plotOne(flP.petal); geojsonIO.addOne(flP.spots)

fig = plt.gcf()
ax = plt.gca()
aa = spotMarker.SpotMarker()

fig.canvas.mpl_disconnect(aa.markCID)
fig.canvas.mpl_disconnect(aa.releaseCID)
del(aa)

circle = sg.Point(0, 0).buffer(0.1)

bb = geojsonIO.addOne(circle)

## seems to work. How can we add these spots to the mix

## do we want to add them to the flowerPetal objects? why not? 

## we'll have to do a little retrofitting, though. 

## these inkspots will be multipolygons, collections of polygons

aa.circlePolys

## we'll add a sixth feature to our geojson, spotEvents

## first we need a dictionary with three slots:

bb = {
    "type": "Feature",
    "geometry": None,
    "properties": {"id": "spotEstimates"}
    }

## can we get our shapely poygons into a format that 
## works here?

## if we feed it the whole thing?

bb['type'] = sg.mapping(sg.MultiPolygon(aa.circlePolys))

## seems to work...

def choice():
    try:
        aa = input("(y/n): ")
        assert aa in {"y","n"}
        return(aa)
    except AssertionError as err:
        print('Enter "y" or "n"')
        return(choice())

def choice():
    try:
        aa = input("Finished (y)? ")
        assert aa == "y"
    except AssertionError as err:
        print('Enter "y" when done.')
        choice()

bb = choice()

## and this would be inserted into our existing geojsons as
## a sixth feature. 

## can we add this to one of our flowerPetal objects?

## big change. 

## let's do a commit and a branch...

## okay, how do we integrate this?

## 1 - geojsonIO needs an extra slot for inkspots
## 2 - flowerpetal needs to be cleaned up, updated - needs to use the geojsonIO module more, anyway
## 3 - get_spots and and get_zones might need tweaked, but the geojsonIO should be able to handle 
## none results from these. If not, that needs to be fixed, anyway. 

## The plan? fix geojson to handle a sixth feature slot. 

## so we need a top level script, when spotmarker is called, that leaves a spot estimate 
## multipolygon in the new spotEstimates slot of the geojson

## our geojsonIO should be able to handle a non-existent slot, and make a new one
## and our spotMarker should be able to fill it

## so we need to make spotMarker accessible from the shell:

cd /home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons

./spotMarker.py geojsons_working/P423F2_mid_polys.geojson -o test.geojson 

## seems to work. What now?

## we'll use our working directory:

spotMarker='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/spotMarker.py'

cd /home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/geojsons_working

for i in *; do
echo $i
echo ${i/.geojson/_withEst.geojson}
$spotMarker $i -o ${i/.geojson/_withEst.geojson}
done

## oops, forgot that we want to do this with the raw images...

## how to get these?

## where does Doug delineate his bounding boxes?

## okay, the pixel coordinates are available in Doug's mat files. 

## So we're back to matlab (maybe octave):

## for example:
/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P434F1.mat

octave-cli

load /home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P434F1.mat

who

Petals.left.data(:,1)

Petals.left.data(:,4)

Petals.left.data(1,:)

## to get our bounding box, we need the max and mins of the first two columns 

min(Petals.left.data(:,1)) ## 34
min(Petals.left.data(:,2)) ## 66

max(Petals.left.data(:,1)) ## 363
max(Petals.left.data(:,2)) ## 425


## so I think this means that our lower left corner of the left petal 
## bounding (34, 66) and upper right (363, 425)?

## does this make sense if we examine the photo in matplotlib:

import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import numpy as np

exJPG="/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P434F1.JPG"

img=mpimg.imread(exJPG)

#img=mpimg.imread(exJPG).astype("float")

plt.ion()

#plt.imshow(img)
plt.gca().invert_yaxis()

## bounding (34, 66) and upper right (363, 425)?

aa = img[34:364,66:425]

bb = img[66:364,34:425]

cc = img[34:364,34:425]

fig, axes = plt.subplots(4,1)

axes[0].imshow(exJPG)

axes[1].imshow(aa)

plt.imshow(bb)

plt.imshow(cc)

## hmm, is there an issue of inversion the y-axis here?

fig = plt.figure()
ax = plt.axes()
plt.imshow(img)

fig, axes = plt.subplots(2,1)
cc = img[114:415,961:1389]
axes[0].imshow(img)
axes[1].imshow(cc)

## it does look like there may be an inversion in the rows/columns.
## doug's matrix gives the column ("x") pixel coordinate first, 
## the matplotlib scripts are the reverse of this, column pixel 
## coordinate is given first... 

## anyway, we can recreate the BB from Doug's melted csv. Seems like 
## the bounding box might be good info to retain from Doug's pipeline.

## so where do we build this into our pipeline?

## 1 - we want to save the work that has already been done, in the 
## flowers that have had manual correction of spots and zones
## (plate 1). We need to add this info retroactively somehow to 
## the record. 

## 2 - but we also want to build this into our pipeline for the next
## batches of automated phenotyping (plate 2+)

## so want do we do?

## seems like we have to store this info in the geojson? 


file="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P434F1/right/P434F1_right_melted.csv"


def parseDougMatrix(file):
    orig = np.genfromtxt(file, delimiter=',')
    orig = orig.astype(int)
    Ymax=np.max(orig[:,1])
    Ymin=np.min(orig[:,1])
    Xmax=np.max(orig[:,0])
    Xmin=np.min(orig[:,0])
    BB = [
        (Xmin,Ymin),
        (Xmax,Ymin),
        (Xmax,Ymax),
        (Xmin,Ymax),
        ]
    petal = np.zeros([Xmax,Ymax])
    spots = np.zeros([Xmax,Ymax])
    for i in orig:
        petal[i[0]-1,i[1]-1] = i[3]
        spots[i[0]-1,i[1]-1] = i[3]
    ## 0 is background color
    ## 2 is petal color
    ## 3 is spot color
    petal = petal.astype(int)
    petal[petal == 0] = 1
    petal[petal == 2] = 0
    petal[petal == 3] = 0
    spots = spots.astype(int)
    spots[spots == 0] = 1
    spots[spots == 2] = 1
    spots[spots == 3] = 0
    return(BB,petal,spots)

parseDougMatrix(file)

BB = [
    [Xmin,Ymin],
    [Xmax,Ymin],
    [Xmax,Ymax],
    [Xmin,Ymax],
    ]

geojson='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/geojsons_working/P434F1_right_polys.geojson'
##P434F1

fl=geojsonIO.parseGeoJson(geojson)[0]

geojsonIO.plotOne(fl)

geojsonIO.addOne(sg.Polygon(a), a=0.2)


## okay, BB is created from the CSV. From there, it needs to make it into 
## the geojson 

## we'll leave it unscaled, and it can be used, I think, to clip the original photos. 

## added handling to geojson, and scripted in the retainment of the bounding box in the 
## get_spots script...

## have to do some testing on that, when we run the second plate of images through

## but how do we add it to flowers we have already done a lot of work on, that we don't 
## want to rerun through our pipeline? (plate 1)

## to make the bounding box of a petal...

def getBB(file):
    orig = np.genfromtxt(file, delimiter=',')
    orig = orig.astype(int)
    Ymax=max(orig[:,1])
    Ymin=min(orig[:,1])
    Xmax=max(orig[:,0])
    Xmin=min(orig[:,0])
    BB = np.array([
        [Xmin,Ymin],
        [Xmax,Ymin],
        [Xmax,Ymax],
        [Xmin,Ymax],
        ]).tolist()
    return(BB)

 
csv="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P434F1/right/P434F1_right_melted.csv"
geojson='/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/geojsons_working/P434F1_right_polys.geojson'

jpg="/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P434F1.JPG"


petal,spots,center,edge,throat, spotEstimates, photoBB = geojsonIO.parseGeoJson(geojson)

photoBB = getBB(csv)

test = geojsonIO.writeGeoJ(petal, spots, center, edge, throat, spotEstimates, photoBB)


with open('test.geojson', 'w') as fp:
    json.dump(test, fp)

petal,spots,center,edge,throat, spotEstimates, photoBB = geojsonIO.parseGeoJson("test.geojson")

## works, but not sure if this list of list helps us... can we clip a photo with this?

xxyy = list(zip(*photoBB))
Xmin = min(xxyy[0])
Xmax = max(xxyy[0])
Ymin = min(xxyy[1])
Ymax = max(xxyy[1])

dd = img[Ymin:Ymax,Xmin:Xmax]

plt.ion()

img=mpimg.imread(jpg)
fig, axes = plt.subplots(2,1)
axes[0].imshow(img)
axes[1].imshow(dd)

## what happens if we put our petals polygon on their first?

fig = plt.fig()
ax = plt.axes()
ax.imshow(dd)
geojsonIO.addOne(petal)

## scales are all off. 

aa = geojsonIO.plotOne(petal, a=0.4)
plt.gca().imshow(dd, extent=plt.gca().get_xlim() + plt.gca().get_ylim(), 
                origin = 'lower')

aa.remove()

## huh, that works really well...

## now what?

## I did all this to be able to estimate spot sizes. 

## so we need to add the bounding boxes to all geojsons:

import json
import geojsonIO
import numpy as np

def getBB(file):
    orig = np.genfromtxt(file, delimiter=',')
    orig = orig.astype(int)
    Ymax=max(orig[:,1])
    Ymin=min(orig[:,1])
    Xmax=max(orig[:,0])
    Xmin=min(orig[:,0])
    BB = np.array([
        [Xmin,Ymin],
        [Xmax,Ymin],
        [Xmax,Ymax],
        [Xmin,Ymax],
        ]).tolist()
    return(BB)


def addPhotoBB(geojson, csv):
    petal,spots,center,edge,throat, spotEstimates, photoBB = geojsonIO.parseGeoJson(geojson)
    photoBB = getBB(csv)
    newGeo = geojsonIO.writeGeoJ(petal, spots, center, edge, throat, spotEstimates, photoBB)
    with open(geojson, 'w') as fp:
        json.dump(newGeo, fp)


geoJs = os.listdir()

## so, tomorrow, we need to match up csv files with geojson files. Basically
## we need to move through each subdirectory with each petal of each flower. 

## solution will probably involve os.walk()


polys="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons"

os.chdir(polys)

os.walk(os.getcwd())

aa = list(os.walk(os.getcwd()))

pp.pprint(aa)

## ugh, this is a mess. let's do this in the shell. 
## giving these functions there own module

## try it with two test files:
## in shell

exCSV="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P403F1/left/P403F1_left_melted.csv"
exGeo="/home/daniel/Documents/cooley_lab/mimulusSpeckling/make_polygons/polygons/P403F1/left/P403F1_left_polys.geojson"
exJPG="/home/daniel/Documents/cooley_lab/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P403F1.JPG"
cp $exCSV test.csv
cp $exGeo test.geojson

grep "photoBB"  test.geojson ## nada

./fixPhotoBBs.py test.geojson test.csv

grep "photoBB"  test.geojson ## there!

## looks good...

python3

petal,spots,center,edge,throat, spotEstimates, photoBB = geojsonIO.parseGeoJson("test.geojson")
plt.ion()
geojsonIO.plotOne(petal)
xxyy = list(zip(*photoBB))
Xmin = min(xxyy[0])
Xmax = max(xxyy[0])
Ymin = min(xxyy[1])
Ymax = max(xxyy[1])
img=mpimg.imread(exJPG)
dd = img[Ymin:Ymax,Xmin:Xmax]
aa = geojsonIO.plotOne(petal, a=0.2)
plt.gca().imshow(dd, extent=plt.gca().get_xlim() + plt.gca().get_ylim(), 
                origin = 'lower')

aa.remove()

## will need to make the above into a function soon...
## anyway, this worked. Can we apply to all of our 
## existing, highly edited flowerpetal geojsons?



