## let's try our vim script out

## symlink where gimp can find it:

ls /Users/danthomas/Documents/speckling/center/scriptfu/make_spot_polygons.scm 

ln -s /Users/danthomas/Documents/speckling/center/scriptfu/make_spot_polygons.scm "/Users/danthomas/Library/Application Support/GIMP/2.8/scripts/make_spot_polygons.scm" 

$gimp -i --verbose -b '(make_spot_polygons "/Users/danthomas/Documents/speckling/demo/test_spots3.png" "mooptest")' -b '(gimp-quit 0)'

## new install not working, missing "gdb". What is this? 

brew search gdb

brew info gdb

## then had to do a bunch of certificate stuff, info here: <https://sourceware.org/gdb/wiki/BuildingOnDarwin>

## to find out where gdb lives:

type -a gdb ## its in /usr/local/bin

## but 

ls -l /usr/local/bin/gdb

## its a soft link to our homebrew cellar:

ls -l /usr/local/Cellar/gdb/8.1/bin/gdb

## not writable. I want to keep it that way. So mac wants sudo or gui password input

codesign -s gdb-cert /usr/local/Cellar/gdb/8.1/bin/gdb

## okay, did this help?

$gimp -i --verbose -b '(make_spot_polygons "/Users/danthomas/Documents/speckling/demo/test_spots3.png" "mooptest")' -b '(gimp-quit 0)'

## and then a mountain of errors from gdb, about shared library incompatibilites. 

## meh. fuck all that. The command line will not work for my setup. It's not worth the time
## to now debug gdb for my setup. Too deep for me. 

## let's try just using the console while gimp is running. Then maybe we can make a macro 
## instead of a script. 

## example file: "/Users/danthomas/Documents/speckling/demo/test_spots3.png"

    (let* (
            ;; load files, set vars
            (image (car (gimp-file-load 
                                0 
                                "/Users/danthomas/Documents/speckling/demo/test_spots3.png" 
                                "/Users/danthomas/Documents/speckling/demo/test_spots3.png") ) )
            (drawable (car (gimp-image-get-active-layer image)))
          )
            ;; do stuff
            ;;1 select black/solid regions:
            (gimp-image-select-color 
                image
                CHANNEL-OP-REPLACE
                drawable
                '(0 0 0) ;; black
            ) ;'
            ;;2 Convert selection to path
            (plug-in-sel2path
                RUN-NONINTERACTIVE
                image
                drawable
            ) 
            ;;3 save path to file
        (gimp-vectors-export-to-file
            image
            "/Users/danthomas/Documents/speckling/make_polygons/spots_script_test.svg"
            0 ;; all vectors
        )
)

## so that works for copying and pasting to the console in GIMP.

## we need to either write a macro for running in the GUI that can handle lots of images or 
## try again with the command line. 


## I personally like the idea of the latter. But I still have no idea 
## how to run gimp command line from the terminal

## can we run the above from the terminal?


## we need to put a copy (symlink) where git wants it:

ln -s /Users/danthomas/Documents/speckling/make_polygons/make_spot_polygons.scm \
"/Users/danthomas/Library/Application Support/GIMP/2.10/scripts/make_spot_polygons.scm"

ls -l "/Users/danthomas/Library/Application Support/GIMP/2.10/scripts/"


ls /Applications/Gimp-2.10.app/Contents/MacOS/gimp-console-2.10

/Applications/Gimp-2.10.app/Contents/MacOS/gimp-console-2.10

## theoretically, we should be able to run this like so:
~/GIMP.app/Contents/MacOS/gimp-2.8 -i

## none of the above works. As before. I think the best strategy here is to try this on my
## linux machine, see if the same bugs pop up. 
cd /home/daniel/mimulusSpeckling/make_polygons


## all the above was for the lab mac. 

## try again with my linux laptop

## where to put gimp scripts on my laptop?

## here I think:
cd ~/.gimp-2.8/scripts

ls -al ~/.gimp-2.8/scripts

ln -s /home/daniel/mimulusSpeckling/make_polygons/make_spot_polygons.scm ~/.gimp-2.8/scripts/make_spot_polygons.scm 

## can we run it?


gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## let's do a test with a script from online:

gimp -i -b '(test-script "foo.png" 5.0 0.5 0)' -b '(gimp-quit 0)'

## okay works...why not ours?

## why is the the script name parsed as an undeclared variable?

cd ../demo
gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'
## nope

## is it because it is a symlink?

cp /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm /home/daniel/.gimp-2.8/scripts/

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## ah, that worked!
## is this a permission issue?

chmod 777 /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm

## try again

ln -s /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm ~/.gimp-2.8/scripts/makePetalPoly.scm 

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## yep. I feel pretty stupid. But good to know that symlink permissions 
## don't really mean anything

## sweet, so:

## 1 edit script to export other filenames that are related to the entered file
## 2 find a way to handle multiple files - either with bash or in scriptfu

## 1 should be simple?

## okay, works. 

#######################################

## back up. We need to use Doug's structures to generate binary pngs 
## that gimp will like. 

## since matlab sucks, as in not-free and license issues are complex
## even when paid for, we'll try octave here

## I'm waiting on the math department to talk to me about the desktop
## license at the lab.`

octave-cli

## get one of Doug's data structures:

load("/home/daniel/Documents/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P431F1.mat")

Petals

fieldnames(Petals)

Petals.left

fieldnames(Petals.left)

Petals.left.data

## can we turn this into an image?

fieldnames(Petals.right)

fieldnames(Petals.Clusters)

Petals.Clusters.left

imshow(Petals.Clusters.left) %% doesn't work

image(Petals.Clusters.left) %% works. Don't know why

image(Petals.Clusters.right); colorbar

%% get the image package 
pkg load image

aa = mat2gray(Petals.Clusters.right);

imshow(aa) %% that works. 

unique(aa) %% all values transformed to between 1 and 0. 
%% 1 is white, 0 is black

%% now we want a petal and a spot image. To do this:

%% get the spot shapes as black, background as white:
bb = aa < 1;
imshow(bb); 

%% petals black with white background
cc = aa == 0;
imshow(cc); 

%% okay. These should be digestable for our GIMP scripts. 

%% export:

imwrite(bb, 'P431F1_bottom_spots.png') %% some quality warnings. 
imwrite(cc, 'P431F1_bottom_petal.png')

%% can we get these to gimp now, and get svgs for both?

## shell/gimp

## ugh, got to remember how to use Gimp from command line 
## with our script...

## we have our scriptfu for this, does this work?:

gimp -i -b '(makePetalPoly "P431F1_bottom_spots.png")' -b '(gimp-quit 0)'

## nope.  What changed? the old command that worked:

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## doesn't work now... did I change something accidentally?

git log makePetalPoly.scm


## not really. The file worked on the last day it was modified.

## can we bring up the older versions, see if they work?

git checkout 759701d0688c1c08e76ca876dc25d08e122b09c4 makePetalPoly.scm

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## nope. What changed?

## looks like the link might be dead...

ln -s /home/daniel/Documents/mimulusSpeckling/make_polygons/makePetalPoly.scm /home/daniel/.gimp-2.8/scripts/makePetalPoly.scm

## work now?

gimp -i -b '(makePetalPoly "P431F1_bottom_spots.png")' -b '(gimp-quit 0)'

## yup, works. Note to self, watch those directory changes...remember they fuck with links 

## now can we flatten the svg bezier curves?

## ugh, all this would be so much more elegant with python. 
## http://scikit-image.org/docs/dev/api/skimage.draw.html

## anyway..

## so with svg bezier curves, we want to be rid of the control points 
## leave just the terminal points

## first get the svg to work,
## then figure out how to clean it all out so matlab can read it.

cp P431F1_bottom_spots.png_path.svg test.svg

## for svg, to flatten the beziers,
## change all C's to L's
## and get rid of the control points (keep only the first set of coordinates)

sed '/^\s*C/ s/C\s/L /' test.svg | \
sed -e 's/\([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\) \([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\) \([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\)/\1/g' > test2.svg

## okay, that seems to work...but the paths have been clipped somehow, which leaves 
## unclosed polygons. This must have happened during the gimp export?

## nope, the svg with the beziers is not broken, at least according to inkscape.
## so we introduced this with our SED modification

tail test.svg

tail test2.svg

## actually, it's ok. The svg lines do close up in both files, you just have to
## expand the svg canvas to see a little. 

## ok, relief. So...what do we need for matlab to understand that these are 
## polygons?

## gimp needs two vectors, x and y. 

## how can we convert our svg to this? 

## a couple of problems here.

## 1) get rid of chaff - remove all the non-drawing directions
## 2) break up the respective polygons
## 3) convert each polygon to two vectors, x and y. 

## this really needs some python. Sorry Doug. 

## which probably means we should back up and use a 
## single python script to fix our svgs in general
## (so I just spent an hour on a SED regex I don't need).
## good news is that the script should be fairly straight forward.

## actually, why use svgs at all? If we're going to 
## python, let's do it right and get our edge detection
## done with that

## hah. into the best rabbit hole I know...


########################################################

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

## bring in our petal image:

bb = io.imread('P431F1_bottom_spots.png')
io.imshow(bb)
io.show()

cc = io.imread('P431F1_bottom_petal.png')
io.imshow(cc)
io.show()

edges = filters.sobel(bb)
io.imshow(edges)
io.show()

## okay, can we turn this into a polygon?

## meaning, can it be approximated into a 
## series of vertices? 

## what value are we chasing?

np.unique(edges)

## huh. 7 non-zero values...

contours = measure.find_contours(edges, 0.5)

type(contours)

contours[0].shape

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)


## almost works, but we're losing information by the png 
## conversion, methinks.

## so... back to octave/matlab:

####################################################

octave-cli

pkg load image

## get one grayscale image:

load("../dougRaster/Rotated_and_Cropped/P431F1.mat")
aa = mat2gray(Petals.Clusters.right);

Petals.Clusters.right

spots = aa < 1;
imshow(spots);

petal = aa == 0;
imshow(petal);

## save them as csv's:

csvwrite('P431F1petal.csv',petal)
csvwrite('P431F1spots.csv',spots)

%% and back to python...
#########################

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

petal = np.genfromtxt ('P431F1petal.csv', delimiter=",")
spots = np.genfromtxt ('P431F1spots.csv', delimiter=",")

np.unique(petal)

np.unique(spots)

## try spots

## can contours handle these directly?
contours = measure.find_contours(spots, 0)
for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.show()

## not bad, but still gaps...

contours = measure.find_contours(spots, 0)
for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

## same. Try finding the edges first:


edges = filters.sobel(spots)

io.imshow(edges)
io.show()

np.unique(edges)

contours = measure.find_contours(edges, 0.5)

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.show()

## same problem. can we add a margin of white to our 
## matrix?

## jog my memory, how to work with numpy again...

a = np.array([[1, 1], [2, 2], [3, 3]])

a
a = np.insert(a, 0, 5, 1)
a

a = np.array([[1, 1], [2, 2], [3, 3]])
np.insert(a, 0, 5, 0)

## rows are axis zero, columns axis one

a = np.array([[1, 1], [2, 2], [3, 3]])

a.shape
np.insert(a, 0, [6,6,6], 1)
np.insert(a, 2, [6,6,6], 1)

a = np.array([[1, 1], [2, 2], [3, 3]])
b = np.insert(a, 2, [6,6,6], 1) ## might be a more elegant way...

## can we add more than one column at a time?

a = np.array([[1, 1], [2, 2], [3, 3]])
b = np.insert(a, 2, [[5,5,5],[6,6,6]], 1)

## works, but probably better to build another matrix 
## and concatenate it 

## for our images, our polygons are black, = 0's

## so we want to add white space, or 1's. 

## seems pretty simple. try it with one of our images:


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

petal = np.genfromtxt ('P431F1petal.csv', delimiter=",")
spots = np.genfromtxt ('P431F1spots.csv', delimiter=",")

petal.shape
## (561, 439)

spots.shape
## same

## looks like the rows/columns are transposed 
## automatically by the scikit-image?

## to add one pixel of white to columns:
spots_marg = np.insert(spots, 439, 1, 1) 
spots_marg = np.insert(spots_marg, 0, 1, 1) 
## and rows:
spots_marg = np.insert(spots_marg, 561, 1, 0) 
spots_marg = np.insert(spots_marg, 0, 1, 0) 

spots.shape
spots_marg.shape


## does this help the detection of the polygons?

contours = measure.find_contours(spots_marg, 0)

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)


plt.show()


## to keep the relative positions accurate, we have to do the
## the same with the petal outline:

petal_marg = np.insert(petal, 439, 1, 1) 
petal_marg = np.insert(petal_marg, 0, 1, 1) 
## and rows:
petal_marg = np.insert(petal_marg, 561, 1, 0) 
petal_marg = np.insert(petal_marg, 0, 1, 0) 

Pcontours = measure.find_contours(petal_marg, 0)

## how does it look?:

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.plot(Pcontours[0][:,1], Pcontours[0][:,0], linewidth=1)

plt.show()

## looks good. 

## 1) Can we give these to Matlab?

## and if so, 

## 2) we need a script to generalize this. 

## 3) and a bash script that will work for anyone to repeat. 

## update notebook, then do these things. 

## okay, can we export one of these so that octave can read it?

## CSV is a little problematic, because we need a new for each 
## polygon.

## but building a json of nested arrays that python will make and 
## matlab will parse, sounds more tricky than I want to take on. 

np.savetxt("P431F1petal_polys.csv", contours) ## doesn't work

contours[0]

contours[0].astype(int)

## loop through the various polygons, save them individually?

photoname = 'P431F1'
partname  = 'spots'
petalname = 'bottom'

for n, contour in enumerate(contours):
    polyname = photoname + petalname + partname + str(n) + "_poly.csv"
    print(polyname)
    np.savetxt(fname=polyname, X=contour.astype(int), delimiter=',') 

## looks good. 

## so now the challenge is, given a single image, make a function 
## that exports the petal outline and all the respective 

## we start with..? a csv from matlab, which is the grayscale matrix
## of a single petal image:

## remember that as we have it here, we get a petal and a spots
## csv from matlab/octave. 

## but it is the same process for both. Make this agnostic: 


## get_pols.py
#################################3
#!/usr/bin/env python3

import argparse
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

## instantiate the argparser
parser = argparse.ArgumentParser()

## argument:
parser.add_argument('file', 
            help="Name of the .csv file from matlab that contains grayscale information about a petal.")

args = parser.parse_args()

## get our image in...
aa  = np.genfromtxt(args.file, delimiter = ",")

aR = aa.shape[0] ## number of rows
aC = aa.shape[1] ## number of cols

## add one pixel of white to rows:
aa_marg = np.insert(aa, aR, 1, 0)
aa_marg = np.insert(aa_marg, 0, 1, 0)
## and columns:
aa_marg = np.insert(aa_marg, aC, 1, 1)
aa_marg = np.insert(aa_marg, 0, 1, 1)

## find the contours:
contours = measure.find_contours(aa_marg, 0)

## save them out:

imageName = args.file[:-4] ## no file extension

for n, contour in enumerate(contours):
    polyname = imageName + "_poly" + str(n) + ".csv"
    np.savetxt(fname=polyname, X=contour.astype(int), delimiter=',')

#####################################

## try this out on one of our CSvs from matlab:

./get_pols.py P431F1spots.csv

## seems to work, but we'll need to check this
## out on matlab tomorrow. 

## how can we make this cleaner? We want to output
## to a folder...

## update notebook, fix tomorrow. 

###############################

## its tomorrow, again. 

## okay, so we need to make our script export all products into 
## a single folder. 

## let's work in the file itself...

./get_pols.py P431F1spots.csv

## 13 of them. is this the same as before?

## looks okay, I think. 

## works for our petal outline? 

./get_pols.py P431F1petal.csv

## works ok on the mac, looks like.

## switch over to matlab for a minute, can we plot our polygons 
## from this and do they look ok?

## if so, focus on getting all of doug's rasters into shape for 
## this script, 

## then run script on all of them. 

## want to run the matlab interpreter without the other junk
## but we gotta find our binaries apparently, doesn't add 
## anything to our path for us on the install...


## I hate matlab.

/Applications/MATLAB_R2018a.app/bin/matlab -nodisplay

## made an alias. should just work with:

matlab

%% now in matlab...

%% what do we want to do again?

wkd = '/Users/danthomas/Documents/speckling/make_polygons/';
%cd /Users/danthomas/Documents/speckling/make_polygons;
cd(wkd);
%name='P431F1petal';
name='P431F1spots';
cd(name);

%% empty vector to fill?

aa = []
counter=1
for i = 2:6;
    aa(counter) = i;
    counter = counter + 1;
end;


%% we need add these as cell arrays to
%% a single iterable structure..
%% so to read in these polygons:

aa = struct
counter = 1;
files = dir('*.csv');
for file = files';
    coords = csvread(file.name);
    aa(counter).coords=coords;
    counter = counter + 1;
end;

%% now to convert to polygons:

counter=1;
for i = aa';
    aa(counter).p = polyshape(aa(counter).coords);
    counter=counter+1;
end;
%% doesn't work, fails and doesn't retry
%% big ol fashioned ugly ifs and fors

counter=1;
for i = aa;
    disp(counter)
%    if length(aa(counter).coords) > 1;
        disp(i)
%    end;
    counter=counter+1;
end;


counter=1;
for i = aa;
disp(i)
end;

for i = 1:length(aa);
    size(aa(i).coords)
end

%% huh. all of the the three point ones aren't viable polygons

%% do we need them? We can increase the sensitivity of our polygon detection,
%% I'd imagine...

%% for the moment we plot them as lines?


%% I'm lost. What am I trying to do? 

%% trying to plot all the spots on a petal. Some of them are too thin to plot as polygons 
%% in matlab. 

%% I may have mentioned I fucking hate matlab. 

%% anyway, not matlab's fault. These are not polygons, they are lines. 

%% back up reset our structure:

aa = struct
counter = 1;
files = dir('*.csv');
for file = files';
    coords = csvread(file.name);
    aa(counter).coords=coords;
    counter = counter + 1;
end;

%% add polyshape if we can:

counter=1;
for i = aa;
    if length(i.coords(:,1)) > 3;
        aa(counter).p = polyshape(i.coords)
    end;
    counter=counter+1;
end;

%% can we plot this?

counter=1;
for i = aa;
    if ~isempty(i.p)
        plot(i.p)
        hold on
    end;
    counter=counter+1;
end;

%% add our petal outline:

Pcoords = csvread("/Users/danthomas/Documents/speckling/make_polygons/P431F1petal/P431F1petal_poly0.csv")
Ppoly = polyshape(Pcoords)
plot(Ppoly)


## lotsa work to do on this, but I think we're moving in the right direction...

##################

## okay, so back up. We need matlab to export the original petal and spots csv in a single folder, 
## so that our skimmage script can rip through them all at once. 

## and we need our skimmage script to handle a folder at a time. 

## then we need a matlab script to 


## looks like we probably need to learn about running matlab scripts from 
## the command line? 

## ugh, nah. Let's not. Others can do this if they want. 

## so first, let's get matlab to export petals and spots in two 
## matrices, in a folder:

%% separatePetPol.m
#############################

%% the goal here is grab all available petal images 
%% that have been through doug's raster transformations.
%% We make grayscle (0-1) matrices of his matrices, 
%% then "peel" them apart into spots and petal backgrounds.
%% these are then passed onto a python script for digitizing
%% the polygons.

%% first let's run through one image again
%% to output both matrices to a single, new folder:

%% following that, make it so all three petals are 
%% produced in their own folders, all within a 
%% single folder for each image

%% following that, make it so we can cycle through
%% all of our processed images

%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% go to working directory
wd = '/Users/danthomas/Documents/speckling/make_polygons/polygons/';
cd(wd);

dougRasterDir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

im = "P431F1.mat";
imName = regexprep(im,'\.mat', ''); 

%% go get our file, come back
cd(dougRasterDir);
rast=load(im);
cd(wd);

%% make a spot for our image, go to it:
mkdir(imName);
cd (imName);

%% get our petal names (left, right mid)
petNames = fieldnames(rast.Petals.Clusters);

%% split images into petal and spot, export, for each of the three petals:

for i = 1:length(petNames);
    pet = rast.Petals.Clusters.(petNames{i}); %petal at hand
    rastGray = mat2gray(pet); 
    spots = rastGray  < 1; 
    petal = rastGray == 0;
    mkdir(petNames{i});
    cd(petNames{i});
    fileNamePetal = imName + "_" +  petNames(i) + "_" + 'petal.csv';
    csvwrite(fileNamePetal,petal);
    fileNameSpots = imName + "_" +  petNames(i) + "_" + 'spots.csv';
    csvwrite(fileNameSpots,spots);
    cd ..;
end;

cd(wd);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%% generalize to catch all of dougs rasters

%%%%%%%%%%%%%%%%%%%%%%%%%%

%% a script to put all of Doug's rasters into a form we can use:

%% go to working directory
wd = '/Users/danthomas/Documents/speckling/make_polygons/polygons/';
cd(wd);

dougRasterDir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

cd(dougRasterDir)

files = dir('P*.mat');
for file = files';
    im = file.name;
    imName = regexprep(im,'\.mat', ''); 
    %% go get our file, come back
    cd(dougRasterDir);
    rast=load(im);
    cd(wd);
    %% make a spot for our image, go to it:
    mkdir(imName);
    cd (imName);
    %% get our petal names (left, right mid)
    petNames = fieldnames(rast.Petals.Clusters);
    %% split images into petal and spot, export, for each of the three petals:
    for i = 1:length(petNames);
        pet = rast.Petals.Clusters.(petNames{i}); %petal at hand
        rastGray = mat2gray(pet); 
        spots = rastGray  < 1; 
        petal = rastGray == 0;
        mkdir(petNames{i});
        cd(petNames{i});
        fileNamePetal = imName + "_" +  petNames(i) + "_" + 'petal.csv';
        csvwrite(fileNamePetal,petal);
        fileNameSpots = imName + "_" +  petNames(i) + "_" + 'spots.csv';
        csvwrite(fileNameSpots,spots);
        cd ..;
    end;
    cd(wd);
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

## think that worked...

## how do we check?

## back to python...

python

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

## some rando files to compare:

aa = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P247F1/right/P247F1_right_spots.csv'
bb = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P399F1/right/P399F1_right_spots.csv'
cc = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P399F1/left/P399F1_left_spots.csv'
dd = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P393F2/mid/P393F2_mid_spots.csv'
ee = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P257F2/left/P257F2_left_petal.csv'

## look at em

image = ee
sv = np.genfromtxt (image, delimiter=",")
contours = measure.find_contours(sv, 0)
for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.show()

## add a petal for cc
image = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P399F1/left/P399F1_left_petal.csv'
svp = np.genfromtxt (image, delimiter=",")
contoursp = measure.find_contours(svp, 0)
for n, contourp in enumerate(contoursp):
    plt.plot(contourp[:, 1], contourp[:, 0], linewidth=2)

## all looks good. 

## move on, digitize with python script... 

## okay, this script goes to home of each file, and builds directories right there, in place.

## so this will go to each of our blacknwhite matrices and build another folder in place with 
## a bunch of polygons 

## is this going to be hard to work with later?

## Probably. First let's just see if it works.

## How do we apply it all of our files? They are all buried in the nested folders...

## seems like a good use of find:

find ./ -name "P*csv" -type f  | wc -l
## hehzus, there 1080 of these. Is that right? 
## = 180 photos x 6, yup.

## sicking our script on these could be catastrophic... getting github uptodate...




