## let's try our vim script out

## symlink where gimp can find it:

ls /Users/danthomas/Documents/speckling/center/scriptfu/make_spot_polygons.scm 

ln -s /Users/danthomas/Documents/speckling/center/scriptfu/make_spot_polygons.scm "/Users/danthomas/Library/Application Support/GIMP/2.8/scripts/make_spot_polygons.scm" 

$gimp -i --verbose -b '(make_spot_polygons "/Users/danthomas/Documents/speckling/demo/test_spots3.png" "mooptest")' -b '(gimp-quit 0)'

## new install not working, missing "gdb". What is this? 

brew search gdb

brew info gdb

## then had to do a bunch of certificate stuff, info here: <https://sourceware.org/gdb/wiki/BuildingOnDarwin>

## to find out where gdb lives:

type -a gdb ## its in /usr/local/bin

## but 

ls -l /usr/local/bin/gdb

## its a soft link to our homebrew cellar:

ls -l /usr/local/Cellar/gdb/8.1/bin/gdb

## not writable. I want to keep it that way. So mac wants sudo or gui password input

codesign -s gdb-cert /usr/local/Cellar/gdb/8.1/bin/gdb

## okay, did this help?

$gimp -i --verbose -b '(make_spot_polygons "/Users/danthomas/Documents/speckling/demo/test_spots3.png" "mooptest")' -b '(gimp-quit 0)'

## and then a mountain of errors from gdb, about shared library incompatibilites. 

## meh. fuck all that. The command line will not work for my setup. It's not worth the time
## to now debug gdb for my setup. Too deep for me. 

## let's try just using the console while gimp is running. Then maybe we can make a macro 
## instead of a script. 

## example file: "/Users/danthomas/Documents/speckling/demo/test_spots3.png"

    (let* (
            ;; load files, set vars
            (image (car (gimp-file-load 
                                0 
                                "/Users/danthomas/Documents/speckling/demo/test_spots3.png" 
                                "/Users/danthomas/Documents/speckling/demo/test_spots3.png") ) )
            (drawable (car (gimp-image-get-active-layer image)))
          )
            ;; do stuff
            ;;1 select black/solid regions:
            (gimp-image-select-color 
                image
                CHANNEL-OP-REPLACE
                drawable
                '(0 0 0) ;; black
            ) ;'
            ;;2 Convert selection to path
            (plug-in-sel2path
                RUN-NONINTERACTIVE
                image
                drawable
            ) 
            ;;3 save path to file
        (gimp-vectors-export-to-file
            image
            "/Users/danthomas/Documents/speckling/make_polygons/spots_script_test.svg"
            0 ;; all vectors
        )
)

## so that works for copying and pasting to the console in GIMP.

## we need to either write a macro for running in the GUI that can handle lots of images or 
## try again with the command line. 


## I personally like the idea of the latter. But I still have no idea 
## how to run gimp command line from the terminal

## can we run the above from the terminal?


## we need to put a copy (symlink) where git wants it:

ln -s /Users/danthomas/Documents/speckling/make_polygons/make_spot_polygons.scm \
"/Users/danthomas/Library/Application Support/GIMP/2.10/scripts/make_spot_polygons.scm"

ls -l "/Users/danthomas/Library/Application Support/GIMP/2.10/scripts/"


ls /Applications/Gimp-2.10.app/Contents/MacOS/gimp-console-2.10

/Applications/Gimp-2.10.app/Contents/MacOS/gimp-console-2.10

## theoretically, we should be able to run this like so:
~/GIMP.app/Contents/MacOS/gimp-2.8 -i

## none of the above works. As before. I think the best strategy here is to try this on my
## linux machine, see if the same bugs pop up. 
cd /home/daniel/mimulusSpeckling/make_polygons


## all the above was for the lab mac. 

## try again with my linux laptop

## where to put gimp scripts on my laptop?

## here I think:
cd ~/.gimp-2.8/scripts

ls -al ~/.gimp-2.8/scripts

ln -s /home/daniel/mimulusSpeckling/make_polygons/make_spot_polygons.scm ~/.gimp-2.8/scripts/make_spot_polygons.scm 

## can we run it?


gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## let's do a test with a script from online:

gimp -i -b '(test-script "foo.png" 5.0 0.5 0)' -b '(gimp-quit 0)'

## okay works...why not ours?

## why is the the script name parsed as an undeclared variable?

cd ../demo
gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'
## nope

## is it because it is a symlink?

cp /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm /home/daniel/.gimp-2.8/scripts/

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## ah, that worked!
## is this a permission issue?

chmod 777 /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm

## try again

ln -s /home/daniel/mimulusSpeckling/make_polygons/makePetalPoly.scm ~/.gimp-2.8/scripts/makePetalPoly.scm 

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## yep. I feel pretty stupid. But good to know that symlink permissions 
## don't really mean anything

## sweet, so:

## 1 edit script to export other filenames that are related to the entered file
## 2 find a way to handle multiple files - either with bash or in scriptfu

## 1 should be simple?

## okay, works. 

#######################################

## back up. We need to use Doug's structures to generate binary pngs 
## that gimp will like. 

## since matlab sucks, as in not-free and license issues are complex
## even when paid for, we'll try octave here

## I'm waiting on the math department to talk to me about the desktop
## license at the lab.`

octave-cli

## get one of Doug's data structures:

load("/home/daniel/Documents/mimulusSpeckling/dougRaster/Rotated_and_Cropped/P431F1.mat")

Petals

fieldnames(Petals)

Petals.left

fieldnames(Petals.left)

Petals.left.data

## can we turn this into an image?

fieldnames(Petals.right)

fieldnames(Petals.Clusters)

Petals.Clusters.left

imshow(Petals.Clusters.left) %% doesn't work

image(Petals.Clusters.left) %% works. Don't know why

image(Petals.Clusters.right); colorbar

%% get the image package 
pkg load image

aa = mat2gray(Petals.Clusters.right);

imshow(aa) %% that works. 

unique(aa) %% all values transformed to between 1 and 0. 
%% 1 is white, 0 is black

%% now we want a petal and a spot image. To do this:

%% get the spot shapes as black, background as white:
bb = aa < 1;
imshow(bb); 

%% petals black with white background
cc = aa == 0;
imshow(cc); 

%% okay. These should be digestable for our GIMP scripts. 

%% export:

imwrite(bb, 'P431F1_bottom_spots.png') %% some quality warnings. 
imwrite(cc, 'P431F1_bottom_petal.png')

%% can we get these to gimp now, and get svgs for both?

## shell/gimp

## ugh, got to remember how to use Gimp from command line 
## with our script...

## we have our scriptfu for this, does this work?:

gimp -i -b '(makePetalPoly "P431F1_bottom_spots.png")' -b '(gimp-quit 0)'

## nope.  What changed? the old command that worked:

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## doesn't work now... did I change something accidentally?

git log makePetalPoly.scm


## not really. The file worked on the last day it was modified.

## can we bring up the older versions, see if they work?

git checkout 759701d0688c1c08e76ca876dc25d08e122b09c4 makePetalPoly.scm

gimp -i -b '(makePetalPoly "test_spots3.png")' -b '(gimp-quit 0)'

## nope. What changed?

## looks like the link might be dead...

ln -s /home/daniel/Documents/mimulusSpeckling/make_polygons/makePetalPoly.scm /home/daniel/.gimp-2.8/scripts/makePetalPoly.scm

## work now?

gimp -i -b '(makePetalPoly "P431F1_bottom_spots.png")' -b '(gimp-quit 0)'

## yup, works. Note to self, watch those directory changes...remember they fuck with links 

## now can we flatten the svg bezier curves?

## ugh, all this would be so much more elegant with python. 
## http://scikit-image.org/docs/dev/api/skimage.draw.html

## anyway..

## so with svg bezier curves, we want to be rid of the control points 
## leave just the terminal points

## first get the svg to work,
## then figure out how to clean it all out so matlab can read it.

cp P431F1_bottom_spots.png_path.svg test.svg

## for svg, to flatten the beziers,
## change all C's to L's
## and get rid of the control points (keep only the first set of coordinates)

sed '/^\s*C/ s/C\s/L /' test.svg | \
sed -e 's/\([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\) \([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\) \([0-9]*\.[0-9]*,[0-9]*\.[0-9]*\)/\1/g' > test2.svg

## okay, that seems to work...but the paths have been clipped somehow, which leaves 
## unclosed polygons. This must have happened during the gimp export?

## nope, the svg with the beziers is not broken, at least according to inkscape.
## so we introduced this with our SED modification

tail test.svg

tail test2.svg

## actually, it's ok. The svg lines do close up in both files, you just have to
## expand the svg canvas to see a little. 

## ok, relief. So...what do we need for matlab to understand that these are 
## polygons?

## gimp needs two vectors, x and y. 

## how can we convert our svg to this? 

## a couple of problems here.

## 1) get rid of chaff - remove all the non-drawing directions
## 2) break up the respective polygons
## 3) convert each polygon to two vectors, x and y. 

## this really needs some python. Sorry Doug. 

## which probably means we should back up and use a 
## single python script to fix our svgs in general
## (so I just spent an hour on a SED regex I don't need).
## good news is that the script should be fairly straight forward.

## actually, why use svgs at all? If we're going to 
## python, let's do it right and get our edge detection
## done with that

## hah. into the best rabbit hole I know...


########################################################

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

## bring in our petal image:

bb = io.imread('P431F1_bottom_spots.png')
io.imshow(bb)
io.show()

cc = io.imread('P431F1_bottom_petal.png')
io.imshow(cc)
io.show()

edges = filters.sobel(bb)
io.imshow(edges)
io.show()

## okay, can we turn this into a polygon?

## meaning, can it be approximated into a 
## series of vertices? 

## what value are we chasing?

np.unique(edges)

## huh. 7 non-zero values...

contours = measure.find_contours(edges, 0.5)

type(contours)

contours[0].shape

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)


## almost works, but we're losing information by the png 
## conversion, methinks.

## so... back to octave/matlab:

####################################################

octave-cli

pkg load image

## get one grayscale image:

load("../dougRaster/Rotated_and_Cropped/P431F1.mat")
aa = mat2gray(Petals.Clusters.right);

Petals.Clusters.right

spots = aa < 1;
imshow(spots);

petal = aa == 0;
imshow(petal);

## save them as csv's:

csvwrite('P431F1petal.csv',petal)
csvwrite('P431F1spots.csv',spots)

%% and back to python...
#########################

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

petal = np.genfromtxt ('P431F1petal.csv', delimiter=",")
spots = np.genfromtxt ('P431F1spots.csv', delimiter=",")

np.unique(petal)

np.unique(spots)

## try spots

## can contours handle these directly?
contours = measure.find_contours(spots, 0)
for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.show()

## not bad, but still gaps...

contours = measure.find_contours(spots, 0)
for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

## same. Try finding the edges first:


edges = filters.sobel(spots)

io.imshow(edges)
io.show()

np.unique(edges)

contours = measure.find_contours(edges, 0.5)

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.show()

## same problem. can we add a margin of white to our 
## matrix?

## jog my memory, how to work with numpy again...

a = np.array([[1, 1], [2, 2], [3, 3]])

a
a = np.insert(a, 0, 5, 1)
a

a = np.array([[1, 1], [2, 2], [3, 3]])
np.insert(a, 0, 5, 0)

## rows are axis zero, columns axis one

a = np.array([[1, 1], [2, 2], [3, 3]])

a.shape
np.insert(a, 0, [6,6,6], 1)
np.insert(a, 2, [6,6,6], 1)

a = np.array([[1, 1], [2, 2], [3, 3]])
b = np.insert(a, 2, [6,6,6], 1) ## might be a more elegant way...

## can we add more than one column at a time?

a = np.array([[1, 1], [2, 2], [3, 3]])
b = np.insert(a, 2, [[5,5,5],[6,6,6]], 1)

## works, but probably better to build another matrix 
## and concatenate it 

## for our images, our polygons are black, = 0's

## so we want to add white space, or 1's. 

## seems pretty simple. try it with one of our images:


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

petal = np.genfromtxt ('P431F1petal.csv', delimiter=",")
spots = np.genfromtxt ('P431F1spots.csv', delimiter=",")

petal.shape
## (561, 439)

spots.shape
## same

## looks like the rows/columns are transposed 
## automatically by the scikit-image?

## to add one pixel of white to columns:
spots_marg = np.insert(spots, 439, 1, 1) 
spots_marg = np.insert(spots_marg, 0, 1, 1) 
## and rows:
spots_marg = np.insert(spots_marg, 561, 1, 0) 
spots_marg = np.insert(spots_marg, 0, 1, 0) 

spots.shape
spots_marg.shape


## does this help the detection of the polygons?

contours = measure.find_contours(spots_marg, 0)

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)


plt.show()


## to keep the relative positions accurate, we have to do the
## the same with the petal outline:

petal_marg = np.insert(petal, 439, 1, 1) 
petal_marg = np.insert(petal_marg, 0, 1, 1) 
## and rows:
petal_marg = np.insert(petal_marg, 561, 1, 0) 
petal_marg = np.insert(petal_marg, 0, 1, 0) 

Pcontours = measure.find_contours(petal_marg, 0)

## how does it look?:

for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.plot(Pcontours[0][:,1], Pcontours[0][:,0], linewidth=1)

plt.show()

## looks good. 

## 1) Can we give these to Matlab?

## and if so, 

## 2) we need a script to generalize this. 

## 3) and a bash script that will work for anyone to repeat. 

## update notebook, then do these things. 

## okay, can we export one of these so that octave can read it?

## CSV is a little problematic, because we need a new for each 
## polygon.

## but building a json of nested arrays that python will make and 
## matlab will parse, sounds more tricky than I want to take on. 

np.savetxt("P431F1petal_polys.csv", contours) ## doesn't work

contours[0]

contours[0].astype(int)

## loop through the various polygons, save them individually?

photoname = 'P431F1'
partname  = 'spots'
petalname = 'bottom'

for n, contour in enumerate(contours):
    polyname = photoname + petalname + partname + str(n) + "_poly.csv"
    print(polyname)
    np.savetxt(fname=polyname, X=contour.astype(int), delimiter=',') 

## looks good. 

## so now the challenge is, given a single image, make a function 
## that exports the petal outline and all the respective 

## we start with..? a csv from matlab, which is the grayscale matrix
## of a single petal image:

## remember that as we have it here, we get a petal and a spots
## csv from matlab/octave. 

## but it is the same process for both. Make this agnostic: 


## get_pols.py
#################################3
#!/usr/bin/env python3

import argparse
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

## instantiate the argparser
parser = argparse.ArgumentParser()

## argument:
parser.add_argument('file', 
            help="Name of the .csv file from matlab that contains grayscale information about a petal.")

args = parser.parse_args()

## get our image in...
aa  = np.genfromtxt(args.file, delimiter = ",")

aR = aa.shape[0] ## number of rows
aC = aa.shape[1] ## number of cols

## add one pixel of white to rows:
aa_marg = np.insert(aa, aR, 1, 0)
aa_marg = np.insert(aa_marg, 0, 1, 0)
## and columns:
aa_marg = np.insert(aa_marg, aC, 1, 1)
aa_marg = np.insert(aa_marg, 0, 1, 1)

## find the contours:
contours = measure.find_contours(aa_marg, 0)

## save them out:

imageName = args.file[:-4] ## no file extension

for n, contour in enumerate(contours):
    polyname = imageName + "_poly" + str(n) + ".csv"
    np.savetxt(fname=polyname, X=contour.astype(int), delimiter=',')

#####################################

## try this out on one of our CSvs from matlab:

./get_pols.py P431F1spots.csv

## seems to work, but we'll need to check this
## out on matlab tomorrow. 

## how can we make this cleaner? We want to output
## to a folder...

## update notebook, fix tomorrow. 

###############################

## its tomorrow, again. 

## okay, so we need to make our script export all products into 
## a single folder. 

## let's work in the file itself...

./get_pols.py P431F1spots.csv

## 13 of them. is this the same as before?

## looks okay, I think. 

## works for our petal outline? 

./get_pols.py P431F1petal.csv

## works ok on the mac, looks like.

## switch over to matlab for a minute, can we plot our polygons 
## from this and do they look ok?

## if so, focus on getting all of doug's rasters into shape for 
## this script, 

## then run script on all of them. 

## want to run the matlab interpreter without the other junk
## but we gotta find our binaries apparently, doesn't add 
## anything to our path for us on the install...


## I hate matlab.

/Applications/MATLAB_R2018a.app/bin/matlab -nodisplay

## made an alias. should just work with:

matlab

%% now in matlab...

%% what do we want to do again?

wkd = '/Users/danthomas/Documents/speckling/make_polygons/';
%cd /Users/danthomas/Documents/speckling/make_polygons;
cd(wkd);
%name='P431F1petal';
name='P431F1spots';
cd(name);

%% empty vector to fill?

aa = []
counter=1
for i = 2:6;
    aa(counter) = i;
    counter = counter + 1;
end;


%% we need add these as cell arrays to
%% a single iterable structure..
%% so to read in these polygons:

aa = struct
counter = 1;
files = dir('*.csv');
for file = files';
    coords = csvread(file.name);
    aa(counter).coords=coords;
    counter = counter + 1;
end;

%% now to convert to polygons:

counter=1;
for i = aa';
    aa(counter).p = polyshape(aa(counter).coords);
    counter=counter+1;
end;
%% doesn't work, fails and doesn't retry
%% big ol fashioned ugly ifs and fors

counter=1;
for i = aa;
    disp(counter)
%    if length(aa(counter).coords) > 1;
        disp(i)
%    end;
    counter=counter+1;
end;


counter=1;
for i = aa;
disp(i)
end;

for i = 1:length(aa);
    size(aa(i).coords)
end

%% huh. all of the the three point ones aren't viable polygons

%% do we need them? We can increase the sensitivity of our polygon detection,
%% I'd imagine...

%% for the moment we plot them as lines?


%% I'm lost. What am I trying to do? 

%% trying to plot all the spots on a petal. Some of them are too thin to plot as polygons 
%% in matlab. 

%% I may have mentioned I fucking hate matlab. 

%% anyway, not matlab's fault. These are not polygons, they are lines. 

%% back up reset our structure:

aa = struct
counter = 1;
files = dir('*.csv');
for file = files';
    coords = csvread(file.name);
    aa(counter).coords=coords;
    counter = counter + 1;
end;

%% add polyshape if we can:

counter=1;
for i = aa;
    if length(i.coords(:,1)) > 3;
        aa(counter).p = polyshape(i.coords)
    end;
    counter=counter+1;
end;

%% can we plot this?

counter=1;
for i = aa;
    if ~isempty(i.p)
        plot(i.p)
        hold on
    end;
    counter=counter+1;
end;

%% add our petal outline:

Pcoords = csvread("/Users/danthomas/Documents/speckling/make_polygons/P431F1petal/P431F1petal_poly0.csv")
Ppoly = polyshape(Pcoords)
plot(Ppoly)


## lotsa work to do on this, but I think we're moving in the right direction...

##################

## okay, so back up. We need matlab to export the original petal and spots csv in a single folder, 
## so that our skimmage script can rip through them all at once. 

## and we need our skimmage script to handle a folder at a time. 

## then we need a matlab script to 


## looks like we probably need to learn about running matlab scripts from 
## the command line? 

## ugh, nah. Let's not. Others can do this if they want. 

## so first, let's get matlab to export petals and spots in two 
## matrices, in a folder:

%% separatePetPol.m
#############################

%% the goal here is grab all available petal images 
%% that have been through doug's raster transformations.
%% We make grayscle (0-1) matrices of his matrices, 
%% then "peel" them apart into spots and petal backgrounds.
%% these are then passed onto a python script for digitizing
%% the polygons.

%% first let's run through one image again
%% to output both matrices to a single, new folder:

%% following that, make it so all three petals are 
%% produced in their own folders, all within a 
%% single folder for each image

%% following that, make it so we can cycle through
%% all of our processed images

%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% go to working directory
wd = '/Users/danthomas/Documents/speckling/make_polygons/polygons/';
cd(wd);

dougRasterDir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

im = "P431F1.mat";
imName = regexprep(im,'\.mat', ''); 

%% go get our file, come back
cd(dougRasterDir);
rast=load(im);
cd(wd);

%% make a spot for our image, go to it:
mkdir(imName);
cd (imName);

%% get our petal names (left, right mid)
petNames = fieldnames(rast.Petals.Clusters);

%% split images into petal and spot, export, for each of the three petals:

for i = 1:length(petNames);
    pet = rast.Petals.Clusters.(petNames{i}); %petal at hand
    rastGray = mat2gray(pet); 
    spots = rastGray  < 1; 
    petal = rastGray == 0;
    mkdir(petNames{i});
    cd(petNames{i});
    fileNamePetal = imName + "_" +  petNames(i) + "_" + 'petal.csv';
    csvwrite(fileNamePetal,petal);
    fileNameSpots = imName + "_" +  petNames(i) + "_" + 'spots.csv';
    csvwrite(fileNameSpots,spots);
    cd ..;
end;

cd(wd);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%% generalize to catch all of dougs rasters

%%%%%%%%%%%%%%%%%%%%%%%%%%

%% a script to put all of Doug's rasters into a form we can use:

%% go to working directory
wd = '/Users/danthomas/Documents/speckling/make_polygons/polygons/';
cd(wd);

dougRasterDir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

cd(dougRasterDir)

files = dir('P*.mat');
for file = files';
    im = file.name;
    imName = regexprep(im,'\.mat', ''); 
    %% go get our file, come back
    cd(dougRasterDir);
    rast=load(im);
    cd(wd);
    %% make a spot for our image, go to it:
    mkdir(imName);
    cd (imName);
    %% get our petal names (left, right mid)
    petNames = fieldnames(rast.Petals.Clusters);
    %% split images into petal and spot, export, for each of the three petals:
    for i = 1:length(petNames);
        pet = rast.Petals.Clusters.(petNames{i}); %petal at hand
        rastGray = mat2gray(pet); 
        spots = rastGray  < 1; 
        petal = rastGray == 0;
        mkdir(petNames{i});
        cd(petNames{i});
        fileNamePetal = imName + "_" +  petNames(i) + "_" + 'petal.csv';
        csvwrite(fileNamePetal,petal);
        fileNameSpots = imName + "_" +  petNames(i) + "_" + 'spots.csv';
        csvwrite(fileNameSpots,spots);
        cd ..;
    end;
    cd(wd);
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

## think that worked...

## how do we check?

## back to python...

python

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure

## some rando files to compare:

aa = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P247F1/right/P247F1_right_spots.csv'
bb = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P399F1/right/P399F1_right_spots.csv'
cc = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P399F1/left/P399F1_left_spots.csv'
dd = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P393F2/mid/P393F2_mid_spots.csv'
ee = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P257F2/left/P257F2_left_petal.csv'

## look at em

image = ee
sv = np.genfromtxt (image, delimiter=",")
contours = measure.find_contours(sv, 0)
for n, contour in enumerate(contours):
    plt.plot(contour[:, 1], contour[:, 0], linewidth=2)

plt.show()

## add a petal for cc
image = '/Users/danthomas/Documents/speckling/make_polygons/polygons/P399F1/left/P399F1_left_petal.csv'
svp = np.genfromtxt (image, delimiter=",")
contoursp = measure.find_contours(svp, 0)
for n, contourp in enumerate(contoursp):
    plt.plot(contourp[:, 1], contourp[:, 0], linewidth=2)

## all looks good. 

## move on, digitize with python script... 

## okay, this script goes to home of each file, and builds directories right there, in place.

## so this will go to each of our blacknwhite matrices and build another folder in place with 
## a bunch of polygons 

## is this going to be hard to work with later?

## Probably. First let's just see if it works.

## How do we apply it all of our files? They are all buried in the nested folders...

## seems like a good use of find:

find ./ -name "P*csv" -type f  | wc -l
## hehzus, there 1080 of these. Is that right? 
## = 180 photos x 6, yup.

## sicking our script on these could be catastrophic... getting github uptodate...


find ../polygons/ -name "P*csv" -type f  -exec ./get_pols.py {} \;

## no errors reporting .. how do we check if we did a good job? 

## be sure to update get_pol.py  script on notebook when next we go there..

## let's let that run tonight...

## maybe we can do the commit/push remotely...

#######################################

##  update notebook


## branch

## then check these with matlab, and meld with doug's matlab structures

## how to do this, in matlab?...

## for each image:

%% 1) load doug matlab structure of image
%% 2) load all associated polygons and petal outlines csvs as matlab polyshapes 
%% 3) add these to doug's matlab stuctures



%% try just one:

wd = '/Users/danthomas/Documents/speckling/make_polygons/'
cd(wd)

dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

im = "P369F1";
pos='mid';
%typPol='spots';
typPol='petal';
imStructF = dougdir + im + ".mat";



%% how do we get a list of matlab structures of interest (images as structures)?

cd(dougdir)
files = dir('P*.mat');
for file = files';
    im = regexprep(file.name,'\.mat', ''); 
    disp(file.name + " " + im)
end;
%% works

load(imStructF)

wd + "tryscript/" + im + '_' + pos + '_' + typPol

%%"mid" (actually "right") petal:

aa = mat2gray(Petals.Clusters.mid);
imshow(aa)

%% there's a hole in this spot, I wonder how our python script
%% dealt with that. We'll see in a minute...

%% what are our accompanying python-defined csv?

%% two directories we need are:

"tryScript/P369F1_mid_petal"
"tryScript/P369F1_mid_spots"

%% could be restated as:

wd + "tryscript/" + im + '_' + pos + '_' + typPol

ls(wd + "tryscript/" + im + '_' + pos + '_' + typPol) %% seems to work

%% seems like it would be simplest to construct a structure that contains
%% all of our spot and petal polygons, then add this to the existing 
%% doug matlab structure for that image. 

%% 1) get image name from list of mat files in dougdir
%% 2) load and convert all the pertinent csvs to polyshapes
%% 3) save together in a structure
%% 4) add this to dougs existing structure

%% for 2, how do we find all the pertinent files?

%% im is scrounged off the file name, then...

dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";
wd = '/Users/danthomas/Documents/speckling/make_polygons/'
petNames = ["left", "mid", "right"];
typPols = ["petal", "spots"];

im = "P369F1";

cd(wd)
Polys = struct;
for i = petNames;
    for j = typPols;
        imdir = "tryScript/" + im + "_" + i + "_" + j;
        cd(imdir);
        files = dir('P*.csv');
        counter = 1;
        for file = files';
            disp(file.name)
            disp(counter)
            coords=csvread(file.name);
            if length(coords(:,1)) > 3; %% if there are enough points
                Polys.(i).(j)(counter) = polyshape(coords); %% convert to polyshape
                counter=counter+1;
            end;
        end;
    cd(wd)
    end;
end;

%% that seems to work. how would we add it?

%% one of Doug's structures looks like:


load ('/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P431F2.mat')

aa = load ('/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P431F2.mat')

save

bb = 'loop';
cc = 'poop';

save('test.mat', 'bb', 'cc')

clear(bb, cc)

load('test.mat')

%% just load the mat file of interest, and add the above as a field.

im = "P369F1";
aa = load(dougdir + im + ".mat");

%% add our polyshapes to it:

aa.Petals

aa.Petals.polys = Polys;

aa.Petals.polys

%% then save it back out. Does our naming the structure accidentally add a layer to our structure?
save("aatest.mat", "aa")
clear(aa)
load("aatest.mat")
%% yup. 

%% seems like maybe we just deal with files one at time here.

load(dougdir + im + ".mat");
Petals.Polys = Polys;
save(imFile,"Petals")


%% where shall we save these?


imFile = wd + "matObjW_pol/" + im + ".mat";

save(imFile,"Petals")

clear Petals

load(imFile)

%% works. Can we loop it?


dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";
wd = '/Users/danthomas/Documents/speckling/make_polygons/';
petNames = ["left", "mid", "right"];
typPols = ["petal", "spots"];

cd(dougdir)
hs = dir('P*.mat');
for h = hs';
    im = regexprep(h.name,'\.mat', ''); 
    cd(wd)
    Polys = struct;
    for i = petNames;
        for j = typPols;
            imdir = "tryScript/" + im + "_" + i + "_" + j;
            cd(imdir);
            files = dir('P*.csv');
            counter = 1;
            for file = files';
                disp(file.name)
                disp(counter)
                coords=csvread(file.name);
                if length(coords(:,1)) > 3; %% if there are enough points
                    Polys.(i).(j)(counter) = polyshape(coords); %% convert to polyshape
                    counter=counter+1;
                end;
            end;
        cd(wd)
        end;
    end;
    load(dougdir + im + ".mat"); %% get doug's matlab structure
    Petals.Polys = Polys; %% add our new Polys structure inside it
    imFile = wd + "matObjW_pol/" + im + ".mat"; %% save the modified structure 
    save(imFile,"Petals");
end;

%% did that work?

%% how to check a few of these?

%% import the 

im = "P369F1";
aa = load(dougdir + im + ".mat");

load("/Users/danthomas/Documents/speckling/make_polygons/matObjW_pol/P440F1.mat")

%% iterate through our petal outline and spots 

for i = Petals.Polys.left.petal
    if ~isempty(i)
        plot(i)
        hold on %% keep the plot open
    end;
end;

for i = Petals.Polys.left.spots
    if ~isempty(i)
        plot(i)
        hold on %% keep the plot open
    end;
end;


%%, but as Arielle mentioned, polygons are getting merged. 

%% let's see how common and how badly. 


%% can we make a function for viewing all three stages of the 
%% process. 

%% to just view the original jpeg?

cd /Users/danthomas/Documents/speckling/make_polygons/matObjW_pol 

files = dir('P*.mat');
counter = 1;
for file = files';
    disp(file.name)
end;


load('P434F1.mat')


dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";

dougdir = '/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/';
[a,b,c] = fileparts(Petals.fullName);
jpegName = dougdir + b + c;

aa = imread("/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P434F1.JPG") %% doesn't work

aa = imread('/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P434F1.JPG') %% works...

ls "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P434F1.JPG"

ls '/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/P434F1.JPG'



a = 'zzop';
b = "zzop";

class(a) %% single quote, = char
class(b) %% double quote, = string

a(1)
b(1)

%% so double quotes save the entire word as a unite (=string),
%% and single quotes save the word as a string of letters (=letter)

wd="/Users/danthomas/Documents/speckling/make_polygons/matObjW_pol"
cd(wd)

%load('P434F1.mat')

load('P248F2.mat')

dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/";
[a,b,c] = fileparts(Petals.fullName);
jpegName = char(dougdir + b + c); %% gotta be a character object
jpegN = imread(jpegName) ;

imshow(jpegN)

[a,b,c] = fileparts(Petals.fullName);
jpegName = char(dougdir + b + c); %% gotta be a character object?
jpegN = imread(jpegName);
    %% plot a page:
    figure;
    %%%%%%%%% first row %%%%%%%%%%%%%%%
    subplot(3,3,[1,3]);
    imshow(jpegN);
    title(b) %% this is our plot title
    %%%%%%%%% second row %%%%%%%%%%%%%
    subplot(3,3,4);
    aa = mat2gray(Petals.Clusters.left);
    imshow(aa) 
    subplot(3,3,5);
    aa = mat2gray(Petals.Clusters.mid);
    imshow(aa) 
    subplot(3,3,6);
    aa = mat2gray(Petals.Clusters.right);
    imshow(aa) 
    %%%%%%%%%% third row %%%%%%%%%%%%%%
    subplot(3,3,7);
        if isfield(Petals.Polys.left,'petal');
        for i = Petals.Polys.left.petal;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        if isfield(Petals.Polys.left,'spots');
        for i = Petals.Polys.left.spots;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        daspect([1 1 1])
    subplot(3,3,8);
        if isfield(Petals.Polys.mid,'petal');
        for i = Petals.Polys.mid.petal;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        if isfield(Petals.Polys.mid,'spots');
        for i = Petals.Polys.mid.spots;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        daspect([1 1 1])
    subplot(3,3,9);
        if isfield(Petals.Polys.right,'petal');
        for i = Petals.Polys.right.petal;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
            end;
        end; end;
        if isfield(Petals.Polys.right,'spots');
        for i = Petals.Polys.right.spots;
            if ~isempty(i);
                plot(i);
                hold on %% keep the plot open;
        daspect([1 1 1])
    %%%%%%%%%%%%%%

%% can we export to pdf?

print("test.pdf",'-dpdf', '-fillpage')

%% works. Can we loop through, make them all?

wd="/Users/danthomas/Documents/speckling/make_polygons/matObjW_pol"  %% right now our structures live here
dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/"; %% but original images here
pdfDir = "/Users/danthomas/Documents/speckling/make_polygons/bigPDF/"; %% we'll put pdfs here
cd(wd)

files = dir('P*.mat');
for file = files';
    %% get things loaded
    load(file.name)
    [a,b,c] = fileparts(Petals.fullName);
    jpegName = char(dougdir + b + c); %% gotta be a character object?
    pdfName = pdfDir + b + ".pdf"; %% doesn't have to be a character object?
    jpegN = imread(jpegName);
        %% plot a page:
        figure;
        %%%%%%%%% first row %%%%%%%%%%%%%%%
        subplot(3,3,[1,3]);
        imshow(jpegN);
        title(b) %% this is our plot title
        %%%%%%%%% second row %%%%%%%%%%%%%
        subplot(3,3,4);
        aa = mat2gray(Petals.Clusters.left);
        imshow(aa) 
        subplot(3,3,5);
        aa = mat2gray(Petals.Clusters.mid);
        imshow(aa) 
        subplot(3,3,6);
        aa = mat2gray(Petals.Clusters.right);
        imshow(aa) 
        %%%%%%%%%% third row %%%%%%%%%%%%%%
        subplot(3,3,7);
            if isfield(Petals.Polys.left,'petal');
            for i = Petals.Polys.left.petal;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            if isfield(Petals.Polys.left,'spots');
            for i = Petals.Polys.left.spots;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            daspect([1 1 1])
        subplot(3,3,8);
            if isfield(Petals.Polys.mid,'petal');
            for i = Petals.Polys.mid.petal;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            if isfield(Petals.Polys.mid,'spots');
            for i = Petals.Polys.mid.spots;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            daspect([1 1 1])
        subplot(3,3,9);
            if isfield(Petals.Polys.right,'petal');
            for i = Petals.Polys.right.petal;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            if isfield(Petals.Polys.right,'spots');
            for i = Petals.Polys.right.spots;
                if ~isempty(i);
                    plot(i);
                    hold on %% keep the plot open;
                end;
            end; end;
            daspect([1 1 1])
        %%%%%%%%%%%%%%
    %% print as a pdf page
    print(pdfName,'-dpdf', '-fillpage')
    close %% added after running, not sure if this works
end;


%% horribly inefficient, but it worked. 


## to join these, try the built in script that comes with mac OS for this:

/System/Library/Automator/Combine\ PDF\ Pages.action/Contents/Resources/join.py -o PolyPipeline_140818.pdf ./bigPDF/*

## so now what? 

## the polygons are flawed, but it would be nice to have something to show about centering, etc

## what is a good one to look at? Which ones made it through the pipeline without issues?

%% back into matlab

%% P416F1 looks simple and well-digitized:

wd="/Users/danthomas/Documents/speckling/make_polygons/matObjW_pol/"  %% right now our structures live here
dougdir = "/Users/danthomas/Documents/speckling/dougRaster/Rotated_and_Cropped/"; %% but original images here
pdfDir = "/Users/danthomas/Documents/speckling/make_polygons/bigPDF/"; %% we'll put pdfs here
cd(wd)
file = wd + "P416F1.mat";
load(file);

%% how to mark the centroid of the petal?

pet = Petals.Polys.right.petal(1);
spotz = Petals.Polys.right.spots;
%% put all the spots into an array
allSpots = union(spotz);
%% Centroids
[x,y] = centroid(pet);
[v,w] = centroid(allSpots);
X=[x v];
Y=[y w];

%% plot polys
ppet = plot(pet);
ppet.FaceColor = [1 1 0];
ppet.FaceAlpha = 0.4;
hold on;
pg = plot(allSpots);
pg.FaceColor = 'red';
p3.FaceAlpha = 1;
hold on;

hold off;

%% plot centroids

%% make the line
plot(X, Y,...
    'LineWidth',2,...
    'Color','black');
hold on;
%% petal centroid
plot(x,y, 'o', 'MarkerSize', 15,...
    'MarkerEdgeColor','black',...
    'MarkerFaceColor','yellow')
    hold on 
%% polygon centroid
plot(x,y, '+', 'MarkerSize', 15,...
    'MarkerEdgeColor','black')
    hold on 
plot(v,w, 'o', 'MarkerSize', 15,...
    'MarkerEdgeColor','black',...
    'MarkerFaceColor','red')
    hold on
plot(v,w, '+', 'MarkerSize', 15,...
    'MarkerEdgeColor','black')
    hold off


%%%%%%%%%%%%%%%%%%%%%%


pdist(X, Y)




[x,y] = centroid(pet);





%% one idea for a quick spot centroid - union(polys) -- centroid()

pg = plot(allSpots);
pg.FaceColor = 'red';
pg.FaceAlpha = 1;
hold on;

ppet=plot(pet(1));
ppet.FaceColor = 'blue';
hold on;

plot(x,y, '-s', 'MarkerSize', 10,...
    'MarkerEdgeColor','black',...
    'MarkerFaceColor','black');
hold off





%% side note, what do the petal polygons look like in the flowers where spots look like they 
%% interfered with the petal outline


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


#################################################

## lets delve back into our python digitization process.

## while we are making our polygons, can we add hand digitizing and 
## corner detection?

## and maybe while we're in here, we see how digitizing from the jpegs works out for us.
## it may be better than Doug's color simplification outputs. 
## doubt it, but it's worth a look

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure, feature
from pprint import pprint 

petal = np.genfromtxt ('P431F1petal.csv', delimiter=",")

petal.shape

petal_marg = np.insert(petal, 439, 1, 1)
petal_marg = np.insert(petal_marg, 0, 1, 1)
petal_marg = np.insert(petal_marg, 561, 1, 0)
petal_marg = np.insert(petal_marg, 0, 1, 0)

Pcontours = measure.find_contours(petal_marg, 0)

## works as before. Now do we use this or the original 
## for corner detection?

## first let's try it on the doug petal outline:

petal_marg = np.transpose(petal_marg)

coords = feature.corner_peaks(
    feature.corner_harris(petal_marg),
    min_distance = 2
)


fig, ax = plt.subplots()
ax.imshow(petal_marg)
plt.show()
ax.plot(coords[:, 1], coords[:, 0], '.b', markersize=5)

## can we smooth/simplify the image a bit?
## or perhaps works better with the contours?

hand = np.array([[1.64516129, 1.16145833],
                 [1.64516129, 1.59375],
                 [1.35080645, 1.921875],
                 [1.375, 2.18229167],
                 [1.68548387, 1.9375],
                 [1.60887097, 2.55208333],
                 [1.68548387, 2.69791667],
                 [1.76209677, 2.56770833],
                 [1.83064516, 1.97395833],
                 [1.89516129, 2.75],
                 [1.9516129, 2.84895833],
                 [2.01209677, 2.76041667],
                 [1.99193548, 1.99479167],
                 [2.11290323, 2.63020833],
                 [2.2016129, 2.734375],
                 [2.25403226, 2.60416667],
                 [2.14919355, 1.953125],
                 [2.30645161, 2.36979167],
                 [2.39112903, 2.36979167],
                 [2.41532258, 2.1875],
                 [2.1733871, 1.703125],
                 [2.07782258, 1.16666667]])



new_hand = hand.copy()

new_hand = measure.subdivide_polygon(new_hand, degree=2, preserve_ends=True)

for _ in range(3):
    new_hand = measure.subdivide_polygon(new_hand, degree=2, preserve_ends=True)

fig, (ax1, ax2) = plt.subplots(ncols=2)

ax1.plot(hand[:, 0],hand[:, 1])
ax1.plot(new_hand[:, 0],new_hand[:, 1])

## interesting. awesome smoothing algorithm

## can we do something like this with our petal outline?

plt.ion()

Pcontours = measure.find_contours(petal_marg, 0)

new_contours = measure.subdivide_polygon(Pcontours[0], degree=2, preserve_ends=True) 

for _ in range(5):
    new_contours = measure.subdivide_polygon(Pcontours[0], degree=2, preserve_ends=True) 

fig, (ax1, ax2) = plt.subplots(ncols=2)
ax1.plot(Pcontours[0][:,0], Pcontours[0][:,1])
ax2.plot(new_contours[:,0], new_contours[:,1])

## doesn't really work, we need sort of the opposite here. Can we put hard corners on our
## petal outline?

aa = measure.approximate_polygon(Pcontours[0], tolerance=9)
fig, (ax1, ax2) = plt.subplots(ncols=2)
ax1.plot(Pcontours[0][:,0], Pcontours[0][:,1])
ax2.plot(aa[:,0], aa[:,1])

plt.show()

## now we're in business. Can we use this to find our corners?

coords = feature.corner_peaks(
    feature.corner_harris(aa),
    min_distance = 2
)


fig, (ax1, ax2, ax3) = plt.subplots(ncols=3)
ax1.plot(Pcontours[0][:,0], Pcontours[0][:,1])
ax2.plot(aa[:,0], aa[:,1])
ax3.plot(aa[:,0], aa[:,1])

## anyway, can we use aa to detect our bottom vertices?

aa[:,1]

aa[:,0]

aa[:,1], aa[:,0]

aa[

np.hstack((aa[:,1], aa[:,0]))

np.concatenate(aa[:,1], aa[:,0], axis = 1)

np.concatenate( [ np.array( [ [1,2], [2,3] ] ), np.array( [ [3],[4] ] ) ] , axis = 1)


bb = np.concatenate([aa[:,1],aa[:,0]], axis = 1)

fig, ax1 = plt.subplots()
ax1.plot(bb[:,0],bb[:,1])


np.array([[1,2],[3,4],[5,6]])

## back on this, where were we?

## oh yeah, can we modify our python digitization script to include finding the bottom corners 
## of our petals?

##############################

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, io, filters, measure, feature
from pprint import pprint 

#plt.ion()

petalFile=('P431F1petal.csv')

petal = np.genfromtxt (petalFile, delimiter=",")


petal.shape[0]
petal.shape[1]

petal_marg = np.insert(petal, petal.shape[1], 1, 1)
petal_marg = np.insert(petal_marg, 0, 1, 1)
petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
petal_marg = np.insert(petal_marg, 0, 1, 0)

Pcontours = measure.find_contours(petal_marg, 0)
aa = measure.approximate_polygon(Pcontours[0], tolerance=9)

## get corners.. how?
## in these inverted images, these should be the highest points:
bb = aa.copy()
bb = bb[bb[:,1].argsort()[::-1]]
cc = bb[0:2,:]

fig, (ax1, ax2, ax3) = plt.subplots(ncols=3)
ax1.plot(Pcontours[0][:,0], Pcontours[0][:,1])
ax2.plot(aa[:,0], aa[:,1])
ax3.plot(aa[:,0], aa[:,1])
ax3.plot(aa[:,0], aa[:,1], 'ro') ## show vertices
ax3.plot(cc[:,0], cc[:,1], 'yo', fillstyle='none',markersize=10, linewidth=3) ## show vertices


## does this work with other petals? how about our side petals?

################### write a function #######
#!/usr/bin/env python3

## petal is single binary petal outline
## petal matrix ouputted from 
## doug's color simplification pipeline
## as a CSV

import numpy as np
import matplotlib.pyplot as plt
import shapely as sh
from skimage import data, io, filters, measure, feature

def digitizePols(petalFile):
    ## pad margins of image and get the contour of the petal shape
    petal = np.genfromtxt (petalFile, delimiter=",")
    petal_marg = np.insert(petal, petal.shape[1], 1, 1)
    petal_marg = np.insert(petal_marg, 0, 1, 1)
    petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
    petal_marg = np.insert(petal_marg, 0, 1, 0)
    Pcontours = measure.find_contours(petal_marg, 0)
    simplePoly = measure.approximate_polygon(Pcontours[0], tolerance=9)
    ## get corners
    ## in these inverted images, these should be the highest points:
    bb = simplePoly.copy()
    bb = bb[bb[:,1].argsort()[::-1]]
    corners = bb[0:2,:]
    return(Pcontours[0],simplePoly,corners) 

##############

## does it work?

petalFile=('P431F1petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)

def plotCor(Pcontours,simplePoly,corners):
    fig, (ax1, ax2, ax3, ax4) = plt.subplots(ncols=4)
    ax1.plot(Pcontours[:,0], Pcontours[:,1])
    ax2.plot(simplePoly[:,0], simplePoly[:,1])
    ax3.plot(simplePoly[:,0], simplePoly[:,1])
    ax3.plot(simplePoly[:,0], simplePoly[:,1], 'ro') ## show vertices
    ax3.plot(corners[:,0], corners[:,1], 'yo', fillstyle='none',markersize=10, linewidth=3) ## show vertices
    ax4.plot(Pcontours[:,0], Pcontours[:,1])
    ax4.plot(corners[:,0], corners[:,1], 'ro', fillstyle='none',markersize=10, linewidth=3) ## show vertices

## try side petals:

petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P431F1/mid/P431F1_mid_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
plotCor(Pcontours,simplePoly,corners)

petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P431F1/left/P431F1_left_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
plotCor(Pcontours,simplePoly,corners)

plt.savefig('P431F1_left_corners.png')
## doesn't capture our upper petal corners...

## how about some other bottom petals:


petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P375F2/left/P375F2_left_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
plotCor(Pcontours,simplePoly,corners)

## oops, that was an upper petal, but it worked!

plt.savefig('P375F2_left_corners.png')

## anyway other lower petals:

petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P375F2/right/P375F2_right_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)

petalFile=('/Users/danthomas/Documents/speckling/make_polygons/polygons/P401F2/right/P401F2_right_petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
plotCor(Pcontours,simplePoly,corners)

plt.savefig('P401F2_right_corners.png')

####################################


## works pretty well. 

## can we get our polygons into shapely objects?

## the goal is have the zones demarcated as part of the digitization 
## process. 

## to get our outline as a shapely polygon:

import shapely.geometry as sg
import shapely.affinity as sa

testP = sg.asPolygon(Pcontours)

xs, ys = testP.exterior.xy

fig, ax1 = plt.subplots()
ax1.fill(xs, ys)

## works. can we simplify?

s = testP.simplify(5, preserve_topology=False)

xsimp, ysimp = s.exterior.xy
fig, (ax1,ax2) = plt.subplots(ncols=2)
ax1.fill(xs, ys)
ax2.fill(xsimp, ysimp)

## let's make a plot function:

def plpo(pol, cl='blue'):
    xs, ys = pol.exterior.xy
    fig, ax1 = plt.subplots()
    ax1.fill(xs, ys)
    ax2.fill(xsimp, ysimp)

plpo(testP)

## okay, can we get the inside polygon?

## wait, first, let's scale and center

## how to do this in python?

petalFile=('P431F1petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)

testP = sg.asPolygon(Pcontours)
xs, ys = testP.exterior.xy
fig, ax1 = plt.subplots()
ax1.fill(xs, ys)

## how can we scale this? just multiply by square root?

## find the scalar 
bb = testP.area
#sc = bb**(1/2)
sc = bb**(-1/2)

## scale
dd = sa.scale(testP, xfact=sc, yfact=sc) 


## recenter (translate to origin)

## get center

cent = dd.centroid

cX, cY = cent.xy

(-1*cX[0])

ee = sa.translate(dd, (-1*cX[0]), (-1*cY[0]))

plpo(ee)

ee.area

##so a function for this, accepts a numpy array of points.
## so we can accept the array from skimage:

def standPet(pet):
    import shapely.geometry as sg
    import shapely.affinity as sa
    aa = sg.asPolygon(pet)
    bb = aa.area
    sc = bb**(-1/2)
    dd = sa.scale(aa, xfact=sc, yfact=sc) 
    ee = dd.centroid
    cX, cY = ee.xy
    ff = sa.translate(dd, (-1*cX[0]), (-1*cY[0]))
    return(ff)

## for spots?

def digitizePols(petalFile):
    ## pad margins of image and get the contour of the petal shape
    petal = np.genfromtxt (petalFile, delimiter=",")
    petal_marg = np.insert(petal, petal.shape[1], 1, 1)
    petal_marg = np.insert(petal_marg, 0, 1, 1)
    petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
    petal_marg = np.insert(petal_marg, 0, 1, 0)
    Pcontours = measure.find_contours(petal_marg, 0)
    simplePoly = measure.approximate_polygon(Pcontours[0], tolerance=9)
    ## get corners
    ## in these inverted images, these should be the highest points:
    bb = simplePoly.copy()
    bb = bb[bb[:,1].argsort()[::-1]]
    corners = bb[0:2,:]
    return(Pcontours[0],simplePoly,corners) 

spotsFile=('P431F1spots.csv')

testS = digitizePols('P431F1spots.csv')

def standFlower(pet, spots=None):
    import shapely.geometry as sg
    import shapely.affinity as sa
    ## get petal outline standardized, get center and scale
    aa = sg.asPolygon(pet)
    bb = aa.area
    sc = bb**(-1/2)
    dd = sa.scale(aa, xfact=sc, yfact=sc) 
    ee = dd.centroid
    cX, cY = ee.xy
    ff = sa.translate(dd, (-1*cX[0]), (-1*cY[0]))
    ## try spots
    if spots is not None: 


can this be a list comprehension?

def standFlower(pet, spots=None):
    import shapely.geometry as sg
    import shapely.affinity as sa

def getinfo(pet):
    aa = sg.asPolygon(pet)
    area = aa.area
    scalar = area**(-1/2)
    center = aa.centroid
    return(scalar, center)

getinfo(

    def stand(pol):
        ispot = sg.asPolygon(i)
        iscaled = sa.scale(ispot, xfact=sc, yfact=sc)
        itrans = sa.translate(iscaled, (-1*cX[0]), (-1*cY[0]))
        return(itrans)


    iStand = [ stand(i) for i in spots ]

pols=(ff, 
    return(pols)

## try it out:

petalFile=('P431F1petal.csv')
Pcontours, simplePoly, corners = digitizePols(petalFile)
testP = standPet(Pcontours)

plpo(testP)

testP.area

## order would be:

## doug's stuff --> sckimage contours --> shapely polygon processing

## so


######## head is spinning. start over from a csv from doug's color simplifications


petalFile=('P431F1petal.csv')
spotsFile=('P431F1spots.csv')


## 1 get our polygons from our petals and spots:

def digitizePols(file):
    import numpy as np
    from skimage import measure
    ## pad margins of image and get the contour of the petal shape
    petal = np.genfromtxt (file, delimiter=",")
    petal_marg = np.insert(petal, petal.shape[1], 1, 1)
    petal_marg = np.insert(petal_marg, 0, 1, 1)
    petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
    petal_marg = np.insert(petal_marg, 0, 1, 0)
    Pcontours = measure.find_contours(petal_marg, 0)
    ## gotta ditch <3 points, they are lines
    polys = [ i for i in Pcontours if len(i) > 3 ]
    return(polys)


testP = digitizePols(petalFile)[0] ## for petals, take first polygon, always seems to work?
testS = digitizePols(spotsFile)

## 2 get information about centroid and scaling factor:

def getPetGeoInfo(pet):
    aa = sg.asPolygon(pet)
    area = aa.area
    scalar = area**(-1/2)
    center = aa.centroid.wkt
    centerCoor = (cX[0], cY[0])
    return(scalar, centerCoor)

scale, cent = getPetGeoInfo(testP)

## 3 standardize petals

def stand(pol, scale, cent):
    aa = sg.asPolygon(pol)
    trans = sa.translate(aa, (-1*cent[0]), (-1*cent[1]))
    scaled = sa.scale(trans, xfact=scale, yfact=scale, origin = (0,0))
    return(scaled)

standPet = stand(testP, scale, cent)

## 4 standardize spots

spotz = [ stand(i, scale, cent) for i in testS ]

## can we take a look at this?

## 5 get the corners:




fig, ax1 = plt.subplots()
xs, ys = standPet.exterior.xy
#xs, ys = trans.exterior.xy
#xs, ys = scaled.exterior.xy
ax1.fill(xs, ys, "y")
for i in spotz:
    xs, ys = i.exterior.xy
    ax1.fill(xs, ys, "r")
  

###########

## python
import numpy as np
import matplotlib.pyplot as plt
import shapely.geometry as sg
import shapely.affinity as sa
from skimage import data, io, filters, measure

def digitizePols(file):
    ## pad margins of image and get the contour of the petal shape
    petal = np.genfromtxt (file, delimiter=",")
    petal_marg = np.insert(petal, petal.shape[1], 1, 1)
    petal_marg = np.insert(petal_marg, 0, 1, 1)
    petal_marg = np.insert(petal_marg, petal.shape[0], 1, 0)
    petal_marg = np.insert(petal_marg, 0, 1, 0)
    Pcontours = measure.find_contours(petal_marg, 0)
    ## gotta ditch <3 points, they are lines
    polys = [ i for i in Pcontours if len(i) > 3 ]
    return(polys)

def getPetGeoInfo(pet):
    aa = sg.asPolygon(pet)
    area = aa.area
    scalar = area**(-1/2)
    center = aa.centroid.wkt
    centerCoor = (center[0], center[1])
    return(scalar, centerCoor)

def getPetGeoInfo(pet):
    aa = sg.asPolygon(pet)
    area = aa.area
    scalar = area**(-1/2)
    center = aa.centroid
    centerCoor = (center.x, center.y)
    return(scalar, centerCoor)

def stand(pol, scale, cent):
    aa = sg.asPolygon(pol)
    trans = sa.translate(aa, (-1*cent[0]), (-1*cent[1]))
    scaled = sa.scale(trans, xfact=scale, yfact=scale, origin = (0,0))
    return(scaled)

## we have an example "right" or lower petal example in our wd:
petalFile=('P431F1petal.csv')
spotsFile=('P431F1spots.csv')

## 1 make our raw, unscaled, untranslated polygons:
testP = digitizePols(petalFile)[0] ## for petals, take first polygon, always seems to work?
testS = digitizePols(spotsFile)

## 2 get information about centroid and scaling factor:
scale, cent = getPetGeoInfo(testP)

